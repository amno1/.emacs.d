!# -*- eval: (progn (setq org-startup-folded 'overview) (org-babel-goto-named-src-block "onstartup") (org-babel-execute-src-block)); -*-
* About
** To fix
   [[https://dev.to/viglioni/how-i-set-up-my-emacs-for-typescript-3eeh]]
   https://github.com/clemera/helm-ido-like-guide
** Introduction
   A very personal and opinionated setup, based on an own code generator. The
   idea with generator is to generate a machine specific setup, so no probing
   for packages, files, paths etc is needed, as well as to perform some
   optimizations automatically and some that are normally not possible.

   This is/was mainly a learning experience to learn Emacs Lisp, but I do use it
   personally for my Emacs setup. It is a lazy-loaded setup, based on built-in
   (and hacked) package.el.

   The setup assumes some environment variables defined in both GNU/Linux and MS
   Windows:

   - BROWSER I use firefox-developer-edition on both OS:s.
   - HOME    Need to be defined on MS Windows, I use %UserProfile%

   This setup also assumes Emacs to run in a Unix-like environment with all the
   standard GNU tools available, so on MS Windows mingw environemnt needs to be
   present and configured. I haven't tested with Cygwin, but I guess it should
   probably work. On MS Windows you also have to enable symlinks for hacked
   package.el to work.

   Package.el is hacked so it let me use symlinks to local packages. The purpose
   is to be able to hack on a repository without need to have two copies, one
   working and one in elpa directory. I will though replace this with a
   different approach I have in mind, on some beautiful day I have time to
   implement it .. :).
   
** Licence
   GNU General Public License, see the attached LICENSE file
   or visit <https://www.gnu.org/licenses/> for the details.
* Generator
#+NAME: onstartup
#+begin_src emacs-lisp :results output silent
  (defvar init-file-bake-autoloads t)
  (defvar init-file-verbose-messages nil)
  (defvar init-file-unroll-key-bindings t)
  (defvar init-file-use-modules nil)
  (defvar init-file-etc-directory (expand-file-name "etc/" user-emacs-directory))
  (defvar init-file-lisp-directory (expand-file-name "lisp/" user-emacs-directory))
  (defvar init-file-source-repositories (list package-user-dir init-file-lisp-directory))
  (defvar init-file--autoloads-map (make-hash-table :test 'equal))
  (defvar init-file--loadpaths-map (make-hash-table :test 'equal))
  (defvar init-file--need-package-refresh t)

  ;; (load (expand-file-name "./lisp/package.el")) ;; use hacked-package.el

  ;; (if (equal system-name "HP-Laptop")
  ;;     (setq package-gnupghome-dir "/c/Users/HP/.emacs.d/elpa/gnupg"))

  (setq package-archives nil)
  ;;(defvar site-archive '("local" . "/home/arthu/repos/"))
  (defvar melpa-archive '("melpa" . "https://melpa.org/packages/"))
  (defvar nelpa-archive '("nelpa" . "https://elpa.nongnu.org/nongnu/"))
  (defvar gnu-archive '("elpa" . "https://elpa.gnu.org/packages/"))

  ;;(add-to-list 'package-archives site-archive)
  (add-to-list 'package-archives gnu-archive)
  (add-to-list 'package-archives nelpa-archive)
  (add-to-list 'package-archives melpa-archive)

  (unless (file-directory-p init-file-etc-directory)
    (make-directory init-file-etc-directory))
  (unless (boundp 'init-file-hooks)
    (make-variable-buffer-local 'init-file-hooks))
  (unless (boundp 'init-file-package-list)
    (make-variable-buffer-local 'init-file-package-list))

  (cl-defstruct package
    (name "")
    (enabled t)
    (pseudo nil)
    (pinned nil)
    (code-beg 0)
    (code-end 0)
    (url ""))

  (defun on-buffer-change-hook (beg eng len)
    (setq init-file-package-list nil))
  (add-hook 'after-change-functions 'on-buffer-change-hook)

  (defmacro on-hook (name &rest body)
    (declare (indent defun))
    (let (found hook)
      (setq name (if (string-match "-hook\\'" (symbol-name `,name))
                     `,name
                   (intern (concat (symbol-name name) "-hook"))))
      (setq body (nreverse body))
      (dolist (hook init-file-hooks)
        (when (equal (symbol-name (car hook)) (symbol-name name))
          (dolist (sexp (nreverse (cdr hook)))
            (add-to-list 'body sexp))
          (setcdr hook body)
          (setq found t)))
      (unless found
        (add-to-list 'init-file-hooks (cons name body)))
      (ignore)))

  (defun verbose (format-string &rest args )
    (when init-file-verbose-messages
      (apply #'message format-string args)))

  (defun clean-init-file ()
    (interactive)
    (with-temp-buffer
      (insert-file-contents "init.el")
      (beginning-of-buffer)
      (while (not (eobp))
        (when (char-equal (char-after) ?\^M)
          (delete-char 1))
        (forward-char 1))
      (write-region (point-min) (point-max) "init.el")))

  (defmacro on-package (name &rest body)
    (declare (indent defun))
    (verbose "Parsing package %s" name)
    (let ((package (symbol-name name)))
      (append-to-init-file "(with-eval-after-load ")
      (append-to-init-file (concat "'" package "\n "))
      (emit-to-init-file body)
      (append-to-init-file ")\n")))

  (defmacro on-idle (&rest body)
    (declare (indent defun))
    `(run-with-idle-timer 0.5 nil (lambda () ,@body)))

  (defmacro on-system (systype &rest body)
    (declare (indent defun))
    (when (equal system-type systype)
      `(progn ,@body)))

  (defmacro on-host (host &rest body)
    (declare (indent defun))
    (when (equal system-name host)
      `(progn ,@body)))

  (defmacro defkeys (mapname &rest body)
    (declare (indent defun))
    `(let ((defs '(,@body)))
       (while defs
         (define-key ,mapname
                     (if (vectorp (car defs))
                         (car defs)
                       (read-kbd-macro (car defs)))
                     (if (or (listp (cadr defs)) (functionp (cadr defs)))
                         (cadr defs)
                       (if `(keymapp (bound-and-true-p ,(cadr defs)))
                           (eval (cadr defs)))))
         (setq defs (cddr defs)))))

  (defun emit-defkeys (map keys)
    (while keys
      (append-to-init-file
       (concat "(define-key "  (symbol-name map) " "
               (if (vectorp (car keys))
                   (prin1-to-string (car keys))
                 (concat "(kbd \"" (car keys) "\")"))
               " #'" (prin1-to-string (cadr keys))
               ")"))
      (setq keys (cddr keys))))

  (defun emit-on-idle (sexp)
    (append-to-init-file
     (format "(run-with-idle-timer 0.5 nil (lambda () %s))" sexp)))

  (defun append-to-init-file (data &optional file)
    (unless file (setq file "init.el"))
    (let (insert-point)
      (cond ((stringp data)
             (write-region data nil file t 0))
            ((bufferp data)
             (with-current-buffer data
               (write-region (point-min) (point-max) file t 0))))))

  (defun emit-sexp-to-init-file (sexp)
    (if init-file-unroll-key-bindings
        (cond ((equal (car sexp) 'defkeys)
               (emit-defkeys (cadr sexp) (cddr sexp)))
              ((equal (car sexp) 'on-system)
               (when (equal (cadr sexp) system-type)
                 (emit-to-init-file (cddr sexp))))
              ((equal (car sexp) 'on-idle)
               (emit-on-idle (cadr sexp)))
              (t
               (append-to-init-file (prin1-to-string sexp))))
      (append-to-init-file (prin1-to-string sexp))))

  (defun emit-to-init-file (&rest body)
    (dolist (sexp body)
      (if (listp (car sexp))
          (dolist (s sexp)
            (emit-sexp-to-init-file s))
        (emit-sexp-to-init-file sexp))))

  (defun emit-packages ()
    (message "Emiting packages ...")
    (dolist (p (get-package-list))
      (verbose "Checking package: %s" (package-name p))
      (when (package-enabled p)
        (verbose "Emiting package: %s" (package-name p))
        (eval-region (package-code-beg p) (package-code-end p)))))

  (defun emit-hooks ()
    (message "Emiting hooks ...")
    (dolist (hook init-file-hooks)
      (verbose "Hook: %s" (car hook))
      (if (equal (symbol-name (car hook)) "early-init-hook")
          (dolist (elt (nreverse (cdr hook)))
            (append-to-init-file (prin1-to-string elt) "early-init.el"))
        (progn
          (append-to-init-file (concat "(add-hook '"
                                       (symbol-name (car hook))
                                       " #'(lambda nil\n"))
          (dolist (s (cdr hook))
            (emit-to-init-file s))
          (append-to-init-file "))")))))

  (defun get-load-paths()
    (let ((elpa (expand-file-name "elpa" user-emacs-directory))
          (archives (expand-file-name "elpa/archives" user-emacs-directory))
          package-paths)
      (dolist (path (directory-files elpa t directory-files-no-dot-files-regexp))
        (when (file-directory-p path)
          (unless (string= path archives)
            (push path package-paths))))
      (push init-file-lisp-directory package-paths)
      package-paths))

  (defun emit-load-paths ()
    (message "Emitting load-path")
    (append-to-init-file (concat "\n(nconc load-path '"
                                 (prin1-to-string (get-load-paths))
                                 ")\n")
                         "early-init.el"))

  (defun quotedp (sym)
    (if (and (consp sym) (eq (car sym) 'quote))
        sym `(quote ,sym)))

  (defun interactivep (form)
    "Wether form is an interactive command."
    (catch 'interactive
      (dolist (sxp form)
        (and (listp sxp) (eq 'interactive (car sxp))
             (throw 'interactive t)))))

  (defun macro-p (form)
    "Wether FORM is a macro definition."
    (eq (car form) 'defmacro))

  (defun collect-autoloads (src)
    (verbose "Collecting autoloads for file: %s" src)
    (let (sxp sym interactive macro file)
      (with-current-buffer (get-buffer-create "*ql-buffer*")
        (erase-buffer)
        (insert-file-contents src)
        (goto-char (point-min))
        (while (re-search-forward "^;;;###autoload" nil t)
          (setq sxp nil sym nil)
          (setq sxp (ignore-errors (read (current-buffer))))
          (when (listp sxp)
            (setq sym (quotedp (cadr sxp))
                  interactive (interactivep sxp)
                  macro (macro-p sxp)
                  file (file-name-nondirectory src))
            (unless (listp (cadr sym))
              (puthash sym (list 'autoload sym file nil interactive macro)
                       init-file--autoloads-map)))))))

  (defun generate-autoloads (dir-tree-or-dir-tree-list &optional outfile)
    (let ((index 0) srcs package-activated-list pkgname
          (tofile (or outfile (expand-file-name "autoloads.el" user-emacs-directory))))
      (if (listp dir-tree-or-dir-tree-list)
          (dolist (dir-tree dir-tree-or-dir-tree-list)
            (setq srcs
                  (nconc srcs (directory-files-recursively dir-tree "\\.el$" nil t t))))
        (setq srcs
              (directory-files-recursively dir-tree-or-dir-tree-list "\\.el$" nil t t)))
      (dolist (src srcs)
        (when (string-match-p "-pkg\\.el" src)
          (push (make-symbol (file-name-base src)) package-activated-list))
        (when (and (not (string-match-p "-pkg\\.el" src))
                   (not (string-match-p "-autoloads\\.el" src)))
          (collect-autoloads src)))
      (with-temp-file tofile
        (maphash (lambda (sym sxp)
                   (prin1 sxp (current-buffer)) (insert "\n"))
                 init-file--autoloads-map)
        (pp `(setq package-activated-list
                   (append ',package-activated-list
                           package-activated-list))
            (current-buffer)))
      (kill-buffer (get-buffer-create "*ql-buffer*")))
    (message "gen autoloads done"))

  (defun emit-autoloads ()
    (message "Emiting autoloads")
    (let ((al (expand-file-name "autoloads.el" user-emacs-directory)))
      (verbose "Generating autoloads: %s" al)
      (generate-autoloads init-file-source-repositories)))

  (defsubst maybe-remove-file (file)
    (when (file-exists-p file)
      (delete-file file)
      (message "Removed file %s" file)))

  (defun tangle-init-file (&optional file)
    (message "Exporting init files.")
    (unless file
      (setq file "init.el"))
    (maybe-remove-file "init.el")
    (maybe-remove-file "init.elc")
    (maybe-remove-file "early-init.el")
    (with-temp-file "init.el"
      (insert ";; init.el -*- lexical-binding: t; -*-\n")
      (insert ";; This file is machine generated by init-file generator, don't edit\n")
      (insert ";; manually, edit instead file init.org and generate new init file from it.\n\n"))
    (with-temp-file "early-init.el"
      (insert ";; early-init.el -*- lexical-binding: t; -*-\n")
      (insert ";; This file is machine generated by init-file generator, don't edit\n")
      (insert ";; manually, edit instead file init.org and generate new init file from it.\n\n"))
    (setq init-file-hooks nil)
    ;; are we baking quickstart file?
    (when init-file-bake-autoloads
      (emit-autoloads)
      (with-temp-buffer
        (insert-file-contents-literally "autoloads.el")
        (append-to-init-file (current-buffer))))
    ;; generate stuff
    (emit-packages)
    ;; do this after user init stuff
    (emit-hooks) ;; must be done after emiting packages
    (emit-load-paths);; must be done after emiting hooks
    ;; fix init.el
    (append-to-init-file "\n;; Local Variables:\n")
    (append-to-init-file ";; coding: utf-8\n")
    (append-to-init-file ";; byte-compile-warnings: '(not docstrings free-vars))\n")
    (append-to-init-file ";; End:\n")
    (clean-init-file))

  (defun goto-code-start (section)
    (goto-char (point-min))
    (re-search-forward section)
    (re-search-forward "begin_src.*emacs-lisp")
    (skip-chars-forward "\s\t\n\r"))

  (defun goto-code-end ()
    (re-search-forward "end_src")
    (beginning-of-line))

  (defun generate-init-files ()
    (interactive)
    (message "Exporting init.el ...")
    (tangle-init-file)
    (setq byte-compile-warnings nil)
    (let ((tangled-file "init.el")
          (byte-compile-warnings nil)
          (fill-column 240))
      ;; always produce elc file
      (byte-compile-file tangled-file)
      (verbose "Byte compiled %s" tangled-file)
      (when (featurep 'native-compile)
        (native-compile tangled-file)
        (verbose "Tangled and compiled %s" tangled-file))
      (verbose "Done.")
      (message "Compiling early-init.el ...")
      (byte-compile-file (expand-file-name "early-init.el"  user-emacs-directory))
      (message "Done.")))

  (defun install-file (file)
    (when (file-exists-p file)
      (unless (equal (file-name-directory buffer-file-name)
                     (expand-file-name user-emacs-directory))
        (copy-file file user-emacs-directory t))
      (message "Wrote: %s." file)))

  (defun install-init-files ()
    (interactive)
    (let ((i "init.el")
          (ic "init.elc")
          (ei "early-init.el")
          (al "autoloads.el")
          (pq (expand-file-name "package-quickstart.el" user-emacs-directory))
          (pqc (expand-file-name "package-quickstart.elc" user-emacs-directory)))
      (install-file i)
      (install-file ei)
      (unless (file-exists-p ic)
        (byte-compile (expand-file-name el)))
      (install-file ic)
      (unless init-file-bake-autoloads
        (byte-compile pq))
      (when init-file-bake-autoloads
        ;; remove package-quickstart files from .emacs.d
        (when (file-exists-p pq)
          (delete-file pq))
        (when (file-exists-p pqc)
          (delete-file pqc)))))

  (defmacro gt (n1 n2)
    `(> ,n1 ,n2))
  (defmacro gte (n1 n2)
    `(>= ,n1 ,n2))
  (defmacro lt (n1 n2)
    `(< ,n1 ,n2))
  (defmacro lte (n1 n2)
    `(<= ,n1 ,n2))

  (defun read-package-spec ()
    ;; format:
    ;; [name enabled pseudo pinned-to code-beg-pos code-end-pos fetch-url]
    (let ((package (make-package))
          (packages nil)
          (header-beg (point))
          (header-end (line-end-position)))
      ;; package name
      (goto-char header-end)
      (search-backward "] " header-beg t)
      (forward-char)
      (setf (package-name package)
            (string-trim
             (buffer-substring-no-properties (point) header-end)))
      (goto-char header-beg)
      ;; are we "pinned" to something
      (if (re-search-forward "\\[ \\(.*\\) \\]" header-end t)
          (let ((s (string-trim (match-string 1))))
            (set-text-properties 0 (length s) nil s)
            (setf (package-pinned package) s
                  header-beg (point))
            (when (equal s "vc")
              (forward-line)
              (if (not (search-forward "#+url" (line-end-position) t))
                  (error
                   "VC specified without URL keyword: %s line %s"
                   (package-name package) (1- (line-number-at-pos)))
                (unless (setf (package-url package)
                              (string-trim
                               (buffer-substring-no-properties (point)
                                                               (line-end-position))))
                  (error "VC specified, but no URL given %s line %s"
                         (package-name package) (1- (line-number-at-pos))))))))
      ;; pseudo package?
      (when (equal (package-pinned package) "none")
        (setf (package-pseudo package) t))
      ;; enabled?
      (when (looking-at-p "\\[ \\]")
        (setf (package-enabled package) nil))
      ;; code start
      (re-search-forward "begin_src.*emacs-lisp")
      (setf (package-code-beg package) (point))
      (search-forward "end_src")
      (goto-char (line-beginning-position))
      (setf (package-code-end package) (- (point) 1))
      (goto-char (line-end-position))
      package))

  (defun get-package-list (&optional force)
    (when (or (buffer-modified-p) force)
      (setq init-file-package-list nil))
    (unless init-file-package-list
      (save-excursion
        (goto-char (point-min))
        (verbose "Creating package list ...")
        (re-search-forward "^\\* Packages")
        (while (re-search-forward "^\\*\\* " (eobp) t)
          (push (read-package-spec) init-file-package-list))))
    init-file-package-list)

  ;; Install packages
  (defun install-package (package)
    (let ((pkg (intern-soft (package-name package)))
          (url (package-url package)))
      (unless (package-installed-p pkg)
        (message "Installing package: %s" package)
        (if (string-empty-p url)
            (package-install pkg)
          (package-vc-install url)))))

  (defun install-packages (&optional packages)
    (interactive)
    (when init-file--need-package-refresh
      (package-refresh-contents)
      (setq init-file--need-package-refresh nil))
    (dolist (p (or packages (get-package-list)))
      (verbose "Current package: %s" (package-name p))
      (and (not (package-pseudo p))
           (package-enabled p)
           (install-package p))))

  (defun current-package ()
    "Return name of package the cursor is at the moment."
    (save-excursion
      (let (nb ne pn (start (point)))
        (when (re-search-backward "^\\* Packages" (point-min) t)
          (setq nb (point))
          (goto-char start)
          (setq pn (search-forward "** " (line-end-position) t 1))
          (unless pn
            (setq pn (search-backward "** " nb t 1)))
          (when pn
            (search-forward "] ")
            (setq nb (point))
            (re-search-forward "[\n[:blank:]]")
            (forward-char -1)
            (setq ne (point))
            (setq pn (buffer-substring-no-properties nb ne))
            pn)))))

  (defun install-and-configure ()
    (interactive)
    (install-packages)
    (generate-init-files)
    (install-init-files))

  (defun configure-emacs ()
    (interactive)
    (generate-init-files)
    (install-init-files))

  (defalias 'vlt 'version-list-<)
  (defun org-init-update-packages ()
    (interactive)
    (package-refresh-contents)
    (dolist (package package-activated-list)
      (let* ((new (cadr (assq package package-archive-contents)))
             (old (cadr (assq package package-alist)))
             to-install)
        (when (and new old (vlt (package-desc-version old) (package-desc-version new)))
          (setq to-install
                (package-compute-transaction (list new) (package-desc-reqs new)))
          (message "Installing package: %S" (package-desc-dir new))
          (package-download-transaction to-install)
          (message "Removed package: %S" (package-desc-dir old))
          (and (file-directory-p (package-desc-dir old))
               (not (file-symlink-p (package-desc-dir old)))
               (delete-directory (package-desc-dir old) t))))))
  
    ;;; org hacks

  ;; https://www.reddit.com/message/unread/
  ;;(require 'cape)

  (if (featurep 'org-heading-checkbox)
      (unload-feature 'org-heading-checkbox))
  (defvar org-init--enabled-re "^[ \t]*\\*+.*?[ \t]*\\[x\\]")
  (defvar org-init--disabled-re "^[ \t]*\\*+.*?[ \t]*\\[ \\]")
  (defvar org-init--checkbox-re "^[ \t]*\\*+.*?\\[[ x]\\]")

  (defun org-init--heading-checkbox-p ()
    "Return t if this is a heading with a checkbox."
    (save-excursion
      (beginning-of-line)
      (looking-at org-init--checkbox-re)))

  (defun org-init--checkbox-enabled-p ()
    "Return t if point is at a heading with an enabed checkbox."
    (save-excursion
      (beginning-of-line)
      (looking-at "^[ \t]*\\*+.*?\\[x\\]")))

  (defun org-init--checkbox-disabled-p ()
    "Return t if point is at a heading with a disabeled checkbox."
    (save-excursion
      (beginning-of-line)
      (looking-at "^[ \t]*\\*+.*?\\[ \\]")))

  (defun org-init--checkbox-enable ()
    "Disable checkbox for heading at point."
    (interactive)
    (when (org-init--checkbox-enabled-p)
      (save-excursion
        (beginning-of-line)
        (replace-string "[ ]" "[x]" nil (line-beginning-position)
                        (line-end-position)))))

  (defun org-init--checkbox-disable ()
    "Disable checkbox for heading at point."
    (interactive)
    (when (org-init--checkbox-enabled-p)
      (save-excursion
        (beginning-of-line)
        (replace-string "[x]" "[ ]" nil (line-beginning-position)
                        (line-end-position)))))

  (defun org-init--checkbox-toggle ()
    "Toggle state of checkbox at heading under the point."
    (interactive)
    (save-excursion
      (beginning-of-line)
      (cond ((looking-at org-init--enabled-re)
             (replace-string "[x]" "[ ]" nil (line-beginning-position)
                             (line-end-position)))
            ((looking-at org-init--disabled-re)
             (replace-string "[ ]" "[x]" nil (line-beginning-position)
                             (line-end-position)))
            (t (error "Not at org-init-checkbox line.")))))

  (defun org-init--packages ()
    "Return start of packages; point after the \"* Packages\" heading."
    (save-excursion
      ;; we search backward, which will find beginning of line if the current
      ;; point is after the heading
      (cond ((re-search-backward "^\\* Packages" (point-min) t)
             (point))
            ;; the point was after the heading, and now we are at the point-min
            ((re-search-forward "^\\* Packages" nil t)
             (beginning-of-line)
             (point))
            ;; we didn't found the Packages section, means invalid file
            (t (error "No Packages section in current file found.")))))

  ;; help fns to work with init.org
  (defun add-package (package)
    (interactive "sPackage name: ")
    (goto-char (org-init--packages))
    (forward-line 1)
    (insert (concat "\n** [x] "
                    package
                    "\n#+begin_src emacs-lisp\n"
                    "\n#+end_src\n"))
    (forward-line -2))

  (defun add-git-package (url)
    (interactive "sGIT url: ")
    (unless (string-empty-p url)
      (let ((tokens (split-string url "/" t "\s\t")) package)
        (message "T: %S" tokens)
        (dolist (tk tokens)
          (setq package tk))
        (goto-char (org-init--packages))
        (forward-line 1)
        (insert (concat "\n** [x] " package
                        "\n#+GIT: " url
                        "\n#+begin_src emacs-lisp\n"
                        "\n#+end_src\n"))
        (forward-line -2))))

  (defun org-init--package-enabled-p ()
    "Return t if point is in a package headline and package is enabled."
    (save-excursion
      (beginning-of-line)
      (looking-at "^[ \t]*\\*\\* \\[x\\]")))

  (defun org-init--toggle-headline-checkbox ()
    "Switch between enabled/disabled todo state."
    (if (org-init--package-enabled-p)
        (org-todo 2)
      (org-todo 1)))

  (defun org-init--package-section-p ()
    (save-excursion
      (let ((current-point (point)))
        (when (re-search-backward "^\\* Packages" nil t)
          (forward-line 1)
          (gte current-point (point))))))

  (defun org-init--shiftup ()
    "Switch between enabled/disabled todo state."
    (interactive)
    (if (org-init--package-section-p)
        (save-excursion
          (beginning-of-line)
          (unless (looking-at org-heading-regexp)
            (re-search-backward org-heading-regexp))
          (if (org-init--heading-checkbox-p)
              (org-init--checkbox-toggle)))
      (org-shiftup)))

  (defun org-init--shiftdown ()
    "Switch between enabled/disabled todo state."
    (interactive)
    (if (org-init--package-section-p)
        (save-excursion
          (beginning-of-line)
          (unless (looking-at org-heading-regexp)
            (re-search-backward org-heading-regexp))
          (if (org-init--heading-checkbox-p)
              (org-init--checkbox-toggle)))
      (org-shiftdown)))

  (defun org-init--shiftright ()
    "Switch between enabled/disabled todo state."
    (interactive)
    (if (org-init--package-section-p)
        (save-excursion
          (beginning-of-line)
          (unless (looking-at org-heading-regexp)
            (re-search-backward org-heading-regexp))
          (org-shiftright))
      (org-shiftright)))

  (defun org-init--shiftleft ()
    "Switch between enabled/disabled todo state."
    (interactive)
    (if (org-init--package-section-p)
        (save-excursion
          (beginning-of-line)
          (unless (looking-at org-heading-regexp)
            (re-search-backward org-heading-regexp))
          (org-shiftleft))
      (org-shiftleft)))

  (defun org-init--open-in-dired ()
    (interactive)
    (if (org-init--package-section-p)
        (save-excursion
          (beginning-of-line)
          (unless (looking-at org-heading-regexp)
            (re-search-backward org-heading-regexp))
          (let ((elpa (expand-file-name "elpa" user-emacs-directory))
                start pkgname pkdir)
            (search-forward "[ " (line-end-position) t)
            (if (search-forward "none" (line-end-position) t)
                (dired (expand-file-name "lisp/" user-emacs-directory) pkdir)
              (progn
                (beginning-of-line)
                (while (search-forward "] " (line-end-position) t) )
                (setq start (point))
                (skip-chars-forward "[a-zA-Z\\-]")
                (setq pkgname (buffer-substring-no-properties start (point)))
                (setq pkdir (directory-files elpa t pkgname t ))
                (if pkdir (dired (car pkdir)))))))))

  (defun org-init--sort-packages ()
    "This is just a convenience wrapper for org-sort. It does reverted sort on
              todo keywords-"
    (interactive)
    (save-excursion
      (goto-char (org-init--packages))
      (org-sort-entries nil ?a) ;; first sort alphabetic than in reversed todo-order
      (org-sort-entries nil ?O)
      (org-cycle) (org-cycle)))

  (defun org-init--goto-package ()
    (interactive)
    (let ((org-goto-interface 'outline-path-completionp)
          (org-outline-path-complete-in-steps nil))
      (org-goto)))

  (defvar org-init-mode-map
    (let ((map (make-sparse-keymap)))
      (define-key org-mode-map [remap org-shiftup] #'org-init--shiftup)
      (define-key org-mode-map [remap org-shiftdown] #'org-init--shiftdown)
      (define-key org-mode-map [remap org-shiftleft] #'org-init--shiftleft)
      (define-key org-mode-map [remap org-shiftright] #'org-init--shiftright)
      (define-key map (kbd "C-c i a") 'add-package)
      (define-key map (kbd "C-c i i") 'install-packages)
      (define-key map (kbd "C-c i p") 'add-pseudo-package)
      (define-key map (kbd "C-c i g") 'generate-init-files)
      (define-key map (kbd "C-c i j") 'org-init--goto-package)
      (define-key map (kbd "C-c C-j") 'org-init--open-in-dired)
      (define-key map (kbd "C-c i s") 'org-init--sort-packages)
      (define-key map (kbd "C-c i u") 'org-init-update-packages)
      map)
    "Keymap used in `org-init-mode'.")

  (defvar org-init-mode-enabled nil)
  (defvar org-init-old-kwds nil)
  (defvar org-init-old-key-alist nil)
  (defvar org-init-old-kwd-alist nil)
  (defvar org-init-old-log-done nil)
  (defvar org-init-old-todo nil)
  (setq org-init-mode-enabled nil org-init-old-kwds nil org-init-old-key-alist nil
        org-init-old-kwd-alist nil org-init-old-log-done nil org-init-old-todo nil)
  (make-variable-buffer-local 'org-log-done)
  (make-variable-buffer-local 'org-todo-keywords)

  (defun org-init--longest-str (lst)
    (let ((len 0) l)
      (dolist (elt lst)
        (setq l (length elt))
        (when (lt len l)
          (setq len l)))
      len))

  (defun org-init--initial-outline ()
    (save-excursion
      (goto-char (point-min))
      (re-search-forward "^\\* About")
      (hide-subtree)
      (re-search-forward "^\\* Generator")
      (hide-subtree)
      (re-search-forward "^\\* Packages")
      (hide-subtree)
      (show-children)))

  (defun org-todo-per-file-keywords (kwds)
    "Sets per file TODO labels. Takes as argument a list of strings to be
                      used as labels."
    (let (alist)
      (push "TODO" alist)
      (dolist (kwd kwds)
        (push kwd alist))
      (setq alist (list (nreverse alist)))
      ;; TODO keywords.
      (setq-local org-todo-kwd-alist nil)
      (setq-local org-todo-key-alist nil)
      (setq-local org-todo-key-trigger nil)
      (setq-local org-todo-keywords-1 nil)
      (setq-local org-done-keywords nil)
      (setq-local org-todo-heads nil)
      (setq-local org-todo-sets nil)
      (setq-local org-todo-log-states nil)
      (let ((todo-sequences alist))
        (dolist (sequence todo-sequences)
          (let* ((sequence (or (run-hook-with-args-until-success
                                'org-todo-setup-filter-hook sequence)
                               sequence))
                 (sequence-type (car sequence))
                 (keywords (cdr sequence))
                 (sep (member "|" keywords))
                 names alist)
            (dolist (k (remove "|" keywords))
              (unless (string-match "^\\(.*?\\)\\(?:(\\([^!@/]\\)?.*?)\\)?$"
                                    k)
                (error "Invalid TODO keyword %s" k))
              (let ((name (match-string 1 k))
                    (key (match-string 2 k))
                    (log (org-extract-log-state-settings k)))
                (push name names)
                (push (cons name (and key (string-to-char key))) alist)
                (when log (push log org-todo-log-states))))
            (let* ((names (nreverse names))
                   (done (if sep (org-remove-keyword-keys (cdr sep))
                           (last names)))
                   (head (car names))
                   (tail (list sequence-type head (car done) (org-last done))))
              (add-to-list 'org-todo-heads head 'append)
              (push names org-todo-sets)
              (setq org-done-keywords (append org-done-keywords done nil))
              (setq org-todo-keywords-1 (append org-todo-keywords-1 names nil))
              (setq org-todo-key-alist
                    (append org-todo-key-alist
                            (and alist
                                 (append '((:startgroup))
                                         (nreverse alist)
                                         '((:endgroup))))))
              (dolist (k names) (push (cons k tail) org-todo-kwd-alist))))))
      (setq org-todo-sets (nreverse org-todo-sets)
            org-todo-kwd-alist (nreverse org-todo-kwd-alist)
            org-todo-key-trigger (delq nil (mapcar #'cdr org-todo-key-alist))
            org-todo-key-alist (org-assign-fast-keys org-todo-key-alist))
      ;; Compute the regular expressions and other local variables.
      ;; Using `org-outline-regexp-bol' would complicate them much,
      ;; because of the fixed white space at the end of that string.
      (unless org-done-keywords
        (setq org-done-keywords
              (and org-todo-keywords-1 (last org-todo-keywords-1))))
      (setq org-not-done-keywords
            (org-delete-all org-done-keywords
                            (copy-sequence org-todo-keywords-1))
            org-todo-regexp (regexp-opt org-todo-keywords-1 t)
            org-not-done-regexp (regexp-opt org-not-done-keywords t)
            org-not-done-heading-regexp
            (format org-heading-keyword-regexp-format org-not-done-regexp)
            org-todo-line-regexp
            (format org-heading-keyword-maybe-regexp-format org-todo-regexp)
            org-complex-heading-regexp
            (concat "^\\(\\*+\\)"
                    "\\(?: +" org-todo-regexp "\\)?"
                    "\\(?: +\\(\\[#.\\]\\)\\)?"
                    "\\(?: +\\(.*?\\)\\)??"
                    "\\(?:[ \t]+\\(:[[:alnum:]_@#%:]+:\\)\\)?"
                    "[ \t]*$")
            org-complex-heading-regexp-format
            (concat "^\\(\\*+\\)"
                    "\\(?: +" org-todo-regexp "\\)?"
                    "\\(?: +\\(\\[#.\\]\\)\\)?"
                    "\\(?: +"
                    ;; Stats cookies can be stuck to body.
                    "\\(?:\\[[0-9%%/]+\\] *\\)*"
                    "\\(%s\\)"
                    "\\(?: *\\[[0-9%%/]+\\]\\)*"
                    "\\)"
                    "\\(?:[ \t]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?"
                    "[ \t]*$")
            org-todo-line-tags-regexp
            (concat "^\\(\\*+\\)"
                    "\\(?: +" org-todo-regexp "\\)?"
                    "\\(?: +\\(.*?\\)\\)??"
                    "\\(?:[ \t]+\\(:[[:alnum:]:_@#%]+:\\)\\)?"
                    "[ \t]*$"))))

  (add-to-list 'org-element-affiliated-keywords "Git")

  ;; from J. Kitchin:
  ;; https://kitchingroup.cheme.cmu.edu/blog/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook/
  (require 'org-mouse)
  (require 'elisp-mode)

  (defun scimax-spoof-mode (orig-func &rest args)
    "Advice function to spoof commands in org-mode src blocks.
            It is for commands that depend on the major mode. One example is
            `lispy--eval'."
    (if (org-in-src-block-p)
        (let ((major-mode (intern (format "%s-mode"
                                          (first (org-babel-get-src-block-info))))))
          (apply orig-func args))
      (apply orig-func args)))

  (defvar scimax-src-block-keymaps
    `(("emacs-lisp"
       .
       ,(let ((map (make-composed-keymap
                    `(,emacs-lisp-mode-map ,org-init-mode-map)
                    org-mode-map)))
          (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
          map))))

  (defun scimax-add-keymap-to-src-blocks (limit)
    "Add keymaps to src-blocks defined in `scimax-src-block-keymaps'."
    (let ((case-fold-search t)
          lang)
      (while (re-search-forward org-babel-src-block-regexp limit t)
        (let ((lang (match-string 2))
              (beg (match-beginning 0))
              (end (match-end 0)))
          (if (assoc (org-no-properties lang) scimax-src-block-keymaps)
              (progn
                (add-text-properties
                 beg end `(local-map ,(cdr (assoc
                                            (org-no-properties lang)
                                            scimax-src-block-keymaps))))
                (add-text-properties
                 beg end `(cursor-sensor-functions
                           ((lambda (win prev-pos sym)
                              ;; This simulates a mouse click and makes a menu change
                              ;; (org-mouse-down-mouse nil)
                              ))))))))))

  (define-minor-mode org-init-mode ""
    :global nil :lighter " init-file"
    (unless (derived-mode-p 'org-mode)
      (error "Not in org-mode."))
    (cond (org-init-mode
           (unless org-init-mode-enabled
             (setq org-init-mode-enabled t
                   org-init-old-log-done org-log-done
                   org-init-old-kwds org-todo-keywords-1
                   org-init-old-key-alist org-todo-key-alist
                   org-init-old-kwd-alist org-todo-kwd-alist)
             (setq-local org-log-done nil)
             (let (s kwdlist templist l)
               (dolist (repo package-archives)
                 (push (car repo) templist))
               (push "vc" templist)
               (push "none" templist)
               (setq l (org-init--longest-str templist))
               (dolist (s templist)
                 (while (lt (length s) l)
                   (setq s (concat s " ")))
                 (push (concat "[ " s " ]") kwdlist))
               (org-todo-per-file-keywords (nreverse kwdlist))))
           (add-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks t)
           (add-to-list 'font-lock-extra-managed-props 'local-map)
           (add-to-list 'font-lock-extra-managed-props 'cursor-sensor-functions)
           ;;(advice-add 'lispy--eval :around 'scimax-spoof-mode)
           (cursor-sensor-mode +1)
           (eldoc-mode +1))
          (t
           (remove-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks)
           ;;(advice-remove 'lispy--eval 'scimax-spoof-mode)
           (cursor-sensor-mode -1)
           (setq org-todo-keywords-1 org-init-old-kwds
                 org-todo-key-alist org-init-old-key-alist
                 org-todo-kwd-alist org-init-old-kwd-alist
                 org-log-done org-init-old-log-done
                 org-init-mode-enabled nil)))
    (font-lock-fontify-buffer))

  (org-init--initial-outline)
  (org-init-mode +1)
#+end_src
* Packages

** [x] common-lisp-snippets
#+begin_src emacs-lisp

#+end_src
** [x] academic-phrases
#+begin_src emacs-lisp
#+end_src
** [x] ace-window
#+begin_src emacs-lisp
(on-package ace-window
  (ace-window-display-mode 1)
  ;;(setq aw-dispatch-always t)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src
** [x] activities
#+begin_src emacs-lisp

#+end_src
** [x] ascii-table
#+begin_src emacs-lisp
#+end_src
** [x] async
#+begin_src emacs-lisp
(on-package
  async
  (async-bytecomp-package-mode 1)
  (on-system windows-nt
    ;; https://gist.github.com/kiennq/cfe57671bab3300d3ed849a7cbf2927c
    (eval-when-compile
      (require 'cl-lib))
    (defvar async-maximum-parallel-procs 4)
    (defvar async--parallel-procs 0)
    (defvar async--queue nil)
    (defvar-local async--cb nil)
    (advice-add #'async-start :around
                (lambda (orig-func func &optional callback)
                  (when (>= async--parallel-procs async-maximum-parallel-procs)
                    (push `(,func ,callback) async--queue)
                    (cl-incf async--parallel-procs)
                    (let ((future (funcall orig-func func
                                           (lambda (re)
                                             (cl-decf async--parallel-procs)
                                             (when async--cb (funcall async--cb re))
                                             (when-let (args (pop async--queue))
                                               (apply #'async-start args))))))
                      (with-current-buffer (process-buffer future)
                        (setq async--cb callback))))))))
(on-hook dired-async-mode (diminish 'dired-async-mode))
#+end_src
** [x] beacon
#+begin_src emacs-lisp
(on-hook after-init (on-idle (beacon-mode t)))
(on-hook beacon-mode (diminish 'beacon-mode))
#+end_src
** [x] buttercup
#+begin_src emacs-lisp
#+end_src
** [x] checkdoc
#+begin_src emacs-lisp
#+end_src
** [x] company
#+begin_src emacs-lisp
#+end_src
** [x] crux
#+begin_src emacs-lisp
#+end_src
** [x] diminish 
#+begin_src emacs-lisp
#+end_src
** [x] dired-hacks-utils
#+begin_src emacs-lisp
#+end_src
** [x] dired-narrow
#+begin_src emacs-lisp
#+end_src
** [x] dired-quick-sort
#+begin_src emacs-lisp
#+end_src
** [x] dired-subtree
#+begin_src emacs-lisp
(on-hook after-init (on-idle (require 'dired-subtree)))
(on-package dired-subtree
  (setq dired-subtree-line-prefix "    "
        dired-subtree-use-backgrounds nil))
#+end_src
** [x] disable-mouse
#+begin_src emacs-lisp

#+end_src
** [x] eask
#+begin_src emacs-lisp

#+end_src
** [x] elnode
#+begin_src emacs-lisp
#+end_src
** [x] el-search
#+begin_src emacs-lisp
#+end_src
** [x] eros
#+begin_src emacs-lisp

#+end_src

** [x] expand-region
#+begin_src emacs-lisp
(on-hook after-init
  (defkeys global-map
    "C-+" er/expand-region
    "C--" er/contract-region))
(on-hook expand-region-mode
  (diminish 'expand-region-mode))
#+end_src
** [x] feebleline
#+begin_src emacs-lisp
#+end_src
** [x] flimenu 
#+begin_src emacs-lisp
(on-package flimenu
  (flimenu-global-mode))
#+end_src
** [x] flycheck 
#+begin_src emacs-lisp
#+end_src
** [x] flycheck-package
#+begin_src emacs-lisp
#+end_src
** [x] gh 
#+begin_src emacs-lisp
#+end_src
** [x] gif-screencast
#+begin_src emacs-lisp
#+end_src
** [x] gist 
#+begin_src emacs-lisp
#+end_src
** [x] git-gutter
#+begin_src emacs-lisp
(on-hook git-gutter
  (setq git-gutter:update-interval 0.02))
#+end_src
** [x] git-gutter-fringe
#+begin_src emacs-lisp
(on-package git-gutter-fringe
  (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
  (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
  (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+end_src
** [x] github-clone
#+begin_src emacs-lisp
#+end_src
** [x] github-search 
#+begin_src emacs-lisp
#+end_src
** [x] git-link 
#+begin_src emacs-lisp
#+end_src
** [x] git-messenger
#+begin_src emacs-lisp
#+end_src
** [x] gnu-elpa-keyring-update
#+begin_src emacs-lisp
#+end_src
** [x] google-c-style 
#+begin_src emacs-lisp
(on-hook google-c-style-mode
  (diminish 'google-c-style-mode))
#+end_src
** [x] goto-last-change
#+begin_src emacs-lisp
#+end_src
** [x] helm 
#+begin_src emacs-lisp
(on-hook after-init (on-idle
                      (require 'helm)
                      (require 'helm-files)
                      (require 'helm-eshell)
                      (require 'helm-buffers)
                      (require 'helm-adaptive)
                      (message "Helm loaded on idle.")))
(on-hook eshell-mode
  (defkeys eshell-mode-map
    "C-c C-h" helm-eshell-history
    "C-c C-r" helm-comint-input-ring
    "C-c C-l" helm-minibuffer-history))
(on-hook helm-ff-cache-mode
  (diminish 'helm-ff-cache-mode))
(on-package helm
  (require 'helm-eshell)
  (require 'helm-buffers)
  (require 'helm-files)
  
  (defun helm-buffer-p (window new-buffer bury-or-kill)
    "Returns T when NEW-BUFFER's name matches any regex in
`helm-boring-buffer-regexp-list'."
    (catch 'helm-p
      (dolist (regex helm-boring-buffer-regexp-list)
        (if (string-match-p regex (buffer-name new-buffer))
            (throw 'helm-p t)))))

  (defvar helm-source-header-default-background (face-attribute
                                                 'helm-source-header :background)) 
  (defvar helm-source-header-default-foreground (face-attribute
                                                 'helm-source-header :foreground)) 
  (defvar helm-source-header-default-box (face-attribute
                                          'helm-source-header :box))
  (set-face-attribute 'helm-source-header nil :height 0.1)
  (defun helm-toggle-header-line ()
    (if (gt (length helm-sources) 1)
        (set-face-attribute 'helm-source-header
                            nil
                            :foreground helm-source-header-default-foreground
                            :background helm-source-header-default-background
                            :box helm-source-header-default-box
                            :height 1.0)
      (set-face-attribute 'helm-source-header
                          nil
                          :foreground (face-attribute 'helm-selection :background)
                          :background (face-attribute 'helm-selection :background)
                          :box nil
                          :height 0.1)))
  
  (setq helm-completion-style             'emacs
        helm-display-header-line              nil
        ;; helm-completion-in-region-fuzzy-match t
        ;; helm-recentf-fuzzy-match              t
        ;; helm-buffers-fuzzy-matching           t
        ;; helm-locate-fuzzy-match               t
        ;; helm-lisp-fuzzy-completion            t
        ;; helm-session-fuzzy-match              t
        ;; helm-apropos-fuzzy-match              t
        ;; helm-imenu-fuzzy-match                t
        ;; helm-semantic-fuzzy-match             t
        ;; helm-M-x-fuzzy-match                  t
        helm-split-window-inside-p            t
        helm-move-to-line-cycle-in-source     t
        helm-ff-search-library-in-sexp        t
        helm-scroll-amount                    8
        helm-ff-file-name-history-use-recentf t
        helm-ff-auto-update-initial-value     nil
        helm-net-prefer-curl                  t
        helm-autoresize-max-height            0
        helm-autoresize-min-height           30
        helm-candidate-number-limit         100
        helm-idle-delay                     0.0
        helm-input-idle-delay               0.0
        switch-to-prev-buffer-skip         'helm-buffer-p
        helm-ff-cache-mode-lighter-sleep    nil
        helm-ff-cache-mode-lighter-updating nil
        helm-ff-cache-mode-lighter          nil
        helm-ff-skip-boring-files            t)
  
  (dolist (regexp '("\\`\\*direnv" "\\`\\*straight" "\\`\\*xref"))
    (push regexp helm-boring-buffer-regexp-list))

  (helm-autoresize-mode 1)
  (helm-adaptive-mode t)
  (helm-mode 1)
  (add-to-list 'helm-sources-using-default-as-input
               'helm-source-man-pages)
  (setq helm-mini-default-sources '(helm-source-buffers-list
                                    helm-source-bookmarks
                                    helm-source-recentf
                                    helm-source-buffer-not-found
                                    projectile-known-projects))
  (defkeys helm-map
    "M-i" helm-previous-line
    "M-k" helm-next-line
    "M-I" helm-previous-page
    "M-K" helm-next-page
    "M-h" helm-beginning-of-buffer
    "M-H" helm-end-of-buffer)

  (defkeys shell-mode-map
    "C-c C-l" helm-comint-input-ring)
  
  (defkeys helm-read-file-map
    ;;"RET" my-helm-return
    "C-o" my-helm-next-source))

(on-hook after-init
  (defkeys global-map
    "M-x"     helm-M-x
    "C-z ,"   helm-pages
    "C-x C-b" helm-buffers-list
    "C-z a"   helm-ag
    "C-z b"   helm-filtered-bookmarks
    ;;                    "C-z c"   helm-company
    "C-z d"   helm-dabbrev
    "C-z e"   helm-calcul-expression
    "C-z g"   helm-google-suggest
    "C-z h"   helm-descbinds
    "C-z i"   helm-imenu-anywhere
    "C-z k"   helm-show-kill-ring
    "C-z C-c" helm-git-local-branches
    "C-z f"   helm-find-files
    "C-z m"   helm-mini
    "C-z o"   helm-occur
    "C-z p"   helm-browse-project
    "C-z q"   helm-apropos
    "C-z r"   helm-recentf
    "C-z s"   helm-swoop
    "C-z C-c" helm-colors
    "C-z x"   helm-M-x
    "C-z y"   helm-yas-complete
    "C-z C-g" helm-ls-git-ls
    "C-z C-b" helm-git-local-branches
    "C-z SPC" helm-all-mark-rings))
(on-hook helm-mode
  ;; (helm-flx-mode +1)
  (diminish 'helm-mode)
  (helm-adaptive-mode 1))
#+end_src
** [ vc    ] [x] helm-rg 
#+url https://github.com/cosmicexplorer/helm-rg
#+begin_src emacs-lisp
(on-package helm-ag
  (setq helm-ag-use-agignore t
        helm-ag-base-command 
        "ag --mmap --nocolor --nogroup --ignore-case --ignore=*terraform.tfstate.backup*"))
#+end_src
** [x] helm-c-yasnippet
#+begin_src emacs-lisp
(on-package helm-c-yasnippet
  (setq helm-yas-space-match-any-greedy t))
#+end_src
** [x] helm-dash
#+begin_src emacs-lisp
#+end_src
** [x] helm-descbinds
#+begin_src emacs-lisp
#+end_src
** [ ] helm-dired-history
#+begin_src emacs-lisp
(on-package helm-dired-history
  (require 'savehist)
  (add-to-list 'savehist-additional-variables
               'helm-dired-history-variable)
  (savehist-mode 1)
  (with-eval-after-load "dired"
    (require 'helm-dired-history)
    (define-key dired-mode-map "," 'dired)))
#+end_src
** [x] helm-flyspell
#+begin_src emacs-lisp
#+end_src
** [x] helm-fuzzier
#+begin_src emacs-lisp
#+end_src
** [ ] helm-git-grep
#+begin_src emacs-lisp
#+end_src
** [x] helm-make
#+begin_src emacs-lisp
#+end_src
** [x] helm-navi
#+begin_src emacs-lisp
#+end_src
** [x] helm-org
#+begin_src emacs-lisp
#+end_src
** [x] helm-pages
#+begin_src emacs-lisp
#+end_src
** [x] helm-projectile
#+begin_src emacs-lisp
#+end_src
** [x] helm-rg
#+begin_src emacs-lisp

#+end_src

** [x] helm-sly 
#+begin_src emacs-lisp
#+end_src
** [x] helm-smex 
#+begin_src emacs-lisp
#+end_src
** [ ] helm-swoop 
#+begin_src emacs-lisp
#+end_src
** [x] helm-xref
#+begin_src emacs-lisp
#+end_src
** [x] helpful
#+begin_src emacs-lisp

#+end_src
** [x] hnreader
#+begin_src emacs-lisp

#+end_src
** [x] ht
#+begin_src emacs-lisp
#+end_src
** [x] htmlize
#+begin_src emacs-lisp
#+end_src

** [x] hydra
#+begin_src emacs-lisp
(on-package hydra
  (defkeys global-map
    "C-x t"
    (defhydra toggle (:color blue)
      "toggle"
      ("a" abbrev-mode "abbrev")
      ("s" flyspell-mode "flyspell")
      ("d" toggle-debug-on-error "debug")
      ("c" fci-mode "fCi")
      ("f" auto-fill-mode "fill")
      ("t" toggle-truncate-lines "truncate")
      ("w" whitespace-mode "whitespace")
      ("q" nil "cancel"))
    "C-x j"
    (defhydra gotoline
      ( :pre (linum-mode 1)
        :post (linum-mode -1))
      "goto"
      ("t" (lambda () (interactive)(move-to-window-line-top-bottom 0)) "top")
      ("b" (lambda () (interactive)(move-to-window-line-top-bottom -1)) "bottom")
      ("m" (lambda () (interactive)(move-to-window-line-top-bottom)) "middle")
      ("e" (lambda () (interactive)(goto-char (point-max)) "end"))
      ("c" recenter-top-bottom "recenter")
      ("n" next-line "down")
      ("p" (lambda () (interactive) (forward-line -1))  "up")
      ("g" goto-line "goto-line"))
    "C-c t"
    (defhydra hydra-global-org (:color blue)
      "Org"
      ("t" org-timer-start "Start Timer")
      ("s" org-timer-stop "Stop Timer")
      ("r" org-timer-set-timer "Set Timer") ; This one requires you be in an orgmode doc, as it sets the timer for the header
      ("p" org-timer "Print Timer") ; output timer value to buffer
      ("w" (org-clock-in '(4)) "Clock-In") ; used with (org-clock-persistence-insinuate) (setq org-clock-persist t)
      ("o" org-clock-out "Clock-Out") ; you might also want (setq org-log-note-clock-out t)
      ("j" org-clock-goto "Clock Goto") ; global visit the clocked task
      ("c" org-capture "Capture") ; Dont forget to define the captures you want http://orgmode.org/manual/Capture.html
      ("l" (or )rg-capture-goto-last-stored "Last Capture"))))
#+end_src
** [x] igist
#+begin_src emacs-lisp

#+end_src
** [x] imenu-anywhere 
#+begin_src emacs-lisp
#+end_src
** [x] import-js
#+begin_src emacs-lisp
#+end_src
** [x] inf-elixir
#+begin_src emacs-lisp

#+end_src

** [x] jq-mode
#+begin_src emacs-lisp

#+end_src
** [x] keycast
#+begin_src emacs-lisp
#+end_src
** [x] kv
#+begin_src emacs-lisp
#+end_src
** [x] lusty-explorer
#+begin_src emacs-lisp
#+end_src
** [x] macro-math
#+begin_src emacs-lisp
#+end_src
** [x] macrostep
#+begin_src emacs-lisp
;;(on-hook edebug-mode (macrostep-mode +1))
#+end_src

** [x] magit
#+begin_src emacs-lisp
#+end_src
** [x] magit-filenotify
#+begin_src emacs-lisp
#+end_src
** [x] magit-gh-pulls
#+begin_src emacs-lisp
#+end_src

** [x] markdown-mode
#+begin_src emacs-lisp
  (on-package markdown-mode
    (defkeys markdown-mode-map
      "M-n" scroll-up-line
      "M-p" scroll-down-line
      "M-N" scroll-up-command
      "M-P" scroll-down-command)
    (defkeys markdown-view-mode-map
      "M-n" scroll-up-line
      "M-p" scroll-down-line
      "M-N" scroll-up-command
      "M-P" scroll-down-command))
#+end_src
** [x] marshal
#+begin_src emacs-lisp
#+end_src
** [x] modern-cpp-font-lock
#+begin_src emacs-lisp
(on-hook modern-cpp-font-lock-mode
  (diminish 'modern-cpp-font-lock-mode))
#+end_src
** [x] nov
#+begin_src emacs-lisp
(on-hook after-init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+end_src
** [x] ob-async
#+begin_src emacs-lisp
#+end_src
** [x] org-appear
#+begin_src emacs-lisp
#+end_src
** [x] org-bullets
#+begin_src emacs-lisp

#+end_src
** [x] org-contrib
#+begin_src emacs-lisp
#+end_src

** [x] org-download
#+begin_src emacs-lisp
#+end_src
** [x] org-projectile
#+begin_src emacs-lisp
(on-package org-projectile
  (require 'org-projectile)
  (setq org-projectile-projects-file "~Dokument/todos.org"
        org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
  (push (org-projectile-project-todo-entry) org-capture-templates)
  
  (defkeys global-map
    "C-c n p" org-projectile-project-todo-completing-read
    "C-c c" org-capture))
#+end_src
** [x] org-projectile-helm
#+begin_src emacs-lisp
#+end_src
** [x] org-ref
#+begin_src emacs-lisp
#+end_src

** [ ] org-sidebar
#+begin_src emacs-lisp
#+end_src
** [x] org-superstar
#+begin_src emacs-lisp
#+end_src
** [x] org-view-mode
#+begin_src emacs-lisp

#+end_src

** [x] package-lint
#+begin_src emacs-lisp
#+end_src
** [x] page-break-lines
#+begin_src emacs-lisp
(on-hook page-break-lines-mode (diminish 'page-break-lines-mode))
#+end_src
** [x] paxedit
#+begin_src emacs-lisp

#+end_src
** [ ] polymode
#+begin_src emacs-lisp
#+end_src
** [x] posframe
#+begin_src emacs-lisp

#+end_src

** [x] prettier-js
#+begin_src emacs-lisp
(on-package prettier-js
  (diminish 'prettier-js-mode))
(on-hook js2-mode
  (prettier-js-mode))
(on-hook rjsx-mode
  (prettier-js-mode))
#+end_src
** [x] pretty-symbols
#+begin_src emacs-lisp
#+end_src
** [x] projectile
#+begin_src emacs-lisp
(on-package projectile
  (setq projectile-indexing-method 'alien))
#+end_src
** [x] pulseaudio-control
#+begin_src emacs-lisp
#+end_src
** [x] quick-peek
#+begin_src emacs-lisp

#+end_src
** [ none  ] [x] recentf 
#+begin_src emacs-lisp
#+end_src
** [x] refine
#+begin_src emacs-lisp
#+end_src
** [x] request
#+begin_src emacs-lisp
#+end_src
** [x] rjsx-mode
#+begin_src emacs-lisp
(on-package rjsx-mode
  (setq js2-mode-show-parse-errors nil
        js2-mode-show-strict-warnings nil
        js2-basic-offset 2
        js-indent-level 2)
  (setq-local flycheck-disabled-checkers (cl-union flycheck-disabled-checkers
                                                   '(javascript-jshint))) ; jshint doesn't work for JSX
  (electric-pair-mode 1))
(on-hook after-init
  (add-to-list 'auto-mode-alist '("\\.js\\'" . rjsx-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx\\'" . rjsx-mode)))
#+end_src
** [x] sentex
#+begin_src emacs-lisp

#+end_src
** [x] sly
#+begin_src emacs-lisp
  (on-package sly
    (add-to-list 'sly-contribs 'sly-asdf)
    (add-to-list 'sly-contribs 'sly-mrepl)
    (add-to-list 'sly-contribs 'sly-indentation)
    ;;(require 'sly-stepper-autoloads)
    ;;(require 'sly-quicklisp-autoloads)
    ;;(require 'sly-macrostep-autoloads)
    ;;(require 'sly-named-readtables-autoloads)
    (setq inferior-lisp-program "sbcl")
    (setq sly-init-function 'sly-init-using-slynk-loader)
    (defkeys sly-editing-mode-map
      "C-c b" sly-eval-buffer
      "C-c d" sly-eval-defun
      "C-c C-d" sly-compile-defun
      "C-c C-k" sly-my-compile-and-load-file
      "C-c l" sly-eval-last-expression
      "M-h" sly-documentation-lookup
      "M-n" scroll-up-line
      "M-p" scroll-down-line)
    (defkeys sly-prefix-map
      "C-c b" sly-eval-buffer
      "C-c d" sly-eval-defun
      "C-c C-d" sly-compile-defun
      "C-c C-k" sly-my-compile-and-load-file
      "C-c l" sly-eval-last-expression
      "M-h" sly-documentation-lookup))

  (on-package sly-mrepl
    (defkeys sly-mrepl-mode-map
      "M-n" scroll-up-line
      "M-p" scroll-down-line
      "<up>" sly-mrepl-previous-input-or-button
      "<down>" sly-mrepl-next-input-or-button))

  (on-hook sly-mrepl-mode
    (cl-hooks))

  (on-hook sly-mode
    ;; Sly auto-installs its own indetantion function, which seems to be loaded
    ;; first when mrepl is loaded.
    ;; That results with Emacs ending up in the debugger when I try to indent a
    ;; Lisp file without a connection or mrepl loaded.
    ;; This is my temporary fix for the situation:
    (unless (functionp (symbol-function 'sly-common-lisp-indent-function))
      (let ((sly-dir (file-name-directory (find-library-name "sly"))))
        (add-to-list 'load-path (expand-file-name "lib" sly-dir))
        (add-to-list 'load-path (expand-file-name "contrib" sly-dir))
        (require 'sly-autodoc)
        (require 'sly-indentation))))
#+end_src
** [x] sly-asdf
#+begin_src emacs-lisp

#+end_src
** [x] sly-macrostep
#+begin_src emacs-lisp
#+end_src
** [x] sly-named-readtables
#+begin_src emacs-lisp
#+end_src
** [x] sly-quicklisp
#+begin_src emacs-lisp

#+end_src
** [x] solarized-theme
#+begin_src emacs-lisp
     ;; (on-package
     ;;  solarized
     ;;  (load-theme 'solarized-dark t))
#+end_src
** [x] super-save
#+begin_src emacs-lisp
(on-package super-save
  ;; add integration with ace-window
  (add-to-list 'super-save-triggers 'ace-window)
  ;; save on find-file
  (add-to-list 'super-save-hook-triggers 'find-file-hook)
  (setf super-save-remote-files nil
        super-save-idle-duration 0.5
        super-save-auto-save-when-idle t
        super-save-exclude '(".gpg")
        super-save-silent t
        super-save-triggers
        (append super-save-triggers
                '(emacs-lisp-byte-compile
                  emacs-lisp-byte-compile-and-load
                  emacs-lisp-native-compile-and-load))))
(on-hook super-save (diminish 'super-save))
#+end_src
** [x] web-mode
#+begin_src emacs-lisp

#+end_src

** [x] winum
#+begin_src emacs-lisp
#+end_src
** [x] with-simulated-input
#+begin_src emacs-lisp
#+end_src
** [x] yasnippet
#+begin_src emacs-lisp
(on-idle (require 'yasnippet))
(on-idle (require 'yasnippet-snippets))
(on-package yasnippet
  (require 'yasnippet-snippets)
  (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
  (setq yas-key-syntaxes '("w_" "w_." "^ ")
        ;; yas-snippet-dirs (eval-when-compile
        ;;                  (list (expand-file-name "~/.emacs.d/snippets")))
        yas-expand-only-for-last-commands nil)
  (defkeys yas-minor-mode-map
    "C-i" nil
    "TAB" nil
    "C-<tab>" yas-expand
    "M-_" yas-undo-expand))

(on-hook yas-minor-mode
 (diminish 'yas-mode 'yas-minor-mode))
#+end_src
** [x] yasnippet-snippets
#+begin_src emacs-lisp
#+end_src
   
** [ none  ] [x] abbrev
#+begin_src emacs-lisp
(on-package abbrev
  (diminish 'abbrev-mode))
#+end_src
** [ none  ] [x] c/c++
#+begin_src emacs-lisp
(on-hook after-init
  (add-hook 'c-initialization-hook 'my-c-init)
  (add-hook 'c++-mode-hook 'my-c++-init)
  (add-to-list 'auto-mode-alist '("\\.\\(c\\|h\\|inc\\|src\\)\\'" . c-mode))
  (add-to-list 'auto-mode-alist '("\\.\\(|hh\\|cc\\|c++\\|cpp\\|tpp\\|hpp\\|hxx\\|cxx\\|inl\\|cu\\)'" . c++-mode))
  (on-idle  (require 'c++-setup)))
#+end_src
** [ none  ] [x] dap-java
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] dired
#+begin_src emacs-lisp
;; (on-hook after-init
;;            (defkeys global-map
;;                     "C-x C-j"   dired-jump
;;                     "C-x 4 C-j" dired-jump-other-window)
;;            (on-idle (require 'dired)))

(on-package dired
  (require 'dired-setup)
  
  ;; (on-system windows-nt
  ;;   (setq ls-lisp-use-insert-directory-program "gls"))
  
  (on-system gnu/linux
    (dolist (ext (list (list (openwith-make-extension-regexp
                              '("xbm" "pbm" "pgm" "ppm" "pnm"
                                "png" "gif" "bmp" "tif" "jpeg" "jpg"))
                             "feh"
                             '(file))
                       (list (openwith-make-extension-regexp
                              '("doc" "xls" "ppt" "odt" "ods" "odg" "odp" "rtf"))
                             "libreoffice"
                             '(file))
                       (list (openwith-make-extension-regexp
                              '("\\.lyx"))
                             "lyx"
                             '(file))
                       (list (openwith-make-extension-regexp
                              '("chm"))
                             "kchmviewer"
                             '(file))
                       (list (openwith-make-extension-regexp
                              '("pdf" "ps" "ps.gz" "dvi" "epub" "djv" "djvu" "mobi" "azw3"))
                             "okular"
                             '(file))))
      (add-to-list 'openwith-associations ext)))
  (defkeys dired-mode-map
    "C-x <M-S-return>" dired-open-current-as-sudo
    "r"                dired-do-rename
    "C-S-r"            wdired-change-to-wdired-mode
    "C-r C-s"          tmtxt/dired-async-get-files-size
    "C-r C-r"          tda/rsync
    "C-r C-z"          tda/zip
    "C-r C-u"          tda/unzip
    "C-r C-a"          tda/rsync-multiple-mark-file
    "C-r C-e"          tda/rsync-multiple-empty-list
    "C-r C-d"          tda/rsync-multiple-remove-item
    "C-r C-v"          tda/rsync-multiple
    "C-r C-s"          tda/get-files-size
    "C-r C-q"          tda/download-to-current-dir
    "C-x C-j"          dired-jump
    "C-x 4 C-j"        dired-jump-other-window
    "S-<return>"       dired-openwith
    "C-'"              dired-collapse-mode
    "n"                scroll-up-line
    "p"                scroll-down-line
    "M-m"              dired-mark-backward
    "M-<"              dired-goto-first
    "M->"              dired-goto-last
    "M-<return>"       my-run
    "C-S-f"            dired-narrow
    "P"                peep-dired
    "<f1>"             term-toggle
    "TAB"              dired-subtree-toggle
    "f"                dired-subtree-fold-all
    "z"                dired-get-size
    "e"                dired-subtree-expand-all)
  )

(on-hook dired-omit-mode (diminish 'dired-omit-mode))
(on-hook dired-mode
  (dired-omit-mode)
  (dired-async-mode)
  (dired-hide-details-mode)
  ;;(dired-git-log-mode)
  (dired-auto-readme-mode))
#+end_src
** [ none  ] [x] early-init
#+begin_src emacs-lisp
(on-hook early-init
  (defvar yas-alias-to-yas/prefix-p nil)
  (defvar default-gc-cons-threshold gc-cons-threshold)
  (defvar old-file-name-handler file-name-handler-alist)
  (setq file-name-handler-alist nil
        debug-on-error t
        gc-cons-threshold most-positive-fixnum
        frame-inhibit-implied-resize t
        bidi-inhibit-bpa t
        initial-scratch-message ""
        inhibit-splash-screen t
        inhibit-startup-screen t
        inhibit-startup-message t
        inhibit-startup-echo-area-message t
        show-paren-delay 0
        use-dialog-box nil
        visible-bell nil
        ring-bell-function 'ignore
        load-prefer-newer t
        shell-command-default-error-buffer "Shell Command Errors"
        native-comp-async-report-warnings-errors 'silent
        comp-speed 3)
  (when 'native-comp-compiler-options
    (setq native-comp-async-jobs-number 4))
  
  (setq-default abbrev-mode t
                indent-tabs-mode nil
                indicate-empty-lines t
                cursor-type 'bar
                fill-column 80
                auto-fill-function 'do-auto-fill
                cursor-in-non-selected-windows 'hollow
                bidi-display-reordering 'left-to-right
                bidi-paragraph-direction 'left-to-right)
  (push '(fullscreen . maximized) initial-frame-alist)
  (push '(fullscreen . maximized) default-frame-alist)
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars . nil) default-frame-alist)
  (push '(font . "Anonymous Pro-20") default-frame-alist)
  
  (setq show-paren-style 'expression
        use-short-answers t
        auto-insert-query nil
        message-log-max 10000 ;; oriignal 1000
        undo-outer-limit 37000000
        shell-command-switch "-c"
        delete-exited-processes t
        echo-keystrokes 0.1
        create-lockfiles nil
        winner-dont-bind-my-keys t
        auto-windo-vscroll nil
        split-width-threshold 0
        split-height-threshold nil
        bookmark-save-flag 1
        delete-selection-mode t
        initial-major-mode 'emacs-lisp-mode
        confirm-kill-processes nil
        help-enable-symbol-autoload t
        large-file-warning-threshold nil
        save-abbrevs 'silent
        save-silently t
        save-interprogram-paste-before-kill t
        save-place-file (expand-file-name "places" user-emacs-directory)
        max-lisp-eval-depth '100000
        scroll-preserve-screen-position 'always
        scroll-conservatively 1
        maximum-scroll-margin 1
        mouse-autoselect-window t
        scroll-margin 0
        make-backup-files nil
        vc-make-backup-files nil
        vc-display-status nil
        ;;vc-handled-backends nil
        kill-buffer-delete-auto-save-files t
        backup-directory-alist `(("." . ,user-emacs-directory))
        custom-file (expand-file-name "custom.el" user-emacs-directory)
        bookmark-default-file (expand-file-name "bookmarks" user-emacs-directory)
        default-licence "GPL 3.0")

  (let ((default-directory  (expand-file-name "lisp" user-emacs-directory)))
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
  (let ((deff (gethash 'default face--new-frame-defaults)))
    (aset (cdr deff) 4 440)
    (puthash 'default deff face--new-frame-defaults))
  (define-prefix-command 'C-z-map)
  (global-set-key (kbd "C-z") 'C-z-map)
  (global-unset-key (kbd "C-v"))
  ;;define a setc function for use in init file
  (put 'setc 'byte-optimizer 'byte-compile-inline-expand))
#+end_src
** [ none  ] [x] edebug
#+begin_src emacs-lisp
;;(on-package edebug (require 'edebug-x))
#+end_src
** [ none  ] [x] eglot
#+begin_src emacs-lisp
(on-package
  eglot
  (fset #'jsonrpc--log-event #'ignore)
  (setq eglot-events-buffer-size 0)
  (setq eglot-sync-connect nil)
  (setq eglot-connect-timeout nil)
  (push :inlayHintProvider eglot-ignored-server-capabilities)
  ;;(advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
  ;;(advice-add 'eglot-completion-at-point :around #'cape-wrap-noninterruptible)
  )
#+end_src

** [ none  ] [x] emacs
#+begin_src emacs-lisp
(on-hook text-mode (setq fill-column 240))
(on-hook abbrev-mode (diminish 'abbrev-mode))
(on-hook auto-complete-mode (diminish 'auto-complete-mode))
(on-hook auto-fill-mode (diminish 'auto-fill-function))
(on-hook auto-insert-mode
  (setq auto-insert-query nil)
  (diminish 'auto-insert-mode))
(on-hook edit-abbrevs-mode (diminish 'abbrev-mode))
(on-hook eldoc-mode (diminish 'eldoc-mode))
(on-hook electric-pair-mode (diminish 'electric-pair-mode))
(on-hook subword-mode (diminish 'subword-mode))
(on-hook wrap-region-mode (diminish 'wrap-region-mode))
(on-hook winner-mode (diminish 'winner-mode))

(on-hook after-init

  (when (eq system-type 'windows-nt)
    (setq w32-get-true-file-attributes nil
	  w32-pipe-read-delay 0
	  w32-pipe-buffer-size (* 64 1024)
	  source-directory "~/repos/em2/emacs"
	  command-line-x-option-alist nil
	  command-line-ns-option-alist nil
	  browse-url-galeon-program (getenv "BROWSER")
	  browse-url-netscape-program browse-url-galeon-program)

    (when (getenv "MSYSTEM") (setq package-gnupghome-dir ""))
    
    (when (or (equal (system-name) "EMMI")
              (equal (system-name) "HP-Laptop"))
      (autoload 'global-disable-mouse-mode "disable-mouse.el" nil nil nil)
      (global-disable-mouse-mode 1)
      (diminish 'disable-mouse-global-mode)))

  (setq 
        auto-insert-query nil
        auto-window-vscroll nil
        split-width-threshold 0
        split-height-threshold nil
        bookmark-save-flag 1
        save-place-file (expand-file-name "places" user-emacs-directory)
        max-lisp-eval-depth '100000
        bookmark-default-file (expand-file-name "bookmarks" user-emacs-directory)
        default-licence "GPL 3.0")

  (push '("\\*Compile-Log\\*" (display-buffer-no-window)) display-buffer-alist)
  (push `       ((,(rx bos (or "*Apropos*" "*Help*" "*helpful*" "*info*" "*Summary*")
        	(0+ not-newline))
           (display-buffer-same-window
            display-buffer-reuse-mode-window
            display-buffer-pop-up-window)
           (mode apropos-mode help-mode helpful-mode Info-mode Man-mode)))
        display-buffer-alist)
  
  (push '(("*Help*" (window-parameters . ((dedicated . t))))) display-buffer-alist)
  (push (expand-file-name "~/repos/ready-lisp/doc/info") Info-directory-list)
  (setq find-file-hook (delq 'vc-refresh-state find-file-hook))

  (fset 'vc-backend 'ignore)
  (electric-indent-mode 1)
  (electric-pair-mode 1)
  (global-auto-revert-mode)
  (global-hl-line-mode 1)
  (global-subword-mode 1)
  (auto-compression-mode 1)
  (auto-image-file-mode)
  (auto-insert-mode 1)
  ;;(auto-save-visited-mode 1)
  (blink-cursor-mode 1)
  (column-number-mode 1)
  (delete-selection-mode 1)
  (display-time-mode t)
  (pending-delete-mode 1)
  (show-paren-mode t)
  (save-place-mode 1)
  (winner-mode t)
  (turn-on-auto-fill)
  (pixel-scroll-precision-mode +1)
  (bash-alias-mode +1)
  (which-key-mode +1)
  (super-save-mode +1)
  
  (defkeys global-map
    "C-<insert>"    term-toggle-term
    "<insert>"      term-toggle-eshell
    "C-v C-t"       term-toggle-ielm
    [f9]            ispell-word
    [S-f10]         next-buffer
    [C-enter]       other-window
    [M-S-f10]       next-buffer-other-window
    [f8]            last-buffer
    [f10]           previous-buffer
    [M-f10]         previous-buffer-other-window
    [M-f12]         kill-buffer-other-window
    [f12]           kill-buffer-but-not-some
    [C-M-f12]       only-current-buffer
    [C-return]      other-window
    "C-;"           do-in-other-window
    "C-M-:"         do-to-this-in-other-window
    "C-:"           do-to-this-and-stay-in-other-window
    ;; Emacs windows
    "C-v <left>"   windmove-swap-states-left
    "C-v <right>"  windmove-swap-states-right
    "C-v <up>"     windmove-swap-states-up
    "C-v <down>"   windmove-swap-states-down
    "C-v o"        other-window
    "C-v j"        windmove-left
    "C-v l"        windmove-right
    "C-v i"        windmove-up
    "C-v k"        windmove-down
    "C-v a"        send-to-window-left
    "C-v d"        send-to-window-right
    "C-v w"        send-to-window-up
    "C-v s"        send-to-window-down
    ;; "C-v v"        maximize-window-vertically
    ;; "C-v h"        maximize-window-horizontally
    "C-v n"        next-buffer
    "C-v p"        previous-buffer
    "C-v +"        text-scale-increase
    "C-v -"        text-scale-decrease
    "C-v C-+"      enlarge-window-horizontally
    "C-v C-,"      enlarge-window-vertically
    "C-v C--"      shrink-window-horizontally
    "C-v C-."      shrink-window-vertically
    "C-v u"        winner-undo
    "C-v r"        winner-redo
    "C-v C-k"      delete-window
    "C-v C-l"      windmove-delete-left
    "C-v C-r"      windmove-delete-right
    "C-v C-a"      windmove-delete-up
    "C-v C-b"      windmove-delete-down
    "C-v <return>" delete-other-windows
    "C-v ,"        split-window-right
    "C-v ."        split-window-below
    ;;"C-h M-i"      help-toggle-source-view
    ;; "C-v C-s"      swap-two-buffers
    [remap other-window]  ace-window
    [remap find-file-other-window]  ff-other-window          
    ;; cursor movement
    "M-n"     scroll-up-line
    "M-N"     scroll-up-command
    "M-p"     scroll-down-line
    "M-P"     scroll-down-command
    "C-v c"   org-capture
    "C-v C-c" avy-goto-char
    "C-v C-v" avy-goto-word-1
    "C-v C-w" avy-goto-word-0
    "C-v C-g" avy-goto-line
    ;; some random stuff
    "C-h C-i" (lambda() 
        	(interactive)
        	(find-file (expand-file-name
        		    "init.org"
        		    user-emacs-directory))))

  (on-idle (require 'which-key))
  (on-idle (require 'extras))
  (on-idle (require 'sv-kalender)
    ;;(add-to-list 'special-display-frame-alist '(tool-bar-lines . 0))
    (when (and custom-file (file-exists-p custom-file))
      (load custom-file 'noerror))
    (add-hook 'comint-output-filter-functions
	      #'comint-watch-for-password-prompt))

  (load-theme 'solarized-dark t)
  (setq gc-cons-threshold       default-gc-cons-threshold
	;;gc-cons-percentage      0.1
	file-name-handler-alist old-file-name-handler))
#+end_src
** [ none  ] [x] emacs-director
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] emacs-gif-screencast
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] emacs-run-command
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] emacs-velocity
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] gnus
#+begin_src emacs-lisp
(on-hook after-init
  (require 'gnus))

(on-hook message-mode
  (setq fill-column 72))

(on-package gnus
  
  ;; (require 'nnir)
  (setq user-full-name    "Arthur Miller"
        user-mail-address "arthur.miller@live.com")
  (setq gnus-select-method '(nnnil ""))
  ;; for the outlook
  (setq gnus-secondary-select-methods
        '((nnimap "live.com"
                 (nnimap-address "imap-mail.outlook.com")
                 (nnimap-server-port 993)
                 (nnimap-stream starttls)
                 (nnimap-search-engine imap)
                 (nnimap-authinfo-file "~/.authinfo"))))
  
  ;; Send email through SMTP
  (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-default-smtp-server "smtp-mail.outlook.com"
        smtpmail-smtp-service 587
        smtpmail-stream-type 'starttls
        smtpmail-local-domain "homepc")

  (setq gnus-thread-sort-functions
        '(gnus-thread-sort-by-most-recent-date
          (not gnus-thread-sort-by-number)))
  (setq gnus-use-cache t gnus-view-pseudo-asynchronously t)
  ;; Show more MIME-stuff:
  (setq gnus-mime-display-multipart-related-as-mixed t)
  ;; http://www.gnu.org/software/emacs/manual/html_node/gnus/_005b9_002e2_005d.html
  (setq gnus-use-correct-string-widths nil)
  ;;(setq nnmail-expiry-wait 'immediate)
  ;; set renderer for html mail to w3m in emacs
  ;;(setq mm-text-html-renderer 'eww)
  (setq gnus-inhibit-images nil)
  ;; set gnus-parameter
  ;; (setq gnus-parameters
  ;;       '(("nnimap.*"
  ;;          (gnus-use-scoring nil)
  ;;          (expiry-wait . 2)
  ;;          (display . all))))
  
  ;;[[http://stackoverflow.com/questions/4982831/i-dont-want-to-expire-mail-in-gnus]]
  ;;(setq gnus-large-newsgroup 'nil)
  ;; Smileys:
  (setq smiley-style 'medium)
  (setq gnus-fetch-old-headers 'some)
  ;; Use topics per default:
  (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
  (setq gnus-message-archive-group '((format-time-string "sent.%Y")))
  (setq gnus-server-alist '(("archive" nnfolder "archive" (nnfolder-directory "~/mail/archive")
                             (nnfolder-active-file "~/mail/archive/active")
                             (nnfolder-get-new-mail nil)
                             (nnfolder-inhibit-expiry t))))
  
  (setq gnus-topic-topology '(("live.com" visible)))
  
  ;; each topic corresponds to a public imap folder
  (setq gnus-topic-alist '(("live.com")
                           ("Gnus"))))
#+end_src
** [ none  ] [x] helm-convert
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] ielm
#+begin_src emacs-lisp
(on-package
  ielm
  (require 'elisp-extras)
  (advice-add 'ielm :around #'ielm-use-current-buffer)
  ;;(advice-add 'ielm-eval-inpu :after #'paredit-open-round)
  (defkeys ielm-map
    "\C-c a" emacs-lisp-byte-compile-and-load
    "\C-c b" emacs-lisp-byte-compile
    "\C-c c" emacs-lisp-native-compile-and-load
    "\C-c d" eval-defun
    "\C-c e" eval-buffer
    "\C-c r" eval-region
    "\C-c l" eval-last-sexp
    "\C-c n" eval-next-sexp
    "\C-c i" reindent-buffer
    "\C-c p" fc-eval-and-replace
    "\C-c s" eval-surrounding-sexp)
  (require 'paredit)
  (define-key paredit-mode-map (kbd "RET") nil)
  (define-key paredit-mode-map (kbd "C-j") 'paredit-newline))

(on-hook ielm-mode
  ;;(ielm-change-working-buffer (other-window-buffer -1))
  (paredit-mode +1)
  (turn-on-eldoc-mode))
#+end_src
** [ none  ] [x] inferior-python-mode
#+begin_src emacs-lisp
(on-hook inferior-python-mode
  (hide-mode-line-mode))
#+end_src
** [ none  ] [x] info
#+begin_src emacs-lisp
(on-package info
  (defkeys Info-mode-map
    "M-n" nil))
#+end_src

** [ none  ] [x] lisp & elisp
#+begin_src emacs-lisp
(on-package elisp-mode
  (require 'elisp-extras)
  (defkeys emacs-lisp-mode-map
    "\C-c a" emacs-lisp-byte-compile-and-load
    "\C-c b" emacs-lisp-byte-compile
    "\C-c c" emacs-lisp-native-compile-and-load
    "\C-c d" eval-defun
    "\C-c e" eval-buffer
    "\C-c r" eval-region
    "\C-c l" eval-last-sexp
    "\C-c n" eval-next-sexp
    "\C-c i" reindent-buffer
    "\C-c p" fc-eval-and-replace
    "\C-c s" eval-surrounding-sexp))

(on-hook after-init
  (set-default
 'auto-mode-alist
 (append '(("\\.lisp" . lisp-mode)
           ("\\.lsp" . lisp-mode)
           ("\\.asd" . lisp-mode)
           ("\\.cl" . lisp-mode))
         auto-mode-alist)))

(on-package inf-lisp (require 'cl-extras))
(on-package lisp-mode
  (require 'cl-extras))
(on-hook emacs-lisp-mode (elisp-hooks))
(on-hook inf-lisp (cl-hooks))
(on-hook lisp-mode (cl-hooks))
#+end_src
** [ none  ] [x] org
#+begin_src emacs-lisp
  (on-hook org-mode
    (auto-fill-mode -1)
    (visual-line-mode +1)
    (when (equal (buffer-name) "init.org")
      (auto-save-mode 1)
      (page-break-lines-mode 1))
    (yas-minor-mode 1))

  (on-package org
    (require 'org-extras))
    
  ;;  (defkeys org-mode-map
  ;;     [C-<enter>] other-window
  ;;     [C-S-<return>] org-insert-heading-respect-content))
 #+end_src
** [ none  ] [x] paredit
#+begin_src emacs-lisp
(on-package paredit
  (defkeys paredit-mode-map
    "C-8" paredit-backward-slurp-sexp
    "C-9" paredit-forward-slurp-sexp
    "C-7" paredit-backward-barf-sexp
    "C-0" paredit-forward-barf-sexp
    "M-8" paredit-wrap-round
    "M-9" paredit-close-round-and-newline
    "C-." paredit-forward
    "C-," paredit-backward))
#+end_src
** [ none  ] [x] term-toggle
#+begin_src emacs-lisp
(on-package term-toggle
  (setq term-toggle-no-confirm-exit t
        term-toggle-kill-buffer-on-term-exit t))
#+end_src
** [ none  ] [x] wdired
#+begin_src emacs-lisp
(on-package wdired
  (defkeys wdired-mode-map
    "<return>"    dired-find-file
    "M-<return>"  my-run
    "S-<return>"  dired-openwith
    "M-<"         dired-go-to-first
    "M->"         dired-go-to-last
    "M-p"         scroll-down-line))
#+end_src
** [ none  ] [x] which-key
#+begin_src emacs-lisp
(on-package which-key
  (setq which-key-idle-delay 0.01)
  (which-key-mode))
(on-hook which-key
  (diminish 'which-key-mode)
  (which-key-setup-minibuffer))
#+end_src

