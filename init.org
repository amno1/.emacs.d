# -*- eval: (progn (setq org-startup-folded 'overview) (org-babel-goto-named-src-block "onstartup") (org-babel-execute-src-block)); -*-
* About
** To fix
   [[https://dev.to/viglioni/how-i-set-up-my-emacs-for-typescript-3eeh]]
   https://github.com/clemera/helm-ido-like-guide
** Introduction
   A very personal and opinionated setup, based on an own code generator. The
   idea with generator is to generate a machine specific setup, so no probing
   for packages, files, paths etc is needed, as well as to perform some
   optimizations automatically and some that are normally not possible.

   This is/was mainly a learning experience to learn Emacs Lisp, but I do use it
   personally for my Emacs setup. It is a lazy-loaded setup, based on built-in
   (and hacked) package.el.

   The setup assumes some environment variables defined in both GNU/Linux and MS
   Windows:

   - BROWSER I use firefox-developer-edition on both OS:s.
   - HOME    Need to be defined on MS Windows, I use %UserProfile%

   This setup also assumes Emacs to run in a Unix-like environment with all the
   standard GNU tools available, so on MS Windows mingw environemnt needs to be
   present and configured. I haven't tested with Cygwin, but I guess it should
   probably work. On MS Windows you also have to enable symlinks for hacked
   package.el to work.

   Package.el is hacked so it let me use symlinks to local packages. The purpose
   is to be able to hack on a repository without need to have two copies, one
   working and one in elpa directory. I will though replace this with a
   different approach I have in mind, on some beautiful day I have time to
   implement it .. :).
   
** Licence
   Copyright (C) 2020  Arthur Miller
   Author: Arthur Miller <arthur.miller@live.com>
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.
* Generator
#+NAME: onstartup
#+begin_src emacs-lisp :results output silent
(defvar init-file-bake-autoloads t)
(defvar init-file-verbose-messages nil)
(defvar init-file-unroll-key-bindings t)
(defvar init-file-use-modules nil)
(defvar init-file-etc-directory (expand-file-name "etc/" user-emacs-directory))
(defvar init-file-lisp-directory (expand-file-name "lisp/" user-emacs-directory))
(defvar init-file-source-repositories (list package-user-dir init-file-lisp-directory))
(defvar init-file--autoloads-map (make-hash-table :test 'equal))
(defvar init-file--loadpaths-map (make-hash-table :test 'equal))
(defvar init-file--need-package-refresh t)

(load (expand-file-name "./lisp/package.el")) ;; use hacked-package.el

(if (equal system-name "HP-Laptop")
    (setq package-gnupghome-dir "/c/Users/HP/.emacs.d/elpa/gnupg"))

(setq package-archives nil)
(defvar site-archive '("local" . "/home/arthur/repos/"))
(defvar org-archive '("org" . "https://orgmode.org/elpa/"))
(defvar gnu-archive '("elpa" . "https://elpa.gnu.org/packages/"))
(defvar melpa-archive '("melpa" . "https://melpa.org/packages/"))
(defvar nelpa-archive '("nelpa" . "https://elpa.nongnu.org/nongnu/"))
(defvar marmalade-archive '("marmalade" . "https://marmalade-repo.org/packages/"))

(add-to-list 'package-archives site-archive)
(add-to-list 'package-archives org-archive)
(add-to-list 'package-archives gnu-archive)
(add-to-list 'package-archives nelpa-archive)
(add-to-list 'package-archives melpa-archive)
(setq package-archives (nreverse package-archives))

(unless (file-directory-p init-file-etc-directory)
  (make-directory init-file-etc-directory))
(unless (boundp 'init-file-hooks)
  (make-variable-buffer-local 'init-file-hooks))
(unless (boundp 'init-file-package-list)
  (make-variable-buffer-local 'init-file-package-list))

(defun on-buffer-change-hook (beg eng len)
  (setq init-file-package-list nil))
(add-hook 'after-change-functions 'on-buffer-change-hook)

(defmacro with-hook (name &rest body)
  (let (found hook)
    (setq name (if (string-match "-hook\\'" (symbol-name `,name))
                   `,name
                 (intern (concat (symbol-name name) "-hook"))))
    (setq body (nreverse body))
    (dolist (hook init-file-hooks)
      (when (equal (symbol-name (car hook)) (symbol-name name))
        (dolist (sexp (nreverse (cdr hook)))
          (add-to-list 'body sexp))
        (setcdr hook body)
        (setq found t)))
    (unless found
      (add-to-list 'init-file-hooks (cons name body)))
    (ignore)))

(defmacro verbose (format-string &rest args )
  (when init-file-verbose-messages
    `(message ,format-string ,@args)))

(defun clean-init-file ()
  (interactive)
  (with-temp-buffer
    (insert-file-contents "init.el")
    (beginning-of-buffer)
    (while (not (eobp))
      (when (char-equal (char-after) ?\^M)
        (delete-char 1))
      (forward-char 1))
    (write-region (point-min) (point-max) "init.el")))

(defmacro after-load (name &rest body)
  (with-eval-after-load name
    `(progn ,@body)))

(defmacro with-package (name &rest body)
  (verbose "Parsing package %s" name)
  (let ((package (symbol-name name)))
    (append-to-init-file "(with-eval-after-load ")
    (append-to-init-file (concat "'" package "\n "))
    (emit-to-init-file body)
    (append-to-init-file ")\n")))

(defmacro when-idle (&rest body)
  `(run-with-idle-timer 0.5 nil (lambda () ,@body)))

(defmacro with-system (systype &rest body)
  (if (equal system-type systype)
      `(progn ,@body)))

(defmacro with-host (host &rest body)
  (if (equal system-name host)
      `(progn ,@body)))

(defmacro defkeys (mapname &rest body)
  `(let ((defs '(,@body)))
     (while defs
       (define-key ,mapname
                   (if (vectorp (car defs))
                       (car defs)
                     (read-kbd-macro (car defs)))
                   (if (or (listp (cadr defs)) (functionp (cadr defs)))
                       (cadr defs)
                     (if `(keymapp (bound-and-true-p ,(cadr defs)))
                         (eval (cadr defs)))))
       (setq defs (cddr defs)))))

(defun emit-defkeys (map keys)
  (while keys
    (append-to-init-file
     (concat "(define-key "  (symbol-name map) " "
             (if (vectorp (car keys))
                 (prin1-to-string (car keys))
               (concat "(kbd \"" (car keys) "\")"))
             " #'" (prin1-to-string (cadr keys))
             ")"))
    (setq keys (cddr keys))))

(defun emit-when-idle (sexp)
  (append-to-init-file
   (format "(run-with-idle-timer 0.5 nil (lambda () %s))" sexp)))

(defun append-to-init-file (data &optional file)
  (unless file (setq file "init.el"))
  (let (insert-point)
    (cond ((stringp data)
           (write-region data nil file t 0))
          ((bufferp data)
           (with-current-buffer data
             (write-region (point-min) (point-max) file t 0))))))

(defun emit-sexp-to-init-file (sexp)
  (if init-file-unroll-key-bindings
      (cond ((equal (car sexp) 'defkeys)
             (emit-defkeys (cadr sexp) (cddr sexp)))
            ((equal (car sexp) 'with-system)
             (when (equal (cadr sexp) system-type)
               (emit-to-init-file (cddr sexp))))
            ((equal (car sexp) 'when-idle)
             (emit-when-idle (cadr sexp)))
            (t
             (append-to-init-file (prin1-to-string sexp))))
    (append-to-init-file (prin1-to-string sexp))))

(defun emit-to-init-file (&rest body)
  (dolist (sexp body)
    (if (listp (car sexp))
        (dolist (s sexp)
          (emit-sexp-to-init-file s))
      (emit-sexp-to-init-file sexp))))

(defun emit-packages ()
  (message "Emiting packages ...")
  (dolist (p (get-package-list))
    (verbose "Checking package: %s" (aref p 0))
    (when (package-enabled-p p)
      (verbose "Emiting package: %s" (aref p 0))
      (eval-region (aref p 4) (aref p 5)))))

(defun emit-hooks ()
  (message "Emiting hooks ...")
  (dolist (hook init-file-hooks)
    (verbose "Hook: %s" (car hook))
    (if (equal (symbol-name (car hook)) "early-init-hook")
        (dolist (elt (nreverse (cdr hook)))
          (append-to-init-file (prin1-to-string elt) "early-init.el"))
      (progn
        (append-to-init-file (concat "(add-hook '"
                                     (symbol-name (car hook))
                                     " #'(lambda nil\n"))
        (dolist (s (cdr hook))
          (emit-to-init-file s))
        (append-to-init-file "))")))))

(defun get-load-paths()
  (let ((elpa (expand-file-name "elpa" user-emacs-directory))
        (archives (expand-file-name "elpa/archives" user-emacs-directory))
        package-paths)
    (dolist (path (directory-files elpa t directory-files-no-dot-files-regexp))
      (when (file-directory-p path)
        (unless (string= path archives)
          (push path package-paths))))
    (push init-file-lisp-directory package-paths)
    package-paths))

(defun emit-load-paths ()
  (message "Emitting load-path")
  (append-to-init-file (concat "\n(nconc load-path '"
                               (prin1-to-string (get-load-paths))
                               ")\n")
                       "early-init.el"))

(defun quotedp (sym)
  (if (and (consp sym) (eq (car sym) 'quote))
      sym `(quote ,sym)))

(defun interactivep (form)
  "Wether form is an interactive command."
  (catch 'interactive
    (dolist (sxp form)
      (and (listp sxp) (equal 'interactive (car sxp))
           (throw 'interactive t)))))

(defun macro-p (form)
  "Wether FORM is a macro definition."
  (equal (car form) 'defmacro))

(defun collect-autoloads (src)
  (verbose "Collecting autoloads for file: %s" src)
  (let (sxp sym interactive macro file)
    (with-current-buffer (get-buffer-create "*ql-buffer*")
      (erase-buffer)
      (insert-file-contents src)
      (goto-char (point-min))
      (while (re-search-forward "^;;;###autoload" nil t)
        (setq sxp nil sym nil)
        (setq sxp (ignore-errors (read (current-buffer))))
        (when (listp sxp)
          (setq sym (quotedp (cadr sxp))
                interactive (interactivep sxp)
                macro (macro-p sxp)
                file (file-name-nondirectory src))
          (unless (listp (cadr sym))
            (puthash sym (list 'autoload sym file nil interactive macro)
                     init-file--autoloads-map)))))))

(defun generate-autoloads (dir-tree-or-dir-tree-list &optional outfile)
  (let ((index 0) srcs package-activated-list pkgname
        (tofile (or outfile (expand-file-name "autoloads.el" user-emacs-directory))))
    (if (listp dir-tree-or-dir-tree-list)
        (dolist (dir-tree dir-tree-or-dir-tree-list)
          (setq srcs
                (nconc srcs (directory-files-recursively dir-tree "\\.el$" nil t t))))
      (setq srcs
            (directory-files-recursively dir-tree-or-dir-tree-list "\\.el$" nil t t)))
    (dolist (src srcs)
      (when (string-match-p "-pkg\\.el" src)
        (push (make-symbol (file-name-base src)) package-activated-list))
      (when (and (not (string-match-p "-pkg\\.el" src))
                 (not (string-match-p "-autoloads\\.el" src)))
        (collect-autoloads src)))
    (with-temp-file tofile
      (maphash (lambda (sym sxp)
                 (prin1 sxp (current-buffer)) (insert "\n"))
               init-file--autoloads-map)
      (pp `(setq package-activated-list
                 (append ',package-activated-list
                         package-activated-list))
          (current-buffer)))
    (kill-buffer (get-buffer-create "*ql-buffer*")))
  (message "gen autoloads done"))

(defun emit-autoloads ()
  (message "Emiting autoloads")
  (let ((al (expand-file-name "autoloads.el" user-emacs-directory)))
    (verbose "Generating autoloads: %s" al)
    (generate-autoloads init-file-source-repositories)))

(defmacro maybe-remove-file (file)
  `(when (file-exists-p ,file)
     (delete-file ,file)
     (message "Removed file %s" ,file)))

(defun tangle-init-file (&optional file)
  (message "Exporting init files.")
  (unless file
    (setq file "init.el"))
  (maybe-remove-file "init.el")
  (maybe-remove-file "init.elc")
  (maybe-remove-file "early-init.el")
  (with-temp-file "init.el"
    (insert ";; init.el -*- lexical-binding: t; -*-\n")
    (insert ";; This file is machine generated by init-file generator, don't edit\n")
    (insert ";; manually, edit instead file init.org and generate new init file from it.\n\n"))
  (with-temp-file "early-init.el"
    (insert ";; early-init.el -*- lexical-binding: t; -*-\n")
    (insert ";; This file is machine generated by init-file generator, don't edit\n")
    (insert ";; manually, edit instead file init.org and generate new init file from it.\n\n"))
  (setq init-file-hooks nil)
  ;; are we baking quickstart file?
  (when init-file-bake-autoloads
    (emit-autoloads)
    (with-temp-buffer
      (insert-file-contents-literally "autoloads.el")
      (append-to-init-file (current-buffer))))
  ;; generate stuff
  (emit-packages)
  ;; do this after user init stuff
  (emit-hooks) ;; must be done after emiting packages
  (emit-load-paths);; must be done after emiting hooks
  ;; fix init.el
  (append-to-init-file "\n;; Local Variables:\n")
  (append-to-init-file ";; coding: utf-8\n")
  (append-to-init-file ";; byte-compile-warnings: '(not docstrings free-vars))\n")
  (append-to-init-file ";; End:\n")
  (clean-init-file))

(defun goto-code-start (section)
  (goto-char (point-min))
  (re-search-forward section)
  (re-search-forward "begin_src.*emacs-lisp")
  (skip-chars-forward "\s\t\n\r"))

(defun goto-code-end ()
  (re-search-forward "end_src")
  (beginning-of-line))

(defun generate-init-files ()
  (interactive)
  (message "Exporting init.el ...")
  (tangle-init-file)
  (setq byte-compile-warnings nil)
  (let ((tangled-file "init.el")
        (byte-compile-warnings nil)
        (fill-column 240))
    ;; always produce elc file
    (byte-compile-file tangled-file)
    (verbose "Byte compiled %s" tangled-file)
    (when (featurep 'native-compile)
      (native-compile tangled-file)
      (verbose "Tangled and compiled %s" tangled-file))
  (verbose "Done.")
  (message "Compiling early-init.el ...")
  (byte-compile-file (expand-file-name "early-init.el"  user-emacs-directory))
  (message "Done.")))

(defun install-file (file)
  (when (file-exists-p file)
    (unless (equal (file-name-directory buffer-file-name)
                   (expand-file-name user-emacs-directory))
      (copy-file file user-emacs-directory t))
    (message "Wrote: %s." file)))

(defun install-init-files ()
  (interactive)
  (let ((i "init.el")
        (ic "init.elc")
        (ei "early-init.el")
        (al "autoloads.el")
        (pq (expand-file-name "package-quickstart.el" user-emacs-directory))
        (pqc (expand-file-name "package-quickstart.elc" user-emacs-directory)))
    (install-file i)
    (install-file ei)
    (unless (file-exists-p ic)
      (byte-compile (expand-file-name el)))
    (install-file ic)
    (unless init-file-bake-autoloads
      (byte-compile pq))
    (when init-file-bake-autoloads
      ;; remove package-quickstart files from .emacs.d
      (when (file-exists-p pq)
        (delete-file pq))
      (when (file-exists-p pqc)
        (delete-file pqc)))))

(defmacro gt (n1 n2)
  `(> ,n1 ,n2))
(defmacro gte (n1 n2)
  `(>= ,n1 ,n2))
(defmacro lt (n1 n2)
  `(< ,n1 ,n2))
(defmacro lte (n1 n2)
  `(<= ,n1 ,n2))

(defun package-name (package)
  (aref package 0))
(defun package-enabled-p (package)
  (aref package 1))
(defun package-pseudo-p (package)
  (aref package 2))
(defun package-pinned-to (package)
  (aref package 3))
(defun package-code-beg (package)
  (aref package 4))
(defun package-code-end (package)
  (aref package 5))

(defun get-package-list ()
  (when (buffer-modified-p)
    (setq init-file-package-list nil))
  (unless init-file-package-list
    (save-excursion
      (goto-char (point-min))
      (let (package packages start end
                    config-start config-end ms me s)
        (goto-char (point-min))
        (verbose "Creating package list ...")
        (re-search-forward "^\\* Packages")
        (while (re-search-forward "^\\*\\* " (eobp) t)
          ;; format: [name enabled pseudo pinned-to code-start-pos code-end-pos fetch-url]
          (setq package (vector "" t nil "" 0 0 "")
                config-start (point) end (line-end-position))
          ;; package name
          (while (search-forward "] " end t) )
          (setq start (point))
          (skip-chars-forward "[a-zA-Z\\-]")
          (aset package 0
                (buffer-substring-no-properties start (point)))
          (goto-char (line-beginning-position))
          ;; enabled?
          (when (search-forward "[ ]" end t)
            (aset package 1 nil))
          (goto-char (line-beginning-position))
          (search-forward "[" end t)
          (setq ms (point))
          (goto-char (line-beginning-position))
          (search-forward "]" end t)
          (setq me (- (point) 1))
          (setq s (buffer-substring-no-properties ms me))
          (when (gt (length s) 1)
            (setq s (string-trim s))
            ;; installable?
            (when (or (equal s "local") (equal s "none"))
              (aset package 2 t))
            ;; pinned to repository?
            (aset package 3 s))
          (goto-char start)
          ;; code start
          (re-search-forward "begin_src.*emacs-lisp" (eobp) t)
          (aset package 4 (point))
          (re-search-forward "end_src$" (eobp) t)
          (beginning-of-line)
          (aset package 5 (- (point) 1))
          ;; are we fetching from somewhere?
          (goto-char (aref package 5))
          (when (re-search-backward "^[ \t].*Git:" config-start t)
            (search-forward "Git:")
            (skip-chars-forward " \t")
            (setq start (point))
            (end-of-line)
            (skip-chars-backward " \t")
            (aset package 6
                  (buffer-substring-no-properties start (point))))
          (push package init-file-package-list)
          (setq init-file-package-list (nreverse init-file-package-list))))))
  init-file-package-list)

;; Install packages
(defun ensure-package (package)
  (let ((p (intern-soft (aref package 0))))
    (message "Installing package: %s" p)
    (package-install p)))

(defun install-packages (&optional packages)
  (interactive)
  (when init-file--need-package-refresh
    (package-refresh-contents)
    (setq init-file--need-package-refresh nil))
  (unless packages
    (setq packages (get-package-list)))
  (dolist (p packages)
    (unless (or (package-installed-p p) (package-pseudo-p p))
      (when (package-enabled-p p)
        ;;    (unless (string-empty-p (aref p 3))
        ;;      (add-to-list 'package-pinned-packages (cons (intern-soft (aref p 0)) (aref p 3))))
        (ensure-package p)))))

(defun current-package ()
  "Return name of package the cursor is at the moment."
  (save-excursion
    (let (nb ne pn (start (point)))
      (when (re-search-backward "^\\* Packages" (point-min) t)
        (setq nb (point))
        (goto-char start)
        (setq pn (search-forward "** " (line-end-position) t 1))
        (unless pn
          (setq pn (search-backward "** " nb t 1)))
        (when pn
          (search-forward "] ")
          (setq nb (point))
          (re-search-forward "[\n[:blank:]]")
          (forward-char -1)
          (setq ne (point))
          (setq pn (buffer-substring-no-properties nb ne))
          pn)))))

(defun install-and-configure ()
  (interactive)
  (install-packages)
  (generate-init-files)
  (install-init-files))

(defun configure-emacs ()
  (interactive)
  (generate-init-files)
  (install-init-files))

(defalias 'vlt 'version-list-<)
(defun org-init-update-packages ()
  (interactive)
  (package-refresh-contents)
  (dolist (package package-activated-list)
    (let* ((new (cadr (assq package package-archive-contents)))
           (old (cadr (assq package package-alist)))
           to-install)
      (when (and new old (vlt (package-desc-version old) (package-desc-version new)))
        (setq to-install
              (package-compute-transaction (list new) (package-desc-reqs new)))
        (message "Installing package: %S" (package-desc-dir new))
        (package-download-transaction to-install)
        (message "Removed package: %S" (package-desc-dir old))
        (and (file-directory-p (package-desc-dir old))
             (not (file-symlink-p (package-desc-dir old)))
             (delete-directory (package-desc-dir old) t))))))

;;; org hacks

;; https://www.reddit.com/message/unread/
(require 'cape)

(if (featurep 'org-heading-checkbox)
    (unload-feature 'org-heading-checkbox))
(defvar org-init--enabled-re "^[ \t]*\\*+.*?[ \t]*\\[x\\]")
(defvar org-init--disabled-re "^[ \t]*\\*+.*?[ \t]*\\[ \\]")
(defvar org-init--checkbox-re "^[ \t]*\\*+.*?\\[[ x]\\]")

(defun org-init--heading-checkbox-p ()
  "Return t if this is a heading with a checkbox."
  (save-excursion
    (beginning-of-line)
    (looking-at org-init--checkbox-re)))

(defun org-init--checkbox-enabled-p ()
  "Return t if point is at a heading with an enabed checkbox."
  (save-excursion
    (beginning-of-line)
    (looking-at "^[ \t]*\\*+.*?\\[x\\]")))

(defun org-init--checkbox-disabled-p ()
  "Return t if point is at a heading with a disabeled checkbox."
  (save-excursion
    (beginning-of-line)
    (looking-at "^[ \t]*\\*+.*?\\[ \\]")))

(defun org-init--checkbox-enable ()
  "Disable checkbox for heading at point."
  (interactive)
  (when (org-init--checkbox-enabled-p)
    (save-excursion
      (beginning-of-line)
      (replace-string "[ ]" "[x]" nil (line-beginning-position)
                      (line-end-position)))))

(defun org-init--checkbox-disable ()
  "Disable checkbox for heading at point."
  (interactive)
  (when (org-init--checkbox-enabled-p)
    (save-excursion
      (beginning-of-line)
      (replace-string "[x]" "[ ]" nil (line-beginning-position)
                      (line-end-position)))))

(defun org-init--checkbox-toggle ()
  "Toggle state of checkbox at heading under the point."
  (interactive)
  (save-excursion
    (beginning-of-line)
    (cond ((looking-at org-init--enabled-re)
           (replace-string "[x]" "[ ]" nil (line-beginning-position)
                           (line-end-position)))
          ((looking-at org-init--disabled-re)
           (replace-string "[ ]" "[x]" nil (line-beginning-position)
                           (line-end-position)))
          (t (error "Not at org-init-checkbox line.")))))

(defun org-init--packages ()
  "Return start of packages; point after the \"* Packages\" heading."
  (save-excursion
    ;; we search backward, which will find beginning of line if the current
    ;; point is after the heading
    (cond ((re-search-backward "^\\* Packages" (point-min) t)
           (point))
          ;; the point was after the heading, and now we are at the point-min
          ((re-search-forward "^\\* Packages" nil t)
           (beginning-of-line)
           (point))
          ;; we didn't found the Packages section, means invalid file
          (t (error "No Packages section in current file found.")))))

;; help fns to work with init.org
(defun add-package (package)
  (interactive "sPackage name: ")
  (goto-char (org-init--packages))
  (forward-line 1)
  (insert (concat "\n** [x] "
                  package
                  "\n#+begin_src emacs-lisp\n"
                  "\n#+end_src\n"))
  (forward-line -2))

(defun add-git-package (url)
  (interactive "sGIT url: ")
  (unless (string-empty-p url)
    (let ((tokens (split-string url "/" t "\s\t")) package)
      (message "T: %S" tokens)
      (dolist (tk tokens)
        (setq package tk))
      (goto-char (org-init--packages))
      (forward-line 1)
      (insert (concat "\n** [x] " package
                      "\n#+GIT: " url
                      "\n#+begin_src emacs-lisp\n"
                      "\n#+end_src\n"))
      (forward-line -2))))

(defun org-init--package-enabled-p ()
  "Return t if point is in a package headline and package is enabled."
  (save-excursion
    (beginning-of-line)
    (looking-at "^[ \t]*\\*\\* \\[x\\]")))

(defun org-init--toggle-headline-checkbox ()
  "Switch between enabled/disabled todo state."
  (if (org-init--package-enabled-p)
      (org-todo 2)
    (org-todo 1)))

(defun org-init--package-section-p ()
  (save-excursion
    (let ((current-point (point)))
      (when (re-search-backward "^\\* Packages" nil t)
        (forward-line 1)
        (gte current-point (point))))))

(defun org-init--shiftup ()
  "Switch between enabled/disabled todo state."
  (interactive)
  (if (org-init--package-section-p)
      (save-excursion
        (beginning-of-line)
        (unless (looking-at org-heading-regexp)
          (re-search-backward org-heading-regexp))
        (if (org-init--heading-checkbox-p)
            (org-init--checkbox-toggle)))
    (org-shiftup)))

(defun org-init--shiftdown ()
  "Switch between enabled/disabled todo state."
  (interactive)
  (if (org-init--package-section-p)
      (save-excursion
        (beginning-of-line)
        (unless (looking-at org-heading-regexp)
          (re-search-backward org-heading-regexp))
        (if (org-init--heading-checkbox-p)
            (org-init--checkbox-toggle)))
    (org-shiftdown)))

(defun org-init--shiftright ()
  "Switch between enabled/disabled todo state."
  (interactive)
  (if (org-init--package-section-p)
      (save-excursion
        (beginning-of-line)
        (unless (looking-at org-heading-regexp)
          (re-search-backward org-heading-regexp))
        (org-shiftright))
    (org-shiftright)))

(defun org-init--shiftleft ()
  "Switch between enabled/disabled todo state."
  (interactive)
  (if (org-init--package-section-p)
      (save-excursion
        (beginning-of-line)
        (unless (looking-at org-heading-regexp)
          (re-search-backward org-heading-regexp))
        (org-shiftleft))
    (org-shiftleft)))

(defun org-init--open-in-dired ()
  (interactive)
  (if (org-init--package-section-p)
      (save-excursion
        (beginning-of-line)
        (unless (looking-at org-heading-regexp)
          (re-search-backward org-heading-regexp))
        (let ((elpa (expand-file-name "elpa" user-emacs-directory))
              start pkgname pkdir)
          (search-forward "[ " (line-end-position) t)
          (if (search-forward "none" (line-end-position) t)
              (dired (expand-file-name "lisp/" user-emacs-directory) pkdir)
            (progn
              (beginning-of-line)
              (while (search-forward "] " (line-end-position) t) )
              (setq start (point))
              (skip-chars-forward "[a-zA-Z\\-]")
              (setq pkgname (buffer-substring-no-properties start (point)))
              (setq pkdir (directory-files elpa t pkgname t ))
              (if pkdir (dired (car pkdir)))))))))

(defun org-init--sort-packages ()
  "This is just a convenience wrapper for org-sort. It does reverted sort on
          todo keywords-"
  (interactive)
  (save-excursion
    (goto-char (org-init--packages))
    (org-sort-entries nil ?a) ;; first sort alphabetic than in reversed todo-order
    (org-sort-entries nil ?O)
    (org-cycle) (org-cycle)))

(defun org-init--goto-package ()
  (interactive)
  (let ((org-goto-interface 'outline-path-completionp)
        (org-outline-path-complete-in-steps nil))
    (org-goto)))

(defvar org-init-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key org-mode-map [remap org-shiftup] #'org-init--shiftup)
    (define-key org-mode-map [remap org-shiftdown] #'org-init--shiftdown)
    (define-key org-mode-map [remap org-shiftleft] #'org-init--shiftleft)
    (define-key org-mode-map [remap org-shiftright] #'org-init--shiftright)
    (define-key map (kbd "C-c i a") 'add-package)
    (define-key map (kbd "C-c i i") 'install-packages)
    (define-key map (kbd "C-c i p") 'add-pseudo-package)
    (define-key map (kbd "C-c i g") 'generate-init-files)
    (define-key map (kbd "C-c i j") 'org-init--goto-package)
    (define-key map (kbd "C-c C-j") 'org-init--open-in-dired)
    (define-key map (kbd "C-c i s") 'org-init--sort-packages)
    (define-key map (kbd "C-c i u") 'org-init-update-packages)
    map)
  "Keymap used in `org-init-mode'.")

(defvar org-init-mode-enabled nil)
(defvar org-init-old-kwds nil)
(defvar org-init-old-key-alist nil)
(defvar org-init-old-kwd-alist nil)
(defvar org-init-old-log-done nil)
(defvar org-init-old-todo nil)
(setq org-init-mode-enabled nil org-init-old-kwds nil org-init-old-key-alist nil
      org-init-old-kwd-alist nil org-init-old-log-done nil org-init-old-todo nil)
(make-variable-buffer-local 'org-log-done)
(make-variable-buffer-local 'org-todo-keywords)

(defun org-init--longest-str (lst)
  (let ((len 0) l)
    (dolist (elt lst)
      (setq l (length elt))
      (when (lt len l)
        (setq len l)))
    len))

(defun org-init--initial-outline ()
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "^\\* About")
    (hide-subtree)
    (re-search-forward "^\\* Generator")
    (hide-subtree)
    (re-search-forward "^\\* Packages")
    (hide-subtree)
    (show-children)))

(defun org-todo-per-file-keywords (kwds)
  "Sets per file TODO labels. Takes as argument a list of strings to be
                  used as labels."
  (let (alist)
    (push "TODO" alist)
    (dolist (kwd kwds)
      (push kwd alist))
    (setq alist (list (nreverse alist)))
    ;; TODO keywords.
    (setq-local org-todo-kwd-alist nil)
    (setq-local org-todo-key-alist nil)
    (setq-local org-todo-key-trigger nil)
    (setq-local org-todo-keywords-1 nil)
    (setq-local org-done-keywords nil)
    (setq-local org-todo-heads nil)
    (setq-local org-todo-sets nil)
    (setq-local org-todo-log-states nil)
    (let ((todo-sequences alist))
      (dolist (sequence todo-sequences)
        (let* ((sequence (or (run-hook-with-args-until-success
                              'org-todo-setup-filter-hook sequence)
                             sequence))
               (sequence-type (car sequence))
               (keywords (cdr sequence))
               (sep (member "|" keywords))
               names alist)
          (dolist (k (remove "|" keywords))
            (unless (string-match "^\\(.*?\\)\\(?:(\\([^!@/]\\)?.*?)\\)?$"
                                  k)
              (error "Invalid TODO keyword %s" k))
            (let ((name (match-string 1 k))
                  (key (match-string 2 k))
                  (log (org-extract-log-state-settings k)))
              (push name names)
              (push (cons name (and key (string-to-char key))) alist)
              (when log (push log org-todo-log-states))))
          (let* ((names (nreverse names))
                 (done (if sep (org-remove-keyword-keys (cdr sep))
                         (last names)))
                 (head (car names))
                 (tail (list sequence-type head (car done) (org-last done))))
            (add-to-list 'org-todo-heads head 'append)
            (push names org-todo-sets)
            (setq org-done-keywords (append org-done-keywords done nil))
            (setq org-todo-keywords-1 (append org-todo-keywords-1 names nil))
            (setq org-todo-key-alist
                  (append org-todo-key-alist
                          (and alist
                               (append '((:startgroup))
                                       (nreverse alist)
                                       '((:endgroup))))))
            (dolist (k names) (push (cons k tail) org-todo-kwd-alist))))))
    (setq org-todo-sets (nreverse org-todo-sets)
          org-todo-kwd-alist (nreverse org-todo-kwd-alist)
          org-todo-key-trigger (delq nil (mapcar #'cdr org-todo-key-alist))
          org-todo-key-alist (org-assign-fast-keys org-todo-key-alist))
    ;; Compute the regular expressions and other local variables.
    ;; Using `org-outline-regexp-bol' would complicate them much,
    ;; because of the fixed white space at the end of that string.
    (unless org-done-keywords
      (setq org-done-keywords
            (and org-todo-keywords-1 (last org-todo-keywords-1))))
    (setq org-not-done-keywords
          (org-delete-all org-done-keywords
                          (copy-sequence org-todo-keywords-1))
          org-todo-regexp (regexp-opt org-todo-keywords-1 t)
          org-not-done-regexp (regexp-opt org-not-done-keywords t)
          org-not-done-heading-regexp
          (format org-heading-keyword-regexp-format org-not-done-regexp)
          org-todo-line-regexp
          (format org-heading-keyword-maybe-regexp-format org-todo-regexp)
          org-complex-heading-regexp
          (concat "^\\(\\*+\\)"
                  "\\(?: +" org-todo-regexp "\\)?"
                  "\\(?: +\\(\\[#.\\]\\)\\)?"
                  "\\(?: +\\(.*?\\)\\)??"
                  "\\(?:[ \t]+\\(:[[:alnum:]_@#%:]+:\\)\\)?"
                  "[ \t]*$")
          org-complex-heading-regexp-format
          (concat "^\\(\\*+\\)"
                  "\\(?: +" org-todo-regexp "\\)?"
                  "\\(?: +\\(\\[#.\\]\\)\\)?"
                  "\\(?: +"
                  ;; Stats cookies can be stuck to body.
                  "\\(?:\\[[0-9%%/]+\\] *\\)*"
                  "\\(%s\\)"
                  "\\(?: *\\[[0-9%%/]+\\]\\)*"
                  "\\)"
                  "\\(?:[ \t]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?"
                  "[ \t]*$")
          org-todo-line-tags-regexp
          (concat "^\\(\\*+\\)"
                  "\\(?: +" org-todo-regexp "\\)?"
                  "\\(?: +\\(.*?\\)\\)??"
                  "\\(?:[ \t]+\\(:[[:alnum:]:_@#%]+:\\)\\)?"
                  "[ \t]*$"))))

(add-to-list 'org-element-affiliated-keywords "Git")

;; from J. Kitchin:
;; https://kitchingroup.cheme.cmu.edu/blog/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook/
(require 'org-mouse)
(require 'elisp-mode)

(defun scimax-spoof-mode (orig-func &rest args)
  "Advice function to spoof commands in org-mode src blocks.
        It is for commands that depend on the major mode. One example is
        `lispy--eval'."
  (if (org-in-src-block-p)
      (let ((major-mode (intern (format "%s-mode"
                                        (first (org-babel-get-src-block-info))))))
        (apply orig-func args))
    (apply orig-func args)))

(defvar scimax-src-block-keymaps
  `(("emacs-lisp"
     .
     ,(let ((map (make-composed-keymap
                  `(,emacs-lisp-mode-map ,org-init-mode-map)
                  org-mode-map)))
        (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
        map))))

(defun scimax-add-keymap-to-src-blocks (limit)
  "Add keymaps to src-blocks defined in `scimax-src-block-keymaps'."
  (let ((case-fold-search t)
        lang)
    (while (re-search-forward org-babel-src-block-regexp limit t)
      (let ((lang (match-string 2))
            (beg (match-beginning 0))
            (end (match-end 0)))
        (if (assoc (org-no-properties lang) scimax-src-block-keymaps)
            (progn
              (add-text-properties
               beg end `(local-map ,(cdr (assoc
                                          (org-no-properties lang)
                                          scimax-src-block-keymaps))))
              (add-text-properties
               beg end `(cursor-sensor-functions
                         ((lambda (win prev-pos sym)
                            ;; This simulates a mouse click and makes a menu change
                            (org-mouse-down-mouse nil)))))))))))

(define-minor-mode org-init-mode ""
  :global nil :lighter " init-file"
  (unless (derived-mode-p 'org-mode)
    (error "Not in org-mode."))
  (cond (org-init-mode
         (unless org-init-mode-enabled
           (setq org-init-mode-enabled t
                 org-init-old-log-done org-log-done
                 org-init-old-kwds org-todo-keywords-1
                 org-init-old-key-alist org-todo-key-alist
                 org-init-old-kwd-alist org-todo-kwd-alist)
           (setq-local org-log-done nil)
           (let (s kwdlist templist l)
             (dolist (repo package-archives)
               (push (car repo) templist))
             (push "none" templist)
             (setq l (org-init--longest-str templist))
             (dolist (s templist)
               (while (lt (length s) l)
                 (setq s (concat s " ")))
               (push (concat "[ " s " ]") kwdlist))
             (org-todo-per-file-keywords (nreverse kwdlist))))
         (add-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks t)
         (add-to-list 'font-lock-extra-managed-props 'local-map)
         (add-to-list 'font-lock-extra-managed-props 'cursor-sensor-functions)
         ;;(advice-add 'lispy--eval :around 'scimax-spoof-mode)
         (cursor-sensor-mode +1)
         (eldoc-mode +1)
         (company-mode +1))
        (t
         (remove-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks)
         ;;(advice-remove 'lispy--eval 'scimax-spoof-mode)
         (cursor-sensor-mode -1)
         (setq org-todo-keywords-1 org-init-old-kwds
               org-todo-key-alist org-init-old-key-alist
               org-todo-kwd-alist org-init-old-kwd-alist
               org-log-done org-init-old-log-done
               org-init-mode-enabled nil)))
  (font-lock-fontify-buffer))

(org-init--initial-outline)
(org-init-mode +1)
#+end_src
* Packages

** [x] embark
#+begin_src emacs-lisp

#+end_src

** [x] alchemist
#+begin_src emacs-lisp

#+end_src

** [x] inf-elixir
#+begin_src emacs-lisp

#+end_src

** [x] elfeed
#+begin_src emacs-lisp

#+end_src

** [x] reddigg
#+begin_src emacs-lisp

#+end_src

** [x] hnreader
#+begin_src emacs-lisp

#+end_src


** [x] jinx
#+begin_src emacs-lisp

#+end_src

** [x] cape
#+begin_src emacs-lisp
;; Add `completion-at-point-functions', used by `completion-at-point'.
  ;; NOTE: The order matters!
(with-package cape
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  ;;(add-to-list 'completion-at-point-functions #'cape-history)
  ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
  ;;(add-to-list 'completion-at-point-functions #'cape-tex)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
  ;;(add-to-list 'completion-at-point-functions #'cape-dict)
  ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
  ;;(add-to-list 'completion-at-point-functions #'cape-line)
  (setq-local completion-at-point-functions
  (mapcar #'cape-company-to-capf
    (list #'company-files #'company-ispell #'company-dabbrev)))
  )
#+end_src

** [x] window-layout
#+begin_src emacs-lisp

#+end_src

** [ ] org-quick-peek
#+begin_src emacs-lisp

#+end_src

** [x] quick-peek
#+begin_src emacs-lisp

#+end_src
** [ local ] [ ] dired-git-log
#+begin_src emacs-lisp
(with-hook dired-git-log-mode
           (diminish 'dired-git-log-mode))
#+end_src

** [ local ] [ ] emacs-vision
#+begin_src emacs-lisp
(with-eval-after-load 'emacs-vision
  (load "~/apikeys"))
#+end_src
** [ local ] [ ] helper
#+begin_src emacs-lisp
#+end_src
** [ local ] [ ] magit-gh-comments
#+begin_src emacs-lisp
#+end_src
** [ local ] [x] clede
#+begin_src emacs-lisp
#+end_src
** [ local ] [x] dired-auto-readme
#+begin_src emacs-lisp
(with-hook dired-auto-readme-mode (diminish 'dired-auto-readme-mode))

(with-package
 dired-auto-readme
 (add-to-list 'dired-auto-readme-alist
              '(org-mode . (lambda ()
                             ;;(org-toggle-link-display)
                             (org-toggle-pretty-entities)
                             ;;(org-pretty-table-mode)
                             ;;(org-display-inline-images t t)
                             (org-fold-core-initialize)
                             (org-view-mode))))
 
 (add-to-list 'dired-auto-readme-alist
              '(markdown-mode . (lambda ()
                                  ;;(font-lock-mode +1)
                                  ;;(font-lock-ensure)
                                  (markdown-view-mode)))))
#+end_src
** [ local ] [x] org-super-links
#+begin_src emacs-lisp

#+end_src

** [ local ] [x] peep-dired
#+begin_src emacs-lisp
#+end_src
** [ local ] [x] sly-package-inferred
#+begin_src emacs-lisp

#+end_src
** [ local ] [x] sly-stepper
#+begin_src emacs-lisp

#+end_src
** [ local ] [x] speed-of-thought-lisp
#+begin_src emacs-lisp

#+end_src
** [ ] borg
#+begin_src emacs-lisp
#+end_src
** [ ] bui
#+begin_src emacs-lisp
#+end_src
** [ ] corfu
#+begin_src emacs-lisp

#+end_src
** [ ] dired-git.el
#+begin_src emacs-lisp
#+end_src
** [ ] doc-show-inline
#+begin_src emacs-lisp
(with-package doc-show-inline
              (defkeys c-mode-map
                       "C-;" doc-show-inline-mode)
              (defkeys c++-mode-map
                       "C-;" doc-show-inline-mode))
(with-hook c-mode (doc-show-inline-mode +1))
(with-hook c++-mode (doc-show-inline-mode +1))
#+end_src
** [ ] elpy        
#+begin_src emacs-lisp
  (with-package elpy
                (elpy-enable)
                (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
              
                (defkeys elpy-mode-map
                  "C-M-n" elpy-nav-forward-block
                  "C-M-p" elpy-nav-backward-block))
  (with-hook elpy-mode
             ;;(company-mode 1)           
             (flycheck-mode 1)
             ;;(make-local-variable 'company-backends)
             ;;(setq company-backends '((elpy-company-backend :with company-yasnippet)))
             )
#+end_src
** [ ] espuds
#+begin_src emacs-lisp
#+end_src
** [ ] esup        
#+begin_src emacs-lisp
#+end_src
** [ ] evil
#+begin_src emacs-lisp
#+end_src
** [ ] evil-exchange
#+begin_src emacs-lisp
#+end_src
** [ ] evil-matchit
#+begin_src emacs-lisp
#+end_src
** [ ] evil-multiedit
#+begin_src emacs-lisp
#+end_src
** [ ] evil-snipe
#+begin_src emacs-lisp
#+end_src
** [ ] keg
#+begin_src emacs-lisp
(with-hook
 after-init
 (setenv "PATH" (concat (getenv "PATH")
                        ":" (package-desc-dir (package-get-descriptor 'keg)))))
#+end_src
** [ ] lispy
#+begin_src emacs-lisp
#+end_src
** [ ] org-noter-pdftools
#+begin_src emacs-lisp
     (unless (equal system-type 'windows-nt)
       (with-package pdf-annot
                     (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+end_src
** [ ] org-pdftools
#+begin_src emacs-lisp
     (unless (eq system-type 'windows-nt)
       (with-hook org-load
                  (org-pdftools-setup-link)))
#+end_src
** [ ] pdf-tools
#+begin_src emacs-lisp
     (unless (equal system-type 'windows-nt)
       (with-package pdf-tools
                     ;;(pdf-tools-install)
                     (setq-default pdf-view-display-size 'fit-page)))
#+end_src
** [ ] rainbow-mode
#+begin_src emacs-lisp
#+end_src

** [ ] run-command
#+begin_src emacs-lisp
#+end_src
** [x] academic-phrases
#+begin_src emacs-lisp
#+end_src
** [x] ace-window
#+begin_src emacs-lisp
  (with-package ace-window
                (ace-window-display-mode 1)
                ;;(setq aw-dispatch-always t)
                (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src
** [x] aggressive-indent
#+begin_src emacs-lisp
#+end_src
** [x] all-the-icons
#+begin_src emacs-lisp
  (with-package all-the-icons
                (diminish 'all-the-icons-mode)
                (setq neo-theme 'arrow)
                (setq neo-window-fixed-size nil))
#+end_src
** [x] anaphora
#+begin_src emacs-lisp
#+end_src
** [x] ascii-art-to-unicode
#+begin_src emacs-lisp
#+end_src
** [x] ascii-table
#+begin_src emacs-lisp
#+end_src
** [x] async
#+begin_src emacs-lisp
(with-package
 async
 (async-bytecomp-package-mode 1)
 (with-system windows-nt
              ;; https://gist.github.com/kiennq/cfe57671bab3300d3ed849a7cbf2927c
              (eval-when-compile
                (require 'cl-lib))
              (defvar async-maximum-parallel-procs 4)
              (defvar async--parallel-procs 0)
              (defvar async--queue nil)
              (defvar-local async--cb nil)
              (advice-add #'async-start :around
                          (lambda (orig-func func &optional callback)
                            (when (>= async--parallel-procs async-maximum-parallel-procs)
                                (push `(,func ,callback) async--queue)
                                (cl-incf async--parallel-procs)
                                (let ((future (funcall orig-func func
                                                       (lambda (re)
                                                         (cl-decf async--parallel-procs)
                                                         (when async--cb (funcall async--cb re))
                                                         (when-let (args (pop async--queue))
                                                           (apply #'async-start args))))))
                                  (with-current-buffer (process-buffer future)
                                    (setq async--cb callback))))))))
 (with-hook dired-async-mode (diminish 'dired-async-mode))
#+end_src
** [x] auto-yasnippet
#+begin_src emacs-lisp
#+end_src
** [x] avy
#+BEGIN_SRC emacs-lisp
#+END_SRC
** [x] beacon
#+begin_src emacs-lisp
(with-hook after-init (when-idle (beacon-mode t)))
(with-hook beacon-mode (diminish 'beacon-mode))
#+end_src
** [x] blamer
#+begin_src emacs-lisp
#+end_src

** [x] bug-hunter
#+begin_src emacs-lisp
#+end_src
** [x] cfrs
#+begin_src emacs-lisp
#+end_src
** [x] checkdoc
#+begin_src emacs-lisp
#+end_src
** [x] cider
#+begin_src emacs-lisp
#+end_src
** [x] cmake-font-lock
#+begin_src emacs-lisp
  (with-hook prog-mode
             ;; Highlighting in cmake-mode this way interferes with
             ;; cmake-font-lock, which is something I dont yet understand.
             (when (not (derived-mode-p 'cmake-mode))
               (font-lock-add-keywords nil
                                       '(("\\<\\(FIXME\\|TODO\\|BUG\\|DONE\\)"
                                          1 font-lock-warning-face t)))))
  (with-hook cmake-mode
             (cmake-font-lock-activate))
#+end_src
** [x] cmake-mode
#+begin_src emacs-lisp
  (with-hook after-init
             (add-to-list 'auto-mode-alist '("\\.cmake\\'" . cmake-mode))
             (add-to-list 'auto-mode-alist '("\\CMakeLists.txt\\'" . cmake-mode)))
  (with-hook cmake
             (require 'company)
             (require 'company-cmake)
             (company-mode 1))
#+end_src
** [x] command-log-mode
#+begin_src emacs-lisp

#+end_src
** [x] company
#+begin_src emacs-lisp
  (with-hook after-init
             (add-hook 'c-mode-common-hook 'company-mode)
             (add-hook 'sgml-mode-hook 'company-mode)
             (add-hook 'emacs-lisp-mode-hook 'company-mode)
             (add-hook 'text-mode-hook 'company-mode)
             (add-hook 'lisp-mode-hook 'company-mode)
             (when-idle (require 'company)))
  (with-package company 
                (require 'company-capf)
                (require 'company-files)
              
                (diminish 'company-mode)
                (setq company-idle-delay            0.0
                      company-require-match         nil
                      company-minimum-prefix-length 2
                      company-show-quick-access     t
                      company-tooltip-limit         30
                      company-async-timeout         10
                      company-dabbrev-downcase      nil
                      tab-always-indent 'complete
                      company-global-modes '(not term-mode)
                      company-backends (delete 'company-semantic company-backends))
              
                (setq company-backends '(company-capf
                                         company-keywords
                                         company-semantic
                                         ;; company-files
                                         company-etags
                                         company-elisp
                                         company-clang
                                         company-ispell
                                         company-yasnippet
                                         ))
                (define-key company-mode-map
                  [remap indent-for-tab-command] 'company-indent-or-complete-common)
                (defkeys company-active-map
                  "C-n" company-select-next
                  "C-p" company-select-previous))
#+end_src
** [x] company-c-headers        
#+begin_src emacs-lisp
  (with-hook company-c-headers-mode
             (diminish 'company-c-headers-mode)
             (add-to-list 'company-backends 'company-c-headers))
#+end_src
** [x] company-flx
#+begin_src emacs-lisp
  (with-hook company
             (company-flx-mode +1))
#+end_src
** [x] company-math
#+begin_src emacs-lisp
  (with-package company-math
                (diminish 'company-math-mode)
                (add-to-list 'company-backends 'company-math-symbols-latex)
                (add-to-list 'company-backends 'company-math-symbols-unicode))
#+end_src
** [x] company-quickhelp
#+begin_src emacs-lisp
  (with-package company-quickhelp-mode
                (diminish 'company-quickhelp-mode)
                (add-hook 'global-company-mode-hook 'company-quickhelp-mode))
#+end_src
** [x] company-statistics
#+begin_src emacs-lisp
#+end_src
** [x] company-try-hard
#+begin_src emacs-lisp
#+end_src
** [x] company-web
#+begin_src emacs-lisp
#+end_src
** [x] consult
#+begin_src emacs-lisp

#+end_src
** [x] crux
#+begin_src emacs-lisp
#+end_src
** [x] dap-mode
#+begin_src emacs-lisp
  (with-package dap-mode
                (dap-auto-configure-mode))
#+end_src
** [x] dash
#+begin_src emacs-lisp
#+end_src
** [x] debbugs
#+begin_src emacs-lisp
#+end_src
** [x] deferred
#+begin_src emacs-lisp
#+end_src
** [x] deft        
#+begin_src emacs-lisp
#+end_src
** [x] devdocs-browser
#+begin_src emacs-lisp
#+end_src
** [x] diminish        
#+begin_src emacs-lisp
#+end_src
** [x] diredfl
#+begin_src emacs-lisp

#+end_src

** [x] dired-hacks-utils        
#+begin_src emacs-lisp
#+end_src
** [x] dired-narrow        
#+begin_src emacs-lisp
#+end_src
** [x] dired-quick-sort
#+begin_src emacs-lisp
#+end_src
** [x] dired-rsync
#+begin_src emacs-lisp
(with-hook after-init (when-idle (require 'dired-async)))
(with-package dired (require 'dired-async))
#+end_src
** [x] dired-subtree
#+begin_src emacs-lisp
(with-hook after-init (when-idle (require 'dired-subtree)))
(with-package dired-subtree
              (setq dired-subtree-line-prefix "    "
                    dired-subtree-use-backgrounds nil))
#+end_src
** [x] d-mode
#+begin_src emacs-lisp
(with-hook after-init
           (add-to-list 'auto-mode-alist '("\\.d[i]?\\'" . d-mode)))
#+end_src
** [x] drag-stuff
#+begin_src emacs-lisp

#+end_src

** [x] dumb-jump        
#+begin_src emacs-lisp
#+end_src
** [x] easy-escape
#+begin_src emacs-lisp

#+end_src

** [ ] ecukes
#+begin_src emacs-lisp
#+end_src
** [x] eldev
#+begin_src emacs-lisp
#+end_src
** [x] elisp-benchmarks
#+begin_src emacs-lisp
#+end_src

** [x] elisp-def
#+begin_src emacs-lisp
#+end_src
** [x] elisp-slime-nav
#+begin_src emacs-lisp
#+end_src
** [x] elnode
#+begin_src emacs-lisp
#+end_src
** [x] el-search
#+begin_src emacs-lisp
#+end_src
** [x] embark
#+begin_src emacs-lisp

#+end_src

** [x] emms
#+begin_src emacs-lisp
(with-hook after-init
           (when-idle (require 'emms))
           (defkeys global-map
             ;; emms
             "C-v e SPC"  emms-pause
             "C-v e d"    emms-play-directory
             "C-v e l"    emms-play-list
             "C-v e n"    emms-next
             "C-v e p"    emms-previous
             "C-v e a"    emms-add-directory
             "C-v e A"    emms-add-directory-tree
             "C-v e +"    pulseaudio-control-increase-volume
             "C-v e -"    pulseaudio-control-decrease-volume
             "C-v e r"    emms-start
             "C-v e s"    emms-stop
             "C-v e m"    emms-play-m3u-playlist))
(with-package emms
              (require 'emms)
              (require 'emms-setup)
              (require 'emms-volume)
              (require 'emms-source-file)
              (require 'emms-source-playlist)
              (require 'emms-playlist-mode)
              (require 'emms-playlist-limit)
              (require 'emms-playing-time)
              (require 'emms-mode-line-cycle)
              (require 'emms-player-mpv)
              (emms-all)
              (emms-history-load)
              (emms-default-players)
              (helm-mode 1)
              (setq-default emms-player-list '(emms-player-mpv)
                            emms-player-mpv-environment '("PULSE_PROP_media.role=music"))
              
              (setq emms-source-file-default-directory (expand-file-name "~/Musik"))
              (setq emms-directory (expand-file-name "etc/emms/" user-emacs-directory)
                    emms-cache-file (expand-file-name "cache" emms-directory)
                    emms-history-file (expand-file-name "history" emms-directory)
                    emms-score-file (expand-file-name "scores" emms-directory)
                    emms-stream-bookmark-file (expand-file-name "streams" emms-directory)
                    emms-playlist-buffer-name "*Music Playlist*"
                    emms-show-format "Playing: %s"
                    ;; Icon setup.
                    emms-mode-line-icon-before-format "["
                    emms-mode-line-format " %s]"
                    emms-playing-time-display-format "%s ]"
                    emms-mode-line-icon-color "lightgrey"
                    global-mode-string '("" emms-mode-line-string " " emms-playing-time-string)
                    emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find
                    emms-browser-covers 'emms-browser-cache-thumbnail)
              
              (add-to-list 'emms-info-functions 'emms-info-cueinfo)
              
              (when (executable-find "emms-print-metadata")
                (require 'emms-info-libtag)
                (add-to-list 'emms-info-functions 'emms-info-libtag)
                (delete 'emms-info-ogginfo emms-info-functions)
                (delete 'emms-info-mp3info emms-info-functions)
                (add-to-list 'emms-info-functions 'emms-info-ogginfo)
                (add-to-list 'emms-info-functions 'emms-info-mp3info))
              
              (add-hook 'emms-browser-tracks-added-hook 'z-emms-play-on-add)
              (add-hook 'emms-player-started-hook 'emms-show))
#+end_src
** [x] emms-mode-line-cycle        
#+begin_src emacs-lisp
#+end_src
** [x] emr
#+begin_src emacs-lisp
#+end_src
** [x] engine-mode
#+begin_src emacs-lisp

#+end_src
** [x] equake
#+begin_src emacs-lisp
(with-package equake
              (advice-add #'save-buffers-kill-terminal :before-while #'equake-kill-emacs-advice)
              (global-set-key (kbd "C-M-^") #'equake-restore-last-etab)
              (setq equake-default-shell 'eshell)
              ;; set list of available shells
              (setq equake-available-shells
                    '("shell"
                      "eshell"
                      "ielm")))
#+end_src
** [x] eros
#+begin_src emacs-lisp
#+end_src
** [x] ert-runner
#+begin_src emacs-lisp
#+end_src
** [x] esxml
#+begin_src emacs-lisp
#+end_src
** [x] ewmctrl
#+begin_src emacs-lisp
#+end_src
** [x] expand-region        
#+begin_src emacs-lisp
(with-hook after-init
           (defkeys global-map
             "C-+" er/expand-region
             "C--" er/contract-region))
(with-hook expand-region-mode
           (diminish 'expand-region-mode))
#+end_src
** [x] f
#+begin_src emacs-lisp
#+end_src
** [x] feebleline
#+begin_src emacs-lisp
#+end_src
** [x] flimenu        
#+begin_src emacs-lisp
(with-package flimenu
              (flimenu-global-mode))
#+end_src
** [x] flycheck        
#+begin_src emacs-lisp
#+end_src
** [x] flycheck-languagetool
#+begin_src emacs-lisp
(with-package
 flycheck-languagetool
 (setq flycheck-languagetool-server-jar
       "/usr/share/java/languagetool/languagetool-server.jar"))
#+end_src
** [x] flycheck-package
#+begin_src emacs-lisp
#+end_src
** [x] geiser
#+begin_src emacs-lisp

 
#+end_src

** [x] geiser-guile
#+begin_src emacs-lisp
(with-hook
 geiser-guile
 (require 'sc-extras)
 (setq geiser-repl-use-other-window nil))           
#+end_src
** [x] geiser-racket
#+begin_src emacs-lisp
(with-hook
 geiser-racket
 (require 'sc-extras))
#+end_src

** [x] gh        
#+begin_src emacs-lisp
#+end_src
** [x] gif-screencast
#+begin_src emacs-lisp
#+end_src
** [x] gist        
#+begin_src emacs-lisp
#+end_src
** [x] git-gutter        
#+begin_src emacs-lisp
#+end_src
** [x] github-clone.el
#+begin_src emacs-lisp
#+end_src

** [x] github-search        
#+begin_src emacs-lisp
#+end_src
** [x] git-link        
#+begin_src emacs-lisp
#+end_src
** [x] git-messenger
#+begin_src emacs-lisp
#+end_src
** [x] gnu-elpa-keyring-update
#+begin_src emacs-lisp
#+end_src
** [x] google-c-style        
#+begin_src emacs-lisp
(with-hook google-c-style-mode
           (diminish 'google-c-style-mode))
#+end_src
** [x] goto-last-change        
#+begin_src emacs-lisp
#+end_src
** [x] helm        
#+begin_src emacs-lisp
(with-hook after-init (when-idle
                       (require 'helm)
                       (require 'helm-files)
                       (require 'helm-eshell)
                       (require 'helm-buffers)
                       (require 'helm-adaptive)
                       (message "Helm loaded on idle.")))
(with-hook eshell-mode
           (defkeys eshell-mode-map
                    "C-c C-h" helm-eshell-history
                    "C-c C-r" helm-comint-input-ring
                    "C-c C-l" helm-minibuffer-history))
(with-hook helm-ff-cache-mode
           (diminish 'helm-ff-cache-mode))
(with-package helm
              (require 'helm-eshell)
              (require 'helm-buffers)
              (require 'helm-files)
              
              (defun helm-buffer-p (window new-buffer bury-or-kill)
                "Returns T when NEW-BUFFER's name matches any regex in
`helm-boring-buffer-regexp-list'."
                (catch 'helm-p
                  (dolist (regex helm-boring-buffer-regexp-list)
                    (if (string-match-p regex (buffer-name new-buffer))
                        (throw 'helm-p t)))))

              (defvar helm-source-header-default-background (face-attribute
                                                             'helm-source-header :background)) 
              (defvar helm-source-header-default-foreground (face-attribute
                                                             'helm-source-header :foreground)) 
              (defvar helm-source-header-default-box (face-attribute
                                                      'helm-source-header :box))
              (set-face-attribute 'helm-source-header nil :height 0.1)
              (defun helm-toggle-header-line ()
                (if (gt (length helm-sources) 1)
                    (set-face-attribute 'helm-source-header
                                        nil
                                        :foreground helm-source-header-default-foreground
                                        :background helm-source-header-default-background
                                        :box helm-source-header-default-box
                                        :height 1.0)
                  (set-face-attribute 'helm-source-header
                                      nil
                                      :foreground (face-attribute 'helm-selection :background)
                                      :background (face-attribute 'helm-selection :background)
                                      :box nil
                                      :height 0.1)))
              
              (setq helm-completion-style             'emacs
                    helm-display-header-line              nil
                    ;; helm-completion-in-region-fuzzy-match t
                    ;; helm-recentf-fuzzy-match              t
                    ;; helm-buffers-fuzzy-matching           t
                    ;; helm-locate-fuzzy-match               t
                    ;; helm-lisp-fuzzy-completion            t
                    ;; helm-session-fuzzy-match              t
                    ;; helm-apropos-fuzzy-match              t
                    ;; helm-imenu-fuzzy-match                t
                    ;; helm-semantic-fuzzy-match             t
                    ;; helm-M-x-fuzzy-match                  t
                    helm-split-window-inside-p            t
                    helm-move-to-line-cycle-in-source     t
                    helm-ff-search-library-in-sexp        t
                    helm-scroll-amount                    8
                    helm-ff-file-name-history-use-recentf t
                    helm-ff-auto-update-initial-value     nil
                    helm-net-prefer-curl                  t
                    helm-autoresize-max-height            0
                    helm-autoresize-min-height           30
                    helm-candidate-number-limit         100
                    helm-idle-delay                     0.0
                    helm-input-idle-delay               0.0
                    switch-to-prev-buffer-skip         'helm-buffer-p
                    helm-ff-cache-mode-lighter-sleep    nil
                    helm-ff-cache-mode-lighter-updating nil
                    helm-ff-cache-mode-lighter          nil
                    helm-ff-skip-boring-files            t)
              
              (dolist (regexp '("\\`\\*direnv" "\\`\\*straight" "\\`\\*xref"))
                (push regexp helm-boring-buffer-regexp-list))

              (helm-autoresize-mode 1)
              (helm-adaptive-mode t)
              (helm-mode 1)
              (add-to-list 'helm-sources-using-default-as-input
                           'helm-source-man-pages)
              (setq helm-mini-default-sources '(helm-source-buffers-list
                                                helm-source-bookmarks
                                                helm-source-recentf
                                                helm-source-buffer-not-found
                                                projectile-known-projects))
              (defkeys helm-map
                       "M-i" helm-previous-line
                       "M-k" helm-next-line
                       "M-I" helm-previous-page
                       "M-K" helm-next-page
                       "M-h" helm-beginning-of-buffer
                       "M-H" helm-end-of-buffer)

              (defkeys shell-mode-map
                       "C-c C-l" helm-comint-input-ring)
              
              (defkeys helm-read-file-map
                       ;;"RET" my-helm-return
                       "C-o" my-helm-next-source))

(with-hook after-init
           (defkeys global-map
                    "M-x"     helm-M-x
                    "C-z ,"   helm-pages
                    "C-x C-b" helm-buffers-list
                    "C-z a"   helm-ag
                    "C-z b"   helm-filtered-bookmarks
                    "C-z c"   helm-company
                    "C-z d"   helm-dabbrev
                    "C-z e"   helm-calcul-expression
                    "C-z g"   helm-google-suggest
                    "C-z h"   helm-descbinds
                    "C-z i"   helm-imenu-anywhere
                    "C-z k"   helm-show-kill-ring
                    "C-z C-c" helm-git-local-branches
                    "C-z f"   helm-find-files
                    "C-z m"   helm-mini
                    "C-z o"   helm-occur
                    "C-z p"   helm-browse-project
                    "C-z q"   helm-apropos
                    "C-z r"   helm-recentf
                    "C-z s"   helm-swoop
                    "C-z C-c" helm-colors
                    "C-z x"   helm-M-x
                    "C-z y"   helm-yas-complete
                    "C-z C-g" helm-ls-git-ls
                    "C-z C-b" helm-git-local-branches
                    "C-z SPC" helm-all-mark-rings))
(with-hook helm-mode
           ;; (helm-flx-mode +1)
           (diminish 'helm-mode)
           (helm-adaptive-mode 1))
#+end_src
** [x] helm-ag        
#+begin_src emacs-lisp
(with-package helm-ag
              (setq helm-ag-use-agignore t
                    helm-ag-base-command 
                    "ag --mmap --nocolor --nogroup --ignore-case --ignore=*terraform.tfstate.backup*"))
#+end_src
** [x] helm-company
#+begin_src emacs-lisp
#+end_src
** [x] helm-c-yasnippet        
#+begin_src emacs-lisp
(with-package helm-c-yasnippet
              (setq helm-yas-space-match-any-greedy t))
#+end_src
** [x] helm-dash        
#+begin_src emacs-lisp
#+end_src
** [x] helm-descbinds        
#+begin_src emacs-lisp
#+end_src
** [x] helm-dired-history       
#+begin_src emacs-lisp
(with-package helm-dired-history
              (require 'savehist)
              (add-to-list 'savehist-additional-variables
                           'helm-dired-history-variable)
              (savehist-mode 1)
              (with-eval-after-load "dired"
                (require 'helm-dired-history)
                (define-key dired-mode-map "," 'dired)))
#+end_src
** [x] helm-emms        
#+begin_src emacs-lisp
#+end_src
** [x] helm-firefox        
#+begin_src emacs-lisp
#+end_src
** [x] helm-flx
#+begin_src emacs-lisp
(with-package helm
           (when-idle
            (setq helm-flx-for-helm-find-files t
                  helm-flx-for-helm-locate t)
            (helm-flx-mode +1)))
#+end_src
** [x] helm-flyspell        
#+begin_src emacs-lisp
#+end_src
** [x] helm-fuzzier        
#+begin_src emacs-lisp
#+end_src
** [x] helm-git-grep
#+begin_src emacs-lisp
#+end_src
** [x] helm-ls-git        
#+begin_src emacs-lisp
#+end_src
** [x] helm-lsp
#+begin_src emacs-lisp
(with-package helm-lsp
              (defun netrom/helm-lsp-workspace-symbol-at-point ()
                (interactive)
                (let ((current-prefix-arg t))
                  (call-interactively 'helm-lsp-workspace-symbol)))
              (defun netrom/helm-lsp-global-workspace-symbol-at-point ()
                (interactive)
                (let ((current-prefix-arg t))
                  (call-interactively 'helm-lsp-global-workspace-symbol)))
              (setq netrom--general-lsp-hydra-heads
                    '(;; Xref
                      ("d" xref-find-definitions "Definitions" :column "Xref")
                      ("D" xref-find-definitions-other-window "-> other win")
                      ("r" xref-find-references "References")
                      ("s" netrom/helm-lsp-workspace-symbol-at-point "Helm search")
                      ("S" netrom/helm-lsp-global-workspace-symbol-at-point "Helm global search")
                      ;; Peek
                      ("C-d" lsp-ui-peek-find-definitions "Definitions" :column "Peek")
                      ("C-r" lsp-ui-peek-find-references "References")
                      ("C-i" lsp-ui-peek-find-implementation "Implementation")
                      ;; LSP
                      ("p" lsp-describe-thing-at-point "Describe at point" :column "LSP")
                      ("C-a" lsp-execute-code-action "Execute code action")
                      ("R" lsp-rename "Rename")
                      ("t" lsp-goto-type-definition "Type definition")
                      ("i" lsp-goto-implementation "Implementation")
                      ("f" helm-imenu "Filter funcs/classes (Helm)")
                      ("C-c" lsp-describe-session "Describe session")
                      ;; Flycheck
                      ("l" lsp-ui-flycheck-list "List errs/warns/notes" :column "Flycheck"))
                    netrom--misc-lsp-hydra-heads
                    '(;; Misc
                      ("q" nil "Cancel" :column "Misc")
                      ("b" pop-tag-mark "Back")))
              ;; Create general hydra.
              (eval `(defhydra netrom/lsp-hydra (:color blue :hint nil)
                       ,@(append
                          netrom--general-lsp-hydra-heads
                          netrom--misc-lsp-hydra-heads)))
              (defkeys lsp-mode-map
                       [remap xref-find-apropos] helm-lsp-workspace-symbol
                       "C-c C-l" netrom/lsp-hydra/body))
#+end_src
** [x] helm-make        
#+begin_src emacs-lisp
#+end_src
** [x] helm-navi        
#+begin_src emacs-lisp
#+end_src
** [x] helm-org        
#+begin_src emacs-lisp
#+end_src
** [x] helm-pages
#+begin_src emacs-lisp
#+end_src
** [x] helm-projectile        
#+begin_src emacs-lisp
#+end_src
** [x] helm-sly 
#+begin_src emacs-lisp
#+end_src
** [x] helm-smex        
#+begin_src emacs-lisp
#+end_src
** [x] helm-swoop        
#+begin_src emacs-lisp
#+end_src
** [x] helm-system-packages
#+begin_src emacs-lisp
#+end_src
** [x] helm-xref        
#+begin_src emacs-lisp
#+end_src
** [x] helpful        
#+begin_src emacs-lisp
(with-package helpful
              (define-key helpful-mode-map (kbd "i")
                (lambda nil (interactive) (info-lookup 'symbol helpful--sym #'emacs-lisp-mode)))
              (setq helpful-max-buffers 1))
(with-hook after-init
           (defkeys global-map
             "C-h C-v" helpful-variable
             "C-h C-k" helpful-key
             "C-h C-f" helpful-callable
             "C-h C-j" helpful-at-point
             "C-h C-u" helpful-command))
#+end_src
** [x] hide-mode-line
#+begin_src emacs-lisp
#+end_src
** [x] ht
#+begin_src emacs-lisp
#+end_src
** [x] htmlize
#+begin_src emacs-lisp
#+end_src

** [x] hydra
#+begin_src emacs-lisp
(with-package hydra
              (defkeys global-map
                "C-x t"
                (defhydra toggle (:color blue)
                  "toggle"
                  ("a" abbrev-mode "abbrev")
                  ("s" flyspell-mode "flyspell")
                  ("d" toggle-debug-on-error "debug")
                  ("c" fci-mode "fCi")
                  ("f" auto-fill-mode "fill")
                  ("t" toggle-truncate-lines "truncate")
                  ("w" whitespace-mode "whitespace")
                  ("q" nil "cancel"))
                "C-x j"
                (defhydra gotoline
                  ( :pre (linum-mode 1)
                    :post (linum-mode -1))
                  "goto"
                  ("t" (lambda () (interactive)(move-to-window-line-top-bottom 0)) "top")
                  ("b" (lambda () (interactive)(move-to-window-line-top-bottom -1)) "bottom")
                  ("m" (lambda () (interactive)(move-to-window-line-top-bottom)) "middle")
                  ("e" (lambda () (interactive)(goto-char (point-max)) "end"))
                  ("c" recenter-top-bottom "recenter")
                  ("n" next-line "down")
                  ("p" (lambda () (interactive) (forward-line -1))  "up")
                  ("g" goto-line "goto-line"))
                "C-c t"
                (defhydra hydra-global-org (:color blue)
                  "Org"
                  ("t" org-timer-start "Start Timer")
                  ("s" org-timer-stop "Stop Timer")
                  ("r" org-timer-set-timer "Set Timer") ; This one requires you be in an orgmode doc, as it sets the timer for the header
                  ("p" org-timer "Print Timer") ; output timer value to buffer
                  ("w" (org-clock-in '(4)) "Clock-In") ; used with (org-clock-persistence-insinuate) (setq org-clock-persist t)
                  ("o" org-clock-out "Clock-Out") ; you might also want (setq org-log-note-clock-out t)
                  ("j" org-clock-goto "Clock Goto") ; global visit the clocked task
                  ("c" org-capture "Capture") ; Dont forget to define the captures you want http://orgmode.org/manual/Capture.html
                  ("l" (or )rg-capture-goto-last-stored "Last Capture"))))
#+end_src
** [x] iedit        
#+begin_src emacs-lisp
#+end_src
** [x] imenu-anywhere        
#+begin_src emacs-lisp
#+end_src
** [x] import-js        
#+begin_src emacs-lisp
#+end_src
** [x] keycast
#+begin_src emacs-lisp
#+end_src
** [x] kv
#+begin_src emacs-lisp
#+end_src
** [x] languagetool
#+begin_src emacs-lisp
(with-package
 languagetool
 (setq languagetool-java-arguments '("-Dfile.encoding=UTF-8")
       languagetool-console-command "/usr/share/java/languagetool/languagetool-commandline.jar"
       languagetool-server-command "/usr/share/java/languagetool/languagetool-server.jar"))
#+end_src
** [x] lisp-extra-font-lock
#+begin_src emacs-lisp

#+end_src

** [ ] lsp-java        
#+begin_src emacs-lisp
#+end_src
** [ ] lsp-mode        
#+begin_src emacs-lisp
(with-package lsp-mode
              (setq lsp-diagnostic-provider :none
                    lsp-keymap-prefix "C-f"
                    lsp-completion-provider t
                    lsp-enable-xref t
                    lsp-auto-configure t
                    lsp-auto-guess-root t
                    ;;lsp-inhibit-message t
                    lsp-enable-snippet t
                    lsp-restart 'interactive
                    lsp-log-io nil
                    lsp-idle-delay 0.1
                    lsp-enable-links nil
                    lsp-enable-symbol-highlighting t
                    lsp-keep-workspace-alive t
                    lsp-clients-clangd-args '("-j=4" "-background-index" "-log=error")
                    ;; python
                    ;; lsp-python-executable-cmd "python3"
                    ;; lsp-python-ms-executable "~/repos/python-language-server/output/bin/Release/osx-x64/publish/Microsoft.Python.LanguageServer"
                    lsp-enable-completion-enable t
                    lsp-pyls-plugins-flake8-enabled t)
              
              (lsp-register-custom-settings
               '(("pyls.plugins.pyls_mypy.enabled" t t)
                 ("pyls.plugins.pyls_mypy.live_mode" nil t)
                 ("pyls.plugins.pyls_black.enabled" t t)
                 ("pyls.plugins.pyls_isort.enabled" t t)
                 ;; Disable these as they're duplicated by flake8
                 ("pyls.plugins.pycodestyle.enabled" nil t)
                 ("pyls.plugins.mccabe.enabled" nil t)
                 ("pyls.plugins.pyflakes.enabled" nil t)))
               (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
               (add-hook 'lsp-managed-mode-hook (lambda () (setq-local company-backends
                                                                       '(company-capf))))
               (require 'dap-chrome)
               (require 'dap-cpptools)
               (diminish 'lsp-mode))

(with-hook python-mode
           (lsp-deferred))
#+end_src
** [ ] lsp-pyright
#+begin_src emacs-lisp
     ;; (with-package lsp-pyright
     ;;               (setq lsp-clients-python-library-directories '("/usr"
     ;;                                                              "~/miniconda3/pkgs")
     ;;                     lsp-pyright-disable-language-service nil
     ;;                     lsp-pyright-dsable-organize-imports nil
     ;;                     lsp-pyright-auto-import-completions t
     ;;                     lsp-pyright-use-library-code-for-types t
     ;;                     lsp-pyright-venv-pat "~/miniconda3/envs"))
     ;; (with-hook python-mode
     ;;            (require 'lsp-pyright)
     ;;            (lsp-deferred)
     ;;            (setq python-shell-interpreter "ipython"
     ;;                  python-shell-interpreter-args "-i --simple-prompt"))
#+end_src
** [ ] lsp-treemacs        
#+begin_src emacs-lisp
#+end_src
** [ ] lsp-ui
#+begin_src emacs-lisp
(with-package lsp-ui
              (add-hook 'lsp-mode-hook 'lsp-ui-mode)
              (setq lsp-ui-doc-enable t
                    lsp-ui-sideline-show-hover t
                    lsp-ui-doc-header t
                    lsp-ui-doc-delay 2
                    lsp-ui-doc-include-signature t
                    lsp-ui-doc-position 'top
                    lsp-ui-doc-alignment 'frame
                    lsp-ui-doc-border (face-foreground 'default)
                    lsp-ui-sideline-enable nil
                    lsp-ui-sideline-ignore-duplicate t
                    lsp-ui-sideline-show-code-actions nil
                    lsp-ui-sideline-ignore-duplicate t
                    ;; Use lsp-ui-doc-webkit only in GUI
                    lsp-ui-doc-use-webkit t
                    lsp-ui-doc-include-signature t
                    lsp-ui-doc-use-childframe t
                    ;; WORKAROUND Hide mode-line of the lsp-ui-imenu buffer
                    ;; https://github.com/emacs-lsp/lsp-ui/issues/243
                    ;;mode-line-format nil
                    )
              (defadvice lsp-ui-imenu (after hide-lsp-ui-imenu-mode-line activate))
           (defkeys lsp-ui-mode-map
             [remap xref-find-references]  lsp-ui-peek-find-references
             [remap xref-find-definitions] lsp-ui-peek-find-definitions
             "C-c u" lsp-ui-imenu))
(with-hook lsp-ui-mode
           (diminish 'lsp-ui-mode))
#+end_src
** [x] lusty-explorer
#+begin_src emacs-lisp
#+end_src
** [x] macro-math
#+begin_src emacs-lisp
#+end_src
** [x] macrostep
#+begin_src emacs-lisp
;;(with-hook edebug-mode (macrostep-mode +1))
#+end_src

** [x] macrostep-geiser
#+begin_src emacs-lisp

#+end_src

** [x] magit        
#+begin_src emacs-lisp
#+end_src
** [x] magit-filenotify
#+begin_src emacs-lisp
#+end_src
** [x] magit-gh-pulls
#+begin_src emacs-lisp
#+end_src

** [x] markdown-mode        
#+begin_src emacs-lisp
#+end_src
** [x] marshal        
#+begin_src emacs-lisp
#+end_src
** [x] mc-extras        
#+begin_src emacs-lisp
#+end_src
** [x] mini-modeline
#+begin_src emacs-lisp

#+end_src
** [x] mmm-mode
#+begin_src emacs-lisp
#+end_src
** [x] modern-cpp-font-lock        
#+begin_src emacs-lisp
(with-hook modern-cpp-font-lock-mode
           (diminish 'modern-cpp-font-lock-mode))
#+end_src
** [x] multiple-cursors        
#+begin_src emacs-lisp
#+end_src
** [x] nadvice
#+begin_src emacs-lisp
#+end_src
** [x] navi-mode        
#+begin_src emacs-lisp
#+end_src
** [x] nov        
#+begin_src emacs-lisp
(with-hook after-init
           (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+end_src
** [x] oauth2 :disable
#+begin_src emacs-lisp
#+end_src
** [x] ob-async
#+begin_src emacs-lisp
#+end_src

** [x] org
#+begin_src emacs-lisp
(with-hook org-mode
           (when (equal (buffer-name) "init.org")
             (org-babel-hide-markers-mode 1)
             (diminish 'org-babel-hide-markers-mode)
             (auto-save-mode 1)
             (page-break-lines-mode 1))
           (yas-minor-mode 1)
           (org-pretty-table-mode 1)
           (diminish 'org-pretty-table-mode))

(with-package org
              (require 'org-protocol)
              (require 'org-pretty-table)

              (defkeys org-mode-map
                       [C-enter] other-window
                       [C-S-<return>] org-insert-heading-respect-content)
              
              (defun get-html-title-from-url (url)
                "Return content in <title> tag."
                (require 'mm-url)
                (let (x1 x2 (download-buffer (url-retrieve-synchronously url)))
                  (with-current-buffer download-buffer
                    (goto-char (point-min))
                    (setq x1 (search-forward "<title>"))
                    (search-forward "</title>")
                    (setq x2 (search-backward "<"))
                    (mm-url-decode-entities-string (buffer-substring-no-properties x1 x2)))))
              
              (defun my-org-insert-link ()
                "Insert org link where default description is set to html title."
                (interactive)
                (let* ((url (read-string "URL: "))
                       (title (get-html-title-from-url url)))
                  (org-insert-link nil url title)))
              
              (defun org-agenda-show-agenda-and-todo (&optional arg)
                ""
                (interactive "P")
                (org-agenda arg "c")
                (org-agenda-fortnight-view))
              ;; ("P" "Research project" entry (file "~/Org/inbox.org")
              ;;  "* TODO %^{Project title} :%^G:\n:PROPERTIES:\n:CREATED:
              ;;     %U\n:END:\n%^{Project description}\n** [x] 
              ;;    TODO Literature review\n** [x] TODO %?\n** [x]
              ;;  TODO Summary\n** [x] TODO Reports\n** [x] Ideas\n"
              ;;  :clock-in t :clock-resume t)
              
              (defun transform-square-brackets-to-round-ones(string-to-transform)
                "Transforms [ into ( and ] into ), other chars left unchanged."
                (concat
                 (mapcar #'(lambda (c)
                             (if (equal c ?[) ?\( (if (equal c ?]) ?\) c ))) string-to-transform)))
              
              (setq org-capture-templates
                    `(("p" "Protocol" entry (file+headline "~/Dokument/notes.org" "Inbox")
                       "* %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")
                      ("L" "Protocol Link" entry (file+headline "~/Dokument/notes.org" "Inbox")
                       "* %? [[%:link][%(transform-square-brackets-to-round-ones\"%:description\")]]\n")
                      ("d" "Denote" plain (file "~/Dokument/denotes.org")
                       "* %^{Description} %^g\n  Created: %U\n  Author:%n\n  ID:%<%y%m%d%H%M%S>\n\n%?"
                       :empty-lines 1)
                      ("r" "To Read" plain (file "~/Dokument/reading.org")
                       "* %A %^g\n  Created: %U\n  ID: %<%y%m%d%H%M%S>\n\n%?"
                       :empty-lines 1)
                      ("n" "Note" entry (file+olp+datetree "~/Dokument/notes.org")
                       "* [[%:link][%:description]] %^g\n%? %U" :empty-lines 1)
                      ("e" "Email" entry (file "~/Dokument/inbox.org")
                       "* TODO %? email |- %:from: %:subject
                    :EMAIL:\n:PROPERTIES:\n:CREATED: %U\n:EMAIL-SOURCE:
                    %l\n:END:\n%U\n"
                       :clock-in t :clock-resume t)))
              (setq  org-log-done 'time
                     org-ditaa-jar-path "/usr/bin/ditaa"
                     org-todo-keywords '((sequence "TODO" "INPROGRESS" "DONE"))
                     org-todo-keyword-faces '(("INPROGRESS" . (:foreground "blue" :weight bold)))
                     org-directory (expand-file-name "~/Dokument/")
                     org-default-notes-file (expand-file-name "notes.org" org-directory)
                     org-use-speed-commands       t
                     org-src-preserve-indentation t
                     org-export-html-postamble    nil
                     org-hide-leading-stars       t
                     org-make-link-description    t
                     org-hide-emphasis-markers    t
                     org-startup-folded           'overview
                     org-startup-indented         nil))
#+end_src
** [x] org-appear
#+begin_src emacs-lisp
#+end_src
** [x] org-bullets
#+begin_src emacs-lisp

#+end_src
** [x] org-contrib
#+begin_src emacs-lisp
#+end_src

** [x] org-download
#+begin_src emacs-lisp
#+end_src
** [x] org-projectile
#+begin_src emacs-lisp
(with-package org-projectile
              (require 'org-projectile)
              (setq org-projectile-projects-file "~Dokument/todos.org"
                    org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
              (push (org-projectile-project-todo-entry) org-capture-templates)
              
              (defkeys global-map
                       "C-c n p" org-projectile-project-todo-completing-read
                       "C-c c" org-capture))
#+end_src
** [x] org-projectile-helm
#+begin_src emacs-lisp
#+end_src
** [x] org-ref
#+begin_src emacs-lisp
#+end_src

** [x] org-roam
#+begin_src emacs-lisp
#+end_src
** [x] org-sidebar
#+begin_src emacs-lisp
#+end_src
** [x] org-superstar
#+begin_src emacs-lisp
#+end_src
** [x] org-view-mode
#+begin_src emacs-lisp

#+end_src

** [x] outshine
#+begin_src emacs-lisp
(with-hook outshine-mode (diminish 'outshine-mode))
#+end_src
** [x] overseer
#+begin_src emacs-lisp
#+end_src
** [x] package-lint
#+begin_src emacs-lisp
#+end_src
** [x] package-lint
#+begin_src emacs-lisp
#+end_src
** [x] page-break-lines
#+begin_src emacs-lisp
(with-hook page-break-lines-mode (diminish 'page-break-lines-mode))
#+end_src
** [x] paxedit
#+begin_src emacs-lisp

#+end_src
** [x] pfuture
#+begin_src emacs-lisp
#+end_src
** [x] plisp-mode
#+begin_src emacs-lisp
#+end_src
** [x] polymode
#+begin_src emacs-lisp
#+end_src
** [x] prettier-js        
#+begin_src emacs-lisp
     (with-package prettier-js
                   (diminish 'prettier-js-mode))
     (with-hook js2-mode
                (prettier-js-mode))
     (with-hook rjsx-mode
                (prettier-js-mode))
#+end_src
** [x] pretty-symbols
#+begin_src emacs-lisp
#+end_src
** [x] prodigy
#+begin_src emacs-lisp
#+end_src
** [x] projectile        
#+begin_src emacs-lisp
(with-package projectile
              (setq projectile-indexing-method 'alien))
#+end_src
** [x] pulseaudio-control
#+begin_src emacs-lisp
#+end_src
** [x] pyenv-mode
#+begin_src emacs-lisp
(with-package pyenv-mode
              (setq python-shell-interpreter "ipython"
                    python-shell-interpreter-args "-i --simple-prompt"))
#+end_src
** [x] pyvenv
#+begin_src emacs-lisp
(with-package pyvenv
              (setenv "WORKON_HOME" (expand-file-name "~/miniconda3/envs"))
              (setq pyvenv-menu t))
(with-hook pyvenv-post-activate-hooks
           (pyvenv-restart-python))
(with-hook python-mode
           (pyvenv-mode +1))
#+end_src
** [x] qrencode
#+begin_src emacs-lisp
#+end_src
** [x] recentf 
#+begin_src emacs-lisp
#+end_src
** [x] refine
#+begin_src emacs-lisp
#+end_src
** [x] request        
#+begin_src emacs-lisp
#+end_src
** [x] rjsx-mode
#+begin_src emacs-lisp
     (with-package rjsx-mode
                   (setq js2-mode-show-parse-errors nil
                         js2-mode-show-strict-warnings nil
                         js2-basic-offset 2
                         js-indent-level 2)
                   (setq-local flycheck-disabled-checkers (cl-union flycheck-disabled-checkers
                                                                    '(javascript-jshint))) ; jshint doesn't work for JSX
                   (electric-pair-mode 1))
     (with-hook after-init
                (add-to-list 'auto-mode-alist '("\\.js\\'" . rjsx-mode))
                (add-to-list 'auto-mode-alist '("\\.jsx\\'" . rjsx-mode)))
#+end_src
** [x] rustic
#+begin_src emacs-lisp
#+end_src
** [x] s
#+begin_src emacs-lisp
#+end_src
** [x] simple-httpd
#+begin_src emacs-lisp
#+end_src
** [x] sly
#+begin_src emacs-lisp
(with-package sly
              (setq inferior-lisp-program "/usr/bin/sbcl")
              (defkeys sly-prefix-map
                "M-h" sly-documentation-lookup))
#+end_src
** [x] sly-asdf
#+begin_src emacs-lisp

#+end_src
** [x] sly-macrostep
#+begin_src emacs-lisp
#+end_src
** [x] sly-named-readtables
#+begin_src emacs-lisp
#+end_src
** [x] sly-quicklisp
#+begin_src emacs-lisp

#+end_src
** [x] smart-jump        
#+begin_src emacs-lisp
#+end_src
** [x] smex        
#+begin_src emacs-lisp
#+end_src
** [x] smooth-scrolling
#+begin_src emacs-lisp
#+end_src
** [x] solarized-theme        
#+begin_src emacs-lisp
     (with-package
      solarized
      (load-theme 'solarized-dark t))
#+end_src
** [x] sphinx-doc        
#+begin_src emacs-lisp
#+end_src
** [x] string-edit        
#+begin_src emacs-lisp
#+end_src
** [x] system-packages
#+begin_src emacs-lisp
#+end_src
** [x] tide        
#+begin_src emacs-lisp
#+end_src
** [x] treemacs
#+begin_src emacs-lisp
(with-package treemacs
              (setq treemacs-no-png-images t
                    treemacs-width 24))
(with-hook python-mode
           (defkeys python-mode-map
             "C-f t" treemacs))
#+end_src
** [x] vertico
#+begin_src emacs-lisp

#+end_src
** [x] visual-ascii-mode
#+begin_src emacs-lisp
#+end_src
** [x] wgrep
#+begin_src emacs-lisp

#+end_src
** [x] which-key        
#+begin_src emacs-lisp
(with-hook which-key
           (diminish 'which-key-mode))
(with-hook after-init
           (which-key-setup-minibuffer)
           (which-key-mode))
#+end_src
** [x] winum
#+begin_src emacs-lisp
#+end_src
** [x] with-simulated-input
#+begin_src emacs-lisp
#+end_src
** [x] wrap-region        
#+begin_src emacs-lisp
     (with-hook after-init
                (wrap-region-global-mode t)
                (diminish 'wrap-region-mode))
#+end_src
** [x] yapfify
#+begin_src emacs-lisp
     (with-hook python-mode
                (yapf-mode +1))
#+end_src
** [x] yasnippet
#+begin_src emacs-lisp
(when-idle (require 'yasnippet))
(with-package yasnippet
              (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
              (setq yas-key-syntaxes '("w_" "w_." "^ ")
                    ;; yas-snippet-dirs (eval-when-compile
                    ;;                  (list (expand-file-name "~/.emacs.d/snippets")))
                    yas-expand-only-for-last-commands nil)
              (defkeys yas-minor-mode-map
                       "C-i" nil
                       "TAB" nil
                       "C-<tab>" yas-expand))
(with-hook yas-minor-mode
           (diminish 'yas-mode 'yas-minor-mode))
#+end_src
** [x] yasnippet-snippets
#+begin_src emacs-lisp
#+end_src
   
** [ none  ] [x] abbrev
#+begin_src emacs-lisp
(with-package abbrev
              (diminish 'abbrev-mode))
#+end_src
** [ none  ] [x] c/c++
#+begin_src emacs-lisp
  (with-hook after-init
             (add-hook 'c-initialization-hook 'my-c-init)
             (add-hook 'c++-mode-hook 'my-c++-init)
             (add-to-list 'auto-mode-alist '("\\.\\(c\\|h\\|inc\\|src\\)\\'" . c-mode))
             (add-to-list 'auto-mode-alist '("\\.\\(|hh\\|cc\\|c++\\|cpp\\|tpp\\|hpp\\|hxx\\|cxx\\|inl\\|cu\\)'" . c++-mode))
             (when-idle  (require 'c++-setup)))
#+end_src
** [ none  ] [x] dap-java
#+begin_src emacs-lisp
#+end_src

** [ none  ] [x] dired
#+begin_src emacs-lisp
(with-hook after-init
           (defkeys global-map
                    "C-x C-j"   dired-jump
                    "C-x 4 C-j" dired-jump-other-window)
           (when-idle (require 'dired)))
(with-package dired
              (require 'dired-setup)
              
              (with-system windows-nt
                           (setq ls-lisp-use-insert-directory-program "gls"))
              
              (with-system gnu/linux
                           (dolist (ext (list (list (openwith-make-extension-regexp
                                                     '("xbm" "pbm" "pgm" "ppm" "pnm"
                                                       "png" "gif" "bmp" "tif" "jpeg" "jpg"))
                                                    "feh"
                                                    '(file))
                                              (list (openwith-make-extension-regexp
                                                     '("doc" "xls" "ppt" "odt" "ods" "odg" "odp" "rtf"))
                                                    "libreoffice"
                                                    '(file))
                                              (list (openwith-make-extension-regexp
                                                     '("\\.lyx"))
                                                    "lyx"
                                                    '(file))
                                              (list (openwith-make-extension-regexp
                                                     '("chm"))
                                                    "kchmviewer"
                                                    '(file))
                                              (list (openwith-make-extension-regexp
                                                     '("pdf" "ps" "ps.gz" "dvi" "epub" "djv" "djvu" "mobi" "azw3"))
                                                    "okular"
                                                    '(file))))
                             (add-to-list 'openwith-associations ext)))
              (defkeys dired-mode-map
                       "C-x <M-S-return>" dired-open-current-as-sudo
                       "r"                dired-do-rename
                       "C-S-r"            wdired-change-to-wdired-mode
                       "C-r C-s"          tmtxt/dired-async-get-files-size
                       "C-r C-r"          tda/rsync
                       "C-r C-z"          tda/zip
                       "C-r C-u"          tda/unzip
                       "C-r C-a"          tda/rsync-multiple-mark-file
                       "C-r C-e"          tda/rsync-multiple-empty-list
                       "C-r C-d"          tda/rsync-multiple-remove-item
                       "C-r C-v"          tda/rsync-multiple
                       "C-r C-s"          tda/get-files-size
                       "C-r C-q"          tda/download-to-current-dir
                       "S-<return>"       dired-openwith
                       "C-'"              dired-collapse-mode
                       "n"                scroll-up-line
                       "p"                scroll-down-line
                       "M-m"              dired-mark-backward
                       "M-<"              dired-goto-first
                       "M->"              dired-goto-last
                       "M-<return>"       my-run
                       "C-S-f"            dired-narrow
                       "P"                peep-dired
                       "<f1>"             term-toggle
                       "TAB"              dired-subtree-toggle
                       "f"                dired-subtree-fold-all
                       "z"                dired-get-size
                       "e"                dired-subtree-expand-all))

(with-hook dired-omit-mode (diminish 'dired-omit-mode))
(with-hook dired-mode
           (dired-omit-mode)
           (dired-async-mode)
           (dired-hide-details-mode)
           ;;(dired-git-log-mode)
           (dired-auto-readme-mode))
#+end_src
** [ none  ] [x] early-init
#+begin_src emacs-lisp
    (with-hook early-init
               (defvar default-gc-cons-threshold gc-cons-threshold)
               (defvar old-file-name-handler file-name-handler-alist)
               (setq file-name-handler-alist nil
                     debug-on-error t
                     gc-cons-threshold most-positive-fixnum
                     frame-inhibit-implied-resize t
                     bidi-inhibit-bpa t
                     initial-scratch-message ""
                     inhibit-splash-screen t
                     inhibit-startup-screen t
                     inhibit-startup-message t
                     inhibit-startup-echo-area-message t
                     show-paren-delay 0
                     use-dialog-box nil
                     visible-bell nil
                     ring-bell-function 'ignore
                     load-prefer-newer t
                     shell-command-default-error-buffer "Shell Command Errors"
                     native-comp-async-report-warnings-errors 'silent
                     comp-speed 3)
               (when 'native-comp-compiler-options
                 (setq native-comp-async-jobs-number 4))
               
               (setq-default abbrev-mode t
                             indent-tabs-mode nil
                             indicate-empty-lines t
                             cursor-type 'bar
                             fill-column 80
                             auto-fill-function 'do-auto-fill
                             cursor-in-non-selected-windows 'hollow
                             bidi-display-reordering 'left-to-right
                             bidi-paragraph-direction 'left-to-right)
               (push '(fullscreen . maximized) initial-frame-alist)
               (push '(fullscreen . maximized) default-frame-alist)
               (push '(menu-bar-lines . 0) default-frame-alist)
               (push '(tool-bar-lines . 0) default-frame-alist)
               (push '(vertical-scroll-bars . nil) default-frame-alist)
               (push '(font . "Anonymous Pro-16") default-frame-alist)
               (custom-set-faces '(default ((t (:height 120)))))
               ;; (let ((default-directory  (expand-file-name "lisp" user-emacs-directory)))
               ;;   (normal-top-level-add-to-load-path '("."))
               ;;   (normal-top-level-add-subdirs-to-load-path))
               ;; (let ((deff (gethash 'default face--new-frame-defaults)))
               ;;   (aset (cdr deff) 4 440)
               ;;   (puthash 'default deff face--new-frame-defaults))
               (define-prefix-command 'C-z-map)
               (global-set-key (kbd "C-z") 'C-z-map)
               (global-unset-key (kbd "C-v"))
               ;; define a setc function for use in init file
               (defalias 'setc 'customize-set-variables)
               (put 'setc 'byte-optimizer 'byte-compile-inline-expand))
#+end_src
** [ none  ] [x] edebug
#+begin_src emacs-lisp
(with-package edebug (require 'edebug-x))
#+end_src
** [ none  ] [x] emacs
#+begin_src emacs-lisp
  (with-hook text-mode (setq fill-column 80))
  (with-hook abbrev-mode (diminish 'abbrev-mode))
  (with-hook auto-complete-mode (diminish 'auto-complete-mode))
  (with-hook auto-fill-mode (diminish 'auto-fill-function))
  (with-hook auto-insert-mode (diminish 'auto-insert-mode))
  (with-hook edit-abbrevs-mode (diminish 'abbrev-mode))
  (with-hook eldoc-mode (diminish 'eldoc-mode))
  (with-hook electric-pair-mode (diminish 'electric-pair-mode))
  (with-hook subword-mode (diminish 'subword-mode))
  (with-hook wrap-region-mode (diminish 'wrap-region-mode))
  (with-hook winner-mode (diminish 'winner-mode))
  (with-hook
   after-init
   (with-system windows-nt
		;; (global-disable-mouse-mode 1)
		(when (equal system-name "HP-Laptop")
		  (setq package-gnupghome-dir "/c/Users/HP/.emacs.d/elpa/gnupg"))
		(setq w32-get-true-file-attributes nil
		      w32-pipe-read-delay 0
		      w32-pipe-buffer-size (* 64 1024)
		      ;;package-gnupghome-dir "c:/Users/arthu/.emacs.d/elpa/gnupg"
		      source-directory "c:/emacs/emsrc/emacs"
		      command-line-x-option-alist nil
		      command-line-ns-option-alist nil
		      browse-url-galeon-program (getenv "BROWSER")
		      browse-url-netscape-program browse-url-galeon-program))
 
   (let ((etc (expand-file-name "etc" user-emacs-directory)))
     (setq show-paren-style 'expression
	   message-log-max 10000 ;; oriignal 1000
	   undo-outer-limit 37000000
	   shell-file-name "bash"
	   shell-command-switch "-ic"
	   delete-exited-processes t
	   echo-keystrokes 0.1
	   create-lock-files nil
	   winner-dont-bind-my-keys t
	   auto-windo-vscroll nil
	   split-width-threshold 0
	   split-height-threshold nil
	   require-final-newline t
	   next-line-add-newlines t
	   bookmark-save-flag 1
	   delete-selection-mode t
	   initial-major-mode 'emacs-lisp-mode
	   confirm-kill-processes nil
	   help-enable-symbol-autoload t
	   large-file-warning-threshold nil
	   save-abbrevs 'silent
	   save-interprogram-paste-before-kill t
	   save-place-file (expand-file-name "places" etc)
	   max-lisp-eval-depth '100000
	   max-specpdl-size '1000000
	   scroll-preserve-screen-position 'always
	   scroll-conservatively 1
	   maximum-scroll-margin 1
	   mouse-autoselect-window t
	   scroll-margin 0
	   make-backup-files nil
	   kill-buffer-delete-auto-save-files t
	   backup-directory-alist `(("." . ,etc))
	   custom-file (expand-file-name "custom.el" etc)
	   abbrev-file-name (expand-file-name "abbrevs.el" etc)
	   bookmark-default-file (expand-file-name "bookmarks" etc)))
 
   (push '("\\*Compile-Log\\*" (display-buffer-no-window)) display-buffer-alist)
   (push `((,(rx bos (or "*Apropos*" "*Help*" "*helpful*" "*info*" "*Summary*")
		 (0+ not-newline))
	    (display-buffer-same-window
	     display-buffer-reuse-mode-window
	     display-buffer-pop-up-window)
	    (mode apropos-mode help-mode helpful-mode Info-mode Man-mode)))
	 display-buffer-alist)
   (push '(("*Help*" (window-parameters . ((dedicated . t))))) display-buffer-alist)
   (push "/home/arthur/repos/ready-lisp/doc/info" Info-directory-list)
   (push "/home/arthur/repos/common-lisp-info" Info-directory-list)
  
   (fset 'yes-or-no-p 'y-or-n-p)
   (electric-indent-mode 1)
   (electric-pair-mode 1)
   (global-auto-revert-mode)
   (global-hl-line-mode 1)
   (global-subword-mode 1)
   (auto-compression-mode 1)
   (auto-image-file-mode)
   (auto-insert-mode 1)
   (auto-save-visited-mode 1)
   (blink-cursor-mode 1)
   (column-number-mode 1)
   (delete-selection-mode 1)
   (display-time-mode t)
   (pending-delete-mode 1)
   (show-paren-mode t)
   (save-place-mode 1)
   (winner-mode t)
   (turn-on-auto-fill)
   (pixel-scroll-precision-mode +1)
 
   (defkeys global-map
	    "C-<insert>"    term-toggle-term
	    "<insert>"      term-toggle-eshell
	    "C-v C-t"       term-toggle-ielm
	    [f9]            ispell-word
	    [S-f10]         next-buffer
	    [C-enter]       other-window
	    [M-S-f10]       next-buffer-other-window
	    [f8]            last-buffer
	    [f10]           previous-buffer
	    [M-f10]         previous-buffer-other-window
	    [M-f12]         kill-buffer-other-window
	    [f12]           kill-buffer-but-not-some
	    [C-M-f12]       only-current-buffer
	    [C-return]      other-window
	    "C-;"           do-in-other-window
	    "C-M-:"         do-to-this-in-other-window
	    "C-:"           do-to-this-and-stay-in-other-window
	    ;; Emacs windows
	    "C-v <left>"   windmove-swap-states-left
	    "C-v <right>"  windmove-swap-states-right
	    "C-v <up>"     windmove-swap-states-up
	    "C-v <down>"   windmove-swap-states-down
	    "C-v o"        other-window
	    "C-v j"        windmove-left
	    "C-v l"        windmove-right
	    "C-v i"        windmove-up
	    "C-v k"        windmove-down
	    "C-v a"        send-to-window-left
	    "C-v d"        send-to-window-right
	    "C-v w"        send-to-window-up
	    "C-v s"        send-to-window-down
	    ;; "C-v v"        maximize-window-vertically
	    ;; "C-v h"        maximize-window-horizontally
	    "C-v n"        next-buffer
	    "C-v p"        previous-buffer
	    "C-v +"        text-scale-increase
	    "C-v -"        text-scale-decrease
	    "C-v C-+"      enlarge-window-horizontally
	    "C-v C-,"      enlarge-window-vertically
	    "C-v C--"      shrink-window-horizontally
	    "C-v C-."      shrink-window-vertically
	    "C-v u"        winner-undo
	    "C-v r"        winner-redo
	    "C-v C-k"      delete-window
	    "C-v C-l"      windmove-delete-left
	    "C-v C-r"      windmove-delete-right
	    "C-v C-a"      windmove-delete-up
	    "C-v C-b"      windmove-delete-down
	    "C-v <return>" delete-other-windows
	    "C-v ,"        split-window-right
	    "C-v ."        split-window-below
	    ;;"C-h M-i"      help-toggle-source-view
	    ;; "C-v C-s"      swap-two-buffers
	    [remap other-window]  ace-window
	    [remap find-file-other-window]  ff-other-window          
	    ;; cursor movement
	    "M-n"     scroll-up-line
	    "M-N"     scroll-up-command
	    "M-p"     scroll-down-line
	    "M-P"     scroll-down-command
	    "C-v c"   org-capture
	    "C-v C-c" avy-goto-char
	    "C-v C-v" avy-goto-word-1
	    "C-v C-w" avy-goto-word-0
	    "C-v C-g" avy-goto-line
	    ;; some random stuff
	    "C-h C-i" (lambda() 
			(interactive)
			(find-file (expand-file-name
				    "init.org"
				    user-emacs-directory))))
 
   (when-idle (require 'cape))
   (when-idle (require 'extras))
   (when-idle (require 'sv-kalender)
	      ;;(add-to-list 'special-display-frame-alist '(tool-bar-lines . 0))
	      (when (and custom-file (file-exists-p custom-file))
		(load custom-file 'noerror))
	      (add-hook 'comint-output-filter-functions
			#'comint-watch-for-password-prompt))
 
   (require 'solarized-theme)
   (setq gc-cons-threshold       default-gc-cons-threshold
	 ;;gc-cons-percentage      0.1
	 file-name-handler-alist old-file-name-handler))
#+end_src
** [ none  ] [x] emacs-director
  #+GIT: https://github.com/bard/emacs-director
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] emacs-gif-screencast
  #+GIT: https://gitlab.com/ambrevar/emacs-gif-screencast
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] emacs-run-command
  #+GIT: https://github.com/bard/emacs-run-command
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] emacs-velocity
  #+GIT: https://github.com/bard/emacs-velocity
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] gnus
#+begin_src emacs-lisp
(with-hook after-init
           (require 'gnus))
(with-hook message-mode
           (setq fill-column 80))
(with-package gnus
              
              (require 'nnir)
              (setq user-full-name    "Arthur Miller"
                    user-mail-address "arthur.miller@live.com")
              
              ;; for the outlook
              (setq gnus-select-method '(nnimap "live.com"
                                                (nnimap-address "imap-mail.outlook.com")
                                                (nnimap-server-port 993)
                                                (nnimap-stream ssl)
                                                (nnir-search-engine imap)
                                                ))
              
              ;; Send email through SMTP
              (setq message-send-mail-function 'smtpmail-send-it
                    smtpmail-default-smtp-server "smtp-mail.outlook.com"
                    smtpmail-smtp-service 587
                    smtpmail-local-domain "homepc")
              (setq gnus-thread-sort-functions
                    '(gnus-thread-sort-by-most-recent-date
                      (not gnus-thread-sort-by-number)))
              (setq gnus-use-cache t gnus-view-pseudo-asynchronously t)
              ;; Show more MIME-stuff:
              (setq gnus-mime-display-multipart-related-as-mixed t)
              ;; http://www.gnu.org/software/emacs/manual/html_node/gnus/_005b9_002e2_005d.html
              (setq gnus-use-correct-string-widths nil)
              ;;(setq nnmail-expiry-wait 'immediate)
              ;; set renderer for html mail to w3m in emacs
              ;;(setq mm-text-html-renderer 'eww)
              (setq gnus-inhibit-images nil)
              ;; set gnus-parameter
              ;; (setq gnus-parameters
              ;;       '(("nnimap.*"
              ;;          (gnus-use-scoring nil)
              ;;          (expiry-wait . 2)
              ;;          (display . all))))
              
              ;;[[http://stackoverflow.com/questions/4982831/i-dont-want-to-expire-mail-in-gnus]]
              ;;(setq gnus-large-newsgroup 'nil)
              ;; Smileys:
              (setq smiley-style 'medium)
              
              ;; Use topics per default:
              (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
              (setq gnus-message-archive-group '((format-time-string "sent.%Y")))
              (setq gnus-server-alist '(("archive" nnfolder "archive" (nnfolder-directory "~/mail/archive")
                                         (nnfolder-active-file "~/mail/archive/active")
                                         (nnfolder-get-new-mail nil)
                                         (nnfolder-inhibit-expiry t))))
              
              (setq gnus-topic-topology '(("live.com" visible)))
              
              ;; each topic corresponds to a public imap folder
              (setq gnus-topic-alist '(("live.com")
                                       ("Gnus")))
              )
#+end_src
** [ none  ] [x] helm-convert
  #+GIT: https://github.com/Zacalot/helm-convert
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] ielm
#+begin_src emacs-lisp
(with-package
 ielm
 (advice-add 'ielm :around #'ielm-use-current-buffer)
 ;;(advice-add 'ielm-eval-inpu :after #'paredit-open-round)
 (defkeys ielm-map
          "\C-c a" emacs-lisp-byte-compile-and-load
          "\C-c b" emacs-lisp-byte-compile
          "\C-c c" emacs-lisp-native-compile-and-load
          "\C-c d" eval-defun
          "\C-c e" eval-buffer
          "\C-c r" eval-region
          "\C-c l" eval-last-sexp
          "\C-c n" eval-next-sexp
          "\C-c i" reindent-buffer
          "\C-c p" fc-eval-and-replace
          "\C-c s" eval-surrounding-sexp)
 (require 'paredit)
 (define-key paredit-mode-map (kbd "RET") nil)
 (define-key paredit-mode-map (kbd "C-j") 'paredit-newline))

(with-hook ielm-mode
           ;;(ielm-change-working-buffer (other-window-buffer -1))
           (paredit-mode +1)
           (turn-on-eldoc-mode))
#+end_src
** [ none  ] [x] inferior-python-mode
#+begin_src emacs-lisp
  (with-hook inferior-python-mode
             (hide-mode-line-mode))
#+end_src
** [ none  ] [x] lisp & elisp
#+begin_src emacs-lisp
(with-package
 elisp-mode
 (require 'elisp-extras)
 ;;(require 'helm-extras)
 
 (defkeys emacs-lisp-mode-map
          "\C-c a" emacs-lisp-byte-compile-and-load
          "\C-c b" emacs-lisp-byte-compile
          "\C-c c" emacs-lisp-native-compile-and-load
          "\C-c d" eval-defun
          "\C-c e" eval-buffer
          "\C-c r" eval-region
          "\C-c l" eval-last-sexp
          "\C-c n" eval-next-sexp
          "\C-c i" reindent-buffer
          "\C-c p" fc-eval-and-replace
          "\C-c s" eval-surrounding-sexp))

(with-hook
 after-init
 (set-default 'auto-mode-alist
              (append '(("\\.lisp" . lisp-mode)
                        ("\\.lsp" . lisp-mode)
                        ("\\.cl" . lisp-mode))
                      auto-mode-alist)))

(with-package
 inf-lisp
 (require 'sly)
 (require 'cl-extras))

(with-package
 lisp-mode
 (require 'sly)
 (require 'cl-extras))

(with-hook
 emacs-lisp-mode
 (elisp-hooks))

(with-hook
 inf-lisp
 (cl-hooks))

(with-hook
 lisp-mode
 (cl-hooks))
#+end_src
** [ none  ] [ ] package
#+begin_src emacs-lisp
(with-package
 package
 (let ((package-install-local-multifile-packages-symlinked t))
   (defun package-unpack (pkg-desc)
  "Install the contents of the current buffer as a package."
  (let* ((name (package-desc-name pkg-desc))
         (dirname (package-desc-full-name pkg-desc))
         (pkg-dir (expand-file-name dirname package-user-dir)))
    (pcase (package-desc-kind pkg-desc)
      ('dir
       (if package-install-local-multifile-packages-symlinked
           (make-symbolic-link (expand-file-name default-directory) pkg-dir t)
         (progn
           (make-directory pkg-dir t)
           (let ((file-list
                  (directory-files
                   default-directory 'full "\\`[^.].*\\.el\\'" 'nosort)))
             (dolist (source-file file-list)
               (let ((target-el-file
                      (expand-file-name (file-name-nondirectory source-file) pkg-dir)))
                 (copy-file source-file target-el-file t)))
             (setf (package-desc-kind pkg-desc)
                   (if (> (length file-list) 1) 'tar 'single))))))
      ('tar
       (make-directory package-user-dir t)
       (let* ((default-directory (file-name-as-directory package-user-dir)))
         (package-untar-buffer dirname)))
      ('single
       (let ((el-file (expand-file-name (format "%s.el" name) pkg-dir)))
         (make-directory pkg-dir t)
         (package--write-file-no-coding el-file)))
      (kind (error "Unknown package kind: %S" kind)))
    (package--make-autoloads-and-stuff pkg-desc pkg-dir)
    (let ((new-desc (package-load-descriptor pkg-dir)))
      (unless (equal (package-desc-full-name new-desc)
                     (package-desc-full-name pkg-desc))
        (error "The retrieved package (`%s') doesn't match what the archive offered (`%s')"
               (package-desc-full-name new-desc) (package-desc-full-name pkg-desc)))
      (when (package-activate-1 new-desc :reload :deps)
        (package--compile new-desc)
        (when package-native-compile
          (package--native-compile-async new-desc))
        (package--load-files-for-activation new-desc :reload)))
    pkg-dir)))
#+end_src
** [ none  ] [x] paredit
#+begin_src emacs-lisp
(with-package
 paredit
 (defkeys paredit-mode-map
          "C-8" paredit-backward-slurp-sexp
          "C-9" paredit-forward-slurp-sexp
          "C-7" paredit-backward-barf-sexp
          "C-0" paredit-forward-barf-sexp
          "M-8" paredit-wrap-round
          "M-9" paredit-close-round-and-newline
          "C-." paredit-forward
          "C-," paredit-backward
          ))
#+end_src
** [ none  ] [x] system-cores.el
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] term-toggle
#+begin_src emacs-lisp
(with-package term-toggle
              (setq term-toggle-no-confirm-exit t
                    term-toggle-kill-buffer-on-term-exit t))
#+end_src
** [ none  ] [x] wdired
#+begin_src emacs-lisp
(with-package wdired
              (defkeys wdired-mode-map
                "<return>"    dired-find-file
                "M-<return>"  my-run
                "S-<return>"  dired-openwith
                "M-<"         dired-go-to-first
                "M->"         dired-go-to-last
                "M-p"         scroll-down-line))
#+end_src
