* About
** Introduction

A personal setup, based on my init file generator tool.

** Licence
Copyright (C) 2020  Arthur Miller

Author: Arthur Miller <arthur.miller@live.com>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
* Generator
#+NAME: onstartup
#+begin_src emacs-lisp :results output silent
  (defvar init-file-bake-autoloads t)
  (defvar init-file-unroll-key-bindings t)

  (package-initialize)
  (package-quickstart-refresh)
  (setq package-archives nil)

  (defvar org-archive '("org" . "http://orgmode.org/elpa/"))
  (defvar gnu-archive '("gnu" . "https://elpa.gnu.org/packages/"))
  (defvar elpa-archive '("elpa" . "https://elpa.gnu.org/packages/"))
  (defvar melpa-archive '("melpa" . "https://melpa.org/packages/"))
  (defvar melpa-stable-archive '("melpa-stable" . "https://stable.melpa.org/packages/"))

  (push elpa-archive package-archives)
  (push melpa-archive package-archives)
  (push melpa-stable-archive package-archives)
  (push org-archive package-archives)
  (setq package-archives (nreverse package-archives))

  (setq init-file-bake-autoloads t)
  (defvar init-file-unroll-key-bindings t)

  (unless (boundp 'init-file-hooks)
    (make-variable-buffer-local 'init-file-hooks))
  (unless (boundp 'init-file-package-list)
    (make-variable-buffer-local 'init-file-package-list))

  (defun on-buffer-change-hook (beg eng len)
    (setq init-file-package-list nil))

  (add-hook 'after-change-functions 'on-buffer-change-hook)

  (defmacro with-hook (name &rest body)
    (let (found hook)
      (setq name (if (string-match "-hook\\'" (symbol-name `,name))
		     `,name
		   (intern (concat (symbol-name name) "-hook"))))
      (setq body (reverse body))
      (dolist (hook init-file-hooks)
	(when (equal (symbol-name (car hook)) (symbol-name name))
	  (dolist (sexp (reverse (cdr hook)))
	    (add-to-list 'body sexp))
	  (setcdr hook body)
	  (setq found t)))
      (unless found
	(add-to-list 'init-file-hooks (cons name body)))
      (ignore)))

  (defun clean-init-file ()
    (interactive)
    (with-temp-buffer
      (insert-file-contents "init.el")
      (beginning-of-buffer)
      (while (not (eobp))
	(when (char-equal (char-after) ?\^M)
	  (delete-char 1))
	(forward-char 1))
      (write-region (point-min) (point-max) "init.el")))

  (defmacro with-package (name &rest body)
    (let ((package (symbol-name name)))
      (append-to-init-file "(with-eval-after-load ")
      (append-to-init-file (concat "\"" package "\"\n"))
      (emit-to-init-file body)
      (append-to-init-file ")\n")))

  (defmacro with-key-map (mapname &rest body)
    `(let ((map (eval-and-compile (concat (symbol-name ',mapname) "-map")))
	   (defs '(,@body)))
       (dolist (def defs)
	 (define-key (symbol-value (intern map))
	   (if (vectorp (car def)) (car def)
	     (read-kbd-macro (car def))) (cdr def)))))

  (defun emit-keymap (map)
    (let ((body (cdr map))
	  (key))
      (dolist (stm `,@body)
	(if (vectorp (eval (car stm)))
	    (setq key (prin1-to-string (car stm)))
	  (setq key (concat "(kbd \"" (car stm) "\")")))
	(append-to-init-file
	 (concat "(define-key "
		 (symbol-name (car map)) "-map "
		 key " '" (prin1-to-string (cdr stm))
		 ")")))))
  (defun append-to-init-file (string-or-buffer)
    (let ((file "init.el") insert-point)
      (cond ((stringp string-or-buffer)
	     (write-region string-or-buffer nil file t 0))
	    ((bufferp string-or-buffer)
	     (with-current-buffer string-or-buffer
	       (write-region (point-min) (point-max) file t 0))))))

  (defun emit-sexp-to-init-file (sexp)
    (if init-file-unroll-key-bindings
	(if (equal (symbol-name (car sexp)) "with-key-map")
	    (emit-keymap (cdr sexp))
	  (append-to-init-file (prin1-to-string sexp)))
      (append-to-init-file (pp sexp))))

  (defun emit-to-init-file (&rest body)
    (dolist (sexp body)
      (if (listp (car sexp))
	  (dolist (s sexp)
	    (emit-sexp-to-init-file s))
	(emit-sexp-to-init-file sexp))))

  (defun emit-packages ()
    (dolist (p (get-package-list))
      (message "Emiting package: %s" (aref p 0))
      (when (package-enabled-p p)
	(eval-region (aref p 4) (aref p 5)))))

  (defun emit-hooks ()
    (message "Emiting hooks.")
    (dolist (hook init-file-hooks)
      (append-to-init-file (concat "(add-hook '"
				   (symbol-name (car hook))
				   " #'(lambda nil\n"))
      (dolist (elt (nreverse (cdr hook)))
	(emit-to-init-file elt))
      (append-to-init-file "))")))

  (defun get-load-paths()
    (let ((elpa (expand-file-name "elpa" user-emacs-directory))
	  (archives (expand-file-name "elpa/archives" user-emacs-directory)) 
	  package-paths)
      (dolist (path (directory-files elpa t directory-files-no-dot-files-regexp))
	(when (file-directory-p path)
	  (unless (string= path archives)
	    (push path package-paths))))
      package-paths))

  (defun emit-load-paths ()
    (let ((lp (get-load-paths)))
      (message "Emitting load-path")
      (append-to-init-file
       (concat "\n(nconc load-path \n'"
	       (prin1-to-string lp)
	       ")\n"))))

  (defun emit-autoloads-file ()
    (message "Emiting autoloads")
    (let ((al "autoloads.el")
	  (pp (get-load-paths))
	  (pq (expand-file-name "package-quickstart.el"
				user-emacs-directory)))
      (unless pq
	(package-quickstart-refresh))
      (with-temp-file al
	(insert-file-contents pq)
	(goto-char (point-min))
	(kill-line 3)
	(insert (concat "\n(setq load-path (append \n'"
			(prin1-to-string pp)
			" load-path))\n"))
	(while (not (eobp))
	  (when (char-equal (char-after) ?\^L)
	    (delete-char 1))
	  (forward-line 1))
	(goto-char (point-max))
	(kill-line -5)
	(goto-char (point-min))
	(while (not (eobp))
	  (when (re-search-forward "^(add-to-list" (line-end-position) t)
	    (forward-line -1)
	    (kill-line 3))
	  (beginning-of-line)
	  (forward-line 1))
	(goto-char (point-min))
	(while (not (eobp))
	  (replace-string "\n\n\n" "\n")
	  (forward-line 1)))))

  (defun tangle-early-init ()
    (message "Exporting early-init.el ...")
      (save-excursion
	(let (start end r)
	  (goto-char (point-min))
	  (re-search-forward "^\\*\\* Early init")
	  (re-search-forward "begin_src.*emacs-lisp")
	  (skip-chars-forward "\s\t\n\r")
	  (setq start (point))
	  (re-search-forward "end_src$")
	  (beginning-of-line)
	  (setq end (point))
	  (setq r (buffer-substring-no-properties start end))
	  (with-temp-file "early-init.el"
	    (insert r)
	    (goto-char (point-min))
	    (forward-line 1)
	    (insert ";; This file is machine generated by init-file generator, don't edit\n")
	    (insert ";; manually, edit instead file init.org and generate new init file from it")
	    ;; are we baking quickstart file?
	    (if init-file-bake-autoloads
	      (insert "\n(setq package-quickstart nil package-enable-at-startup nil package--init-file-ensured t)\n")))
	    (message "Wrote early-init.el"))))

  (defun tangle-init-file (&optional file)
    ;;(message "TANGLE INIT FILE")
    (unless file
      (setq file "init.el"))
    (if (file-exists-p file)
	(delete-file file))
    (if (file-exists-p (concat file "c"))
	(delete-file (concat file "c")))
    (setq init-file-hooks nil)
    (let (code-start config-start)
      (save-excursion
	(goto-char (point-min))
	(setq config-start (re-search-forward "^\\* Packages"))
	;; prolog
	(message "Emiting prolog.")  
	(goto-code-start "^\\*\\* Init")
	(setq code-start (point))
	(goto-code-end)
	(write-region code-start (point) file t 0)
	;; emit paths
	;;(emit-load-paths)
	(emit-autoloads-file)
	(if init-file-bake-autoloads
	  (with-temp-buffer
	    (insert "(defvar package-activated-list nil)")
	    (insert-file-contents-literally "autoloads.el")
	    (write-region (point-min) (point-max) "init.el" t 0))
	  (append-to-init-file "(package-activate-all)"))
	;; generate stuff
	(emit-packages)
	(emit-hooks) ;; must be done after emiting packages
	;; epilog
	(message "Emiting epilog")
	(goto-code-start "^\\* Epilog")
	(setq code-start (point))
	(goto-code-end)
	(write-region code-start (point) file t 0)))
    (clean-init-file))

  (defun goto-code-start (section)
    (goto-char (point-min))
    (re-search-forward section)
    (re-search-forward "begin_src.*emacs-lisp")
    (skip-chars-forward "\s\t\n\r"))

  (defun goto-code-end ()
    (re-search-forward "end_src")
    (beginning-of-line))

  (defun create-early-init-file ()
    (interactive)
    (let ((ei (expand-file-name "early-init.el")))
      (when (file-exists-p ei)
	(delete-file ei))
      (tangle-early-init)
      (message "Tangled early init file.")))

  (defun create-init-file ()
    (interactive)
    (message "Exporting init.el ...")
    (tangle-init-file)
    (let ((tangled-file "init.el"))
      ;; always produce elc file
      (byte-compile-file tangled-file)
      (when (featurep 'nativecomp)
	(message "Native compiled %s" (native-compile tangled-file)))
      (message "Tangled and compiled %s" tangled-file))
    (message "Done."))

  (defun generate-init-files ()
    (interactive)
    (create-init-file)
    (create-early-init-file))

  (defun install-file (file)
    (when (file-exists-p file)
      (copy-file file user-emacs-directory t)
      (message "Wrote: %s." file)))

  (defun install-init-files ()
    (interactive)
    (let ((i "init.el")
	    (ic "init.elc")
	  (ei "early-init.el")
	  (al "autoloads.el")
	  (pq (expand-file-name "package-quickstart.el" user-emacs-directory))
	  (pqc (expand-file-name "package-quickstart.elc" user-emacs-directory)))
      (install-file i)
      (install-file ei)
      (unless (file-exists-p ic)
	(byte-compile (expand-file-name el)))
      (install-file ic)
      (unless init-file-bake-autoloads
	  (byte-compile pq))
      (when init-file-bake-autoloads
	;; remove package-quickstart files from .emacs.d
	(when (file-exists-p pq)
	  (delete-file pq))
	(when (file-exists-p pqc)
	  (delete-file pqc)))))

  (defun get-package-list ()
    (when (buffer-modified-p)
      (setq init-file-package-list nil))
    (unless init-file-package-list
      (save-excursion
	(goto-char (point-min))
	(let ((bound (re-search-forward "^\\* Epilog"))
	      package packages start end)
	  (goto-char (point-min))
	  (re-search-forward "^\\* Packages")
	  (while (re-search-forward "^\\*\\* " bound t)
	    (setq package (vector nil t t "" 0 0)
		  start (point) end (line-end-position))
	    ;; package name
	    (when (re-search-forward ":" end t)
	      (setq end (point)))
	    (goto-char end)
	    (skip-chars-backward ":\s\t\r\n")
	    (aset package 0 (intern (buffer-substring-no-properties
				     start (point))))
	    (goto-char start)
	    ;; enabled?
	    (when (search-forward ":disable" (line-end-position) t)
	      (aset package 1 nil))
	    (goto-char start)
	    ;; installable?
	    (when (search-forward ":pseudo" (line-end-position) t)
	      (aset package 2 nil))
	    (goto-char start)
	    ;; pinned to repository?
	    (dolist (repo package-archives)
	      (when (re-search-forward (concat ":" (car repo)) (line-end-position) t)
		(aset package 3 (car repo))))
	    ;; code start
	    (re-search-forward "begin_src.*emacs-lisp" bound t)
	    (aset package 4 (point))
	    (re-search-forward "end_src$" bound t)
	    (beginning-of-line)
	    (aset package 5 (point))
	    (push package init-file-package-list)
	    (setq init-file-package-list (nreverse init-file-package-list))))))
    init-file-package-list)

  ;; Install packages
  (defun ensure-package (package)
    (let ((p (aref package 0)))
      (unless (package-installed-p p)
	(message "Installing package: %s" p)
	(package-install p))))

  (defun package-pseudo-p (package)
    (not (aref package 2)))

  (defun package-enabled-p (package)
    (aref package 1))

  (defun package-installable-p (package)
    (and (aref package 1) (aref package 2)))

  (defun install-packages (&optional packages)
    (interactive)
    (package-initialize)
    (package-refresh-contents)
    (unless packages
      (setq packages (get-package-list)))
    (dolist (p packages)
      (when (package-installable-p p)
	(ensure-package p))))

  (defun add-package (package)
    ""
    (interactive "sPackage name: ")
    (goto-char (point-min))
    (when (re-search-forward "^* Packages")
      (forward-line 1)
      (insert (concat "** " package
		      "\n#+begin_src emacs-lisp\n"
		      "\n#+end_src\n"))
      (forward-line -2)))

  (defun add-pseudo-package (package)
    ""
    (interactive "sPackage name: ")
    (goto-char (point-min))
    (when (re-search-forward "^* Packages")
      (forward-line 1)
      (insert (concat "** " package "\t\t:pseudo"
		      "\n#+begin_src emacs-lisp\n"
		      "\n#+end_src\n"))
      (forward-line -2)))
#+end_src
* Prolog
** Early init
#+begin_src emacs-lisp
;;; early-init.el -*- lexical-binding: t -*-

(setq gc-cons-threshold most-positive-fixnum
      frame-inhibit-implied-resize t
      bidi-inhibit-bpa t
      initial-scratch-message ""
      inhibit-splash-screen t
      inhibit-startup-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message t
      show-paren-delay 0
      use-dialog-box nil
      visible-bell nil
      ring-bell-function 'ignore
      load-prefer-newer t)

(setq-default abbrev-mode t
              indent-tabs-mode nil
              indicate-empty-lines t
              cursor-type 'bar
              fill-column 80
              auto-fill-function 'do-auto-fill
              cursor-in-non-selected-windows 'hollow
              bidi-display-reordering 'left-to-right
              bidi-paragraph-direction 'left-to-right)

(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
(push '(font . "Anonymous Pro-16") default-frame-alist)
(custom-set-faces '(default ((t (:height 140)))))

(unless (eq system-type 'darwin)
(setq command-line-ns-option-alist nil))
;;; early-init.el ends here
#+end_src

** Init
#+begin_src emacs-lisp
;;; init.el -*- lexical-binding: t; -*-
;;
;; This file is machine generated by init-file generator, don't edit
;; manually, edit instead file init.org and generate new init file from it

(defvar old-file-name-handler file-name-handler-alist)
(setq file-name-handler-alist nil)

(let ((default-directory  (expand-file-name "lisp" user-emacs-directory)))
      (normal-top-level-add-to-load-path '("."))
      (normal-top-level-add-subdirs-to-load-path))

(define-prefix-command 'C-z-map)
(global-set-key (kbd "C-z") 'C-z-map)
(define-prefix-command 'C-f-map)
(global-set-key (kbd "C-f") 'C-f-map)
(global-unset-key (kbd "C-v"))
#+end_src
* Packages
** async
#+begin_src emacs-lisp
(with-package async
              (autoload 'dired-async-mode "dired-async.el" nil t)
              (async-bytecomp-package-mode 1)
              (diminish 'async-dired-mode))
#+end_src
** auto-package-update
#+begin_src emacs-lisp
(with-hook auto-package-update-after
           (message "Refresh autoloads")
           (package-quickstart-refresh))

(with-package auto-package-update
              (setq auto-package-update-delete-old-versions t
                    auto-package-update-interval nil))
#+end_src
** beacon
#+begin_src emacs-lisp
(with-hook after-init
           (beacon-mode t))
#+end_src
** company
#+begin_src emacs-lisp
(with-package company 
  (require 'company-capf)
  (require 'company-files)
  (setq company-idle-delay            0
        company-require-match         nil
        company-minimum-prefix-length 2
        company-show-numbers          t
        company-tooltip-limit         20
        company-async-timeout         6
        company-dabbrev-downcase      nil
        tab-always-indent 'complete
        company-global-modes '(not term-mode)
        company-backends (delete 'company-semantic company-backends))
        (define-key company-mode-map [remap indent-for-tab-command]
        'company-indent-or-complete-common)
        (add-to-list 'company-backends 'company-cmake)
        (add-to-list 'company-backends 'company-capf)
        (add-to-list 'company-backends 'company-files)
  (add-hook 'emacs-lisp-mode-hook 'company-mode))

(with-hook company-mode
  (diminish 'company-mode)
  (with-key-map company-active-map
    ("C-n" . company-select-next)
    ("C-p" . company-select-previous)))

(with-hook emacs-lisp-mode
  (setq fill-column 80)
  (define-key emacs-lisp-mode-map (kbd "\C-c r") 'fc-eval-and-replace)
  (define-key emacs-lisp-mode-map (kbd "\C-c s") 'eval-surrounding-sexp)
  (define-key emacs-lisp-mode-map (kbd "\C-c l") 'eval-last-sexp)
  (define-key emacs-lisp-mode-map (kbd "\C-c n") 'eval-next-sexp)
  (define-key emacs-lisp-mode-map (kbd "\C-c d") 'eval-defun))
#+end_src
** company-c-headers
#+begin_src emacs-lisp
(with-hook company-mode
  (add-to-list 'company-backends 'company-c-headers))
(with-hook company-c-headers-mode
  (diminish 'company-c-headers-mode))
#+end_src
** company-lsp
#+begin_src emacs-lisp
(with-package company-lsp
  (push 'company-lsp company-backends)
  (setq company-transformers nil
        company-lsp-async t
        company-lsp-cache-candidates nil))

(with-hook company-lsp-mode
  (diminish 'company-lsp-mode))
#+end_src
** company-math
#+begin_src emacs-lisp
(with-hook company-mode
  (diminish 'company-math-mode)
  (add-to-list 'company-backends 'company-math-symbols-latex)
  (add-to-list 'company-backends 'company-math-symbols-unicode))
#+end_src
** company-quickhelp
#+begin_src emacs-lisp
(with-hook company-mode
  (add-hook 'global-company-mode-hook 'company-quickhelp-mode))
(with-hook company-quickhelp-mode
  (diminish 'company-quickhelp-mode))
#+end_src
** c++                                                                    :pseudo
#+begin_src emacs-lisp
(with-hook c-initialization-hook
  (require 'c++-setup))

(with-hook after-init
  (add-to-list 'auto-mode-alist '("\\.c\\'" . c-mode))
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c-mode))
  (setq auto-mode-alist (append
              (list '("\\.\\(|hh\\|cc\\|c++\\|cpp\\|tpp\\|hpp\\|hxx\\|cxx\\|inl\\|cu\\)$" . c++-mode)) 
              auto-mode-alist)))
#+end_src
** diminish
#+begin_src emacs-lisp

#+end_src
** dired-hacks-utils
#+begin_src emacs-lisp

#+end_src
** dired                                                                   :pseudo
#+begin_src emacs-lisp
   (with-hook dired-mode
           (require 'dired-setup)

           (autoload 'dired-subtree-toggle "dired-subtree.el" nil t)
           (autoload 'dired-openwith "openwith.el" nil t)

           (with-key-map dired-mode
                         ("C-x <M-S-return>" . dired-open-current-as-sudo)                    
                         ("r"                . dired-do-rename)
                         ("C-S-r"            . wdired-change-to-wdired-mode)
                         ;; ("C-r C-s"          . tmtxt/dired-async-get-files-size)
                         ;; ("C-r C-r"          . tda/rsync)
                         ;; ("C-r C-z"          . tda/zip)
                         ;; ("C-r C-u"          . tda/unzip)
                         ;; ("C-r C-a"          . tda/rsync-multiple-mark-file)
                         ;; ("C-r C-e"          . tda/rsync-multiple-empty-list)
                         ;; ("C-r C-d"          . tda/rsync-multiple-remove-item)
                         ;; ("C-r C-v"          . tda/rsync-multiple)
                         ;; ("C-r C-s"          . tda/get-files-size)
                         ;; ("C-r C-q"          . tda/download-to-current-dir)
                         ("S-<return>"       . dired-openwith)
                         ("C-'"              . dired-collapse-mode)
                         ("M-p"              . scroll-down-line)
                         ("M-m"              . dired-mark-backward)
                         ("M-<"              . dired-go-to-first)
                         ("M->"              . dired-go-to-last)
                         ("M-<return>"       . my-run)
                         ("C-S-f"            . dired-narrow)
                         ("P"                . peep-dired)
                         ("<f1>"             . term-toggle)
                         ("TAB"              . dired-subtree-toggle))
           
           (with-key-map wdired-mode
                         ("<return>"        . dired-find-file)
                         ("M-<return>"      . my-run)
                         ("S-<return>"      . dired-openwith)
                         ("M-<"             . dired-go-to-first)
                         ("M->"             . dired-go-to-last)
                         ("M-p"             . scroll-down-line))

           (dired-async-mode)
           (dired-omit-mode)
           (dired-hide-details-mode))
#+end_src
** dired-subtree
#+begin_src emacs-lisp
  (with-package dired-subtree
                (setq dired-subtree-line-prefix "    "
                      dired-subtree-use-backgrounds nil))

  (with-hook dired-subtree
             ;; fixes the case of the first line in dired when the cursor jumps 
             ;; to the header in dired rather then to the first file in buffer
             (defun dired-subtree-toggle ()
               "Insert subtree at point or remove it if it was not present."
               (interactive)
               (when (dired-subtree--is-expanded-p)
                 (dired-next-line 1)
                 (dired-subtree-remove)
                 (when (bobp)
                   (dired-next-line 1))
                 (save-excursion (dired-subtree-insert)))))
#+end_src
** emacs                                                                 :pseudo
#+begin_src emacs-lisp
  (with-hook after-init
             (autoload 'term-toggle "term-toggle.el" nil t)
             (autoload 'term-toggle-eshell "term-toggle.el" nil t)
             (autoload 'only-current-buffer "extras.el" nil t)
             (autoload 'toggle-letter-case "extras.el" nil t)
             (autoload 'undo-kill-buffer "extras.el" nil t)
             (autoload 'enlarge-window-vertically "extras.el" nil t)
             (autoload 'enlarge-window-horizontally "extras.el" nil t)
             (autoload 'kill-window-left "extras.el" nil t)
             (autoload 'kill-window-right "extras.el" nil t)
             (autoload 'kill-window-above "extras.el" nil t)
             (autoload 'kill-window-below "extras.el" nil t)
             (autoload 'sudo-find-file "extras.el" nil t)
             (autoload 'kill-buffer-other-window "extras.el" nil t)
             (autoload 'kill-buffer-but-not-some "extras.el" nil t)
             (autoload 'helm-emms "helm-emms" nil t)

             ;;(unless (getenv "BROWSER")
             (setenv "BROWSER" "firefox-developer-edition")
             ;;)

             (let ((etc (expand-file-name "etc" user-emacs-directory)))
               (unless (file-directory-p etc)
                 (make-directory etc))
               (setq show-paren-style 'expression
                     shell-file-name "bash"
                     shell-command-switch "-c"
                     delete-exited-processes t
                     echo-keystrokes 0.1
                     winner-dont-bind-my-keys t
                     auto-window-vscroll nil
                     require-final-newline t
                     next-line-add-newlines t
                     bookmark-save-flag 1
                     delete-selection-mode t
                     conform-kill-processes nil
                     save-abbrevs 'silent
                     save-interprogram-paste-before-kill t
                     save-place-file (expand-file-name "places" etc)

                     ;; scroll-preserve-screen-position t
                     ;; scroll-conservatively 1
                     ;; maximum-scroll-margin 1
                     ;; scroll-margin 99999

                     backup-directory-alist `(("." . ,etc))
                     custom-file (expand-file-name "emacs-custom.el" etc)
                     abbrev-file-name (expand-file-name "abbrevs.el" etc)
                     bookmark-default-file (expand-file-name "bookmarks" etc)))

             ;; (add-to-list 'special-display-frame-alist '(tool-bar-lines . 0))
             ;;(load custom-file 'noerror)

             (fset 'yes-or-no-p 'y-or-n-p)

             (electric-indent-mode 1)
             (electric-pair-mode 1)
             (global-auto-revert-mode)
             (global-hl-line-mode 1)
             (global-subword-mode 1)
             (auto-compression-mode 1)
             (auto-image-file-mode)
             (auto-insert-mode 1)
             (auto-save-mode 1)
             (blink-cursor-mode 1)
             (column-number-mode 1)
             (delete-selection-mode 1)
             (display-time-mode 1)
             (pending-delete-mode 1)
             (save-place-mode 1)
             (show-paren-mode t)
             (winner-mode t)
             (turn-on-auto-fill)

             (diminish 'winner-mode)
             (diminish 'eldoc-mode)
             (diminish 'electric-pair-mode)
             (diminish 'auto-complete-mode)
             (diminish 'abbrev-mode)
             (diminish 'auto-fill-function)
             (diminish 'subword-mode)
             (diminish 'auto-insert-mode)

             (add-hook 'comint-output-filter-functions
                       'comint-watch-for-password-prompt)

             (with-key-map global
                           ;; Window-buffer operations
                           ([f1]      . term-toggle)
                           ([f2]      . term-toggle-eshell)
                           ([f9]      . ispell-word)
                           ([S-f10]   . next-buffer)
                           ([f10]     . previous-buffer)
                           ([f12]     . kill-buffer-but-not-some)
                           ([M-f12]   . kill-buffer-other-window)
                           ([C-M-f12] . only-current-buffer)

                           ;; Emacs windows
                           ("C-v <left>"   . windmove-left)
                           ("C-v <right>"  . windmove-right)
                           ("C-v <up>"     . windmove-up)
                           ("C-v <down>"   . windmove-down)
                           ("C-v o"        . other-window)
                           ("C-v s"        . z-swap-windows)
                           ("C-v l"        . windmove-left)
                           ("C-v r"        . windmove-right)
                           ("C-v u"        . windmove-up)
                           ("C-v d"        . windmove-down)
                           ("C-v C-+"      . enlarge-window-horizontally)
                           ("C-v C-,"      . enlarge-window-vertically)
                           ("C-v C--"      . shrink-window-horizontally)
                           ("C-v C-."      . shrink-window-vertically)
                           ("C-v -"        . winner-undo)
                           ("C-v +"        . winner-redo)
                           ("C-v C-k"      . delete-window)
                           ("C-v C-l"      . kill-window-left)
                           ("C-v C-r"      . kill-window-right)
                           ("C-v C-a"      . kill-window-above)
                           ("C-v C-b"      . kill-window-below)
                           ("C-v <return>" . delete-other-windows)
                           ("C-v ,"        . split-window-right)
                           ("C-v ."        . split-window-below)

                           ;; cursor movement
                           ("M-n"     . scroll-up-line)
                           ("M-N"     . scroll-up-command)
                           ("M-p"     . scroll-down-line)
                           ("M-P"     . scroll-down-command)
                           ("C-f n"   . next-buffer)
                           ("C-f p"   . previous-buffer)
                           ("C-f C-c" . org-capture)

                           ;; emms
                           ("C-v e SPC"   . emms-pause)
                           ("C-v e d"     . emms-play-directory)
                           ("C-v e l"     . emms-play-list)
                           ("C-v e n"     . emms-next)
                           ("C-v e p"     . emms-previous)
                           ("C-v e a"     . emms-add-directory)
                           ("C-v e A"     . emms-add-directory-tree)
                           ("C-v e +"     . emms-volume-raise)
                           ("C-v e -"     . emms-volume-lower)
                           ("C-v e +"     . emms-volume-mode-plus)
                           ("C-v e -"     . emms-volume-mode-minus)
                           ("C-v e r"     . emms-start)
                           ("C-v e s"     . emms-stop)
                           ("C-v e m"     . emms-play-m3u-playlist)

                           ;; some random stuff
                           ("C-f f"     . right-char)
                           ("C-x C-j"   . dired-jump)
                           ("C-x 4 C-j" . dired-jump-other-window)
                           ("C-f i"     . (lambda() 
                                            (interactive)
                                            (find-file (expand-file-name
                                                        "init.org" user-emacs-directory))))))
#+end_src
** emms
#+begin_src emacs-lisp
(with-package emms
    (require 'emms-setup)
    (emms-all)
    (emms-history-load)
    (emms-default-players)
    (require 'emms-player-mpv)
    (defun emms-mode-line-icon-function ()
      (concat " "
              emms-mode-line-icon-before-format
              (propertize "NP:" display emms-mode-line-icon-image-cache)
              (format emms-mode-line-format (emms-track-get
                                             (emms-playlist-current-selected-track)
                                             info-title))))
    
    (setq emms-directory "~/.emacs.d/etc/emms/"
          emms-playlist-buffer-name "*Music Playlist*"
          emms-show-format "Playing: %s"
          ;; Icon setup.
          emms-mode-line-icon-before-format "["
          emms-mode-line-format " %s]"
          emms-playing-time-display-format "%s ]"
          emms-mode-line-icon-color "lightgrey"
          global-mode-string '("" emms-mode-line-string " " emms-playing-time-string)
          ;;emms-player-list (list emms-player-mpv)
          emms-source-file-default-directory (expand-file-name "~/Musik")
          emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find
          emms-browser-covers 'emms-browser-cache-thumbnail)

    (add-to-list 'emms-player-list 'emms-player-mpv)
    (add-to-list 'emms-player-mpv-parameters "--no-audio-display")
    (add-to-list 'emms-info-functions 'emms-info-cueinfo)
    
    (when (executable-find "emms-print-metadata")
      (require 'emms-info-libtag)
      (add-to-list 'emms-info-functions 'emms-info-libtag)
      (delete 'emms-info-ogginfo emms-info-functions)
      (delete 'emms-info-mp3info emms-info-functions)
      (add-to-list 'emms-info-functions 'emms-info-ogginfo)
      (add-to-list 'emms-info-functions 'emms-info-mp3info))

    (add-hook 'emms-browser-tracks-added-hook 'z-emms-play-on-add)
    ;; Show the current track each time EMMS
    (add-hook 'emms-player-started-hook 'emms-show))
#+end_src
** esup
#+begin_src emacs-lisp

#+end_src
** expand-region
#+begin_src emacs-lisp
(with-hook expand-region-mode
           (diminish 'expand-region-mode))
#+end_src
** flycheck
#+begin_src emacs-lisp

#+end_src
** gnus                                                                    :pseudo
#+begin_src emacs-lisp
(with-hook after-init

           ;;(require 'nnreddit)

           (setq user-mail-address "your email here"
                 user-full-name    "your name here")
           ;; for the outlook
           (setq gnus-select-method '(nnimap "live.com"
                                             (nnimap-address "imap-mail.outlook.com")
                                             (nnimap-server-port 993)
                                             (nnimap-stream ssl)
                                             (nnir-search-engine imap)))

           ;; Send email through SMTP
           (setq message-send-mail-function 'smtpmail-send-it
                 smtpmail-default-smtp-server "smtp-mail.outlook.com"
                 smtpmail-smtp-service 587
                 smtpmail-local-domain "homepc")
           )

;;(setq auth-source-debug t)
;;(setq auth-source-do-cache nil)
(with-hook gnus-mode
           (require 'nnir)

           (setq gnus-thread-sort-functions
                 '(gnus-thread-sort-by-most-recent-date
                   (not gnus-thread-sort-by-number)))
           
           ;;(add-to-list 'gnus-secondary-select-methods '(nnreddit ""))
           (setq gnus-use-cache t)
           ;; Show more MIME-stuff:
           (setq gnus-mime-display-multipart-related-as-mixed t)
           ;; http://www.gnu.org/software/emacs/manual/html_node/gnus/_005b9_002e2_005d.html
           (setq gnus-use-correct-string-widths nil)
           (setq nnmail-expiry-wait 'immediate)
           
           ;; Smileys:
           (setq smiley-style 'medium)
           
           ;; Use topics per default:
           (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
           (setq gnus-message-archive-group '((format-time-string "sent.%Y")))
           (setq gnus-server-alist '(("archive" nnfolder "archive" (nnfolder-directory "~/mail/archive")
                                      (nnfolder-active-file "~/mail/archive/active")
                                      (nnfolder-get-new-mail nil)
                                      (nnfolder-inhibit-expiry t))))
           
           (setq gnus-topic-topology '(;;("Gnus" visible)
                                       ;;(("misc" visible))
                                       ("live.com" visible)))
           ;;(("Reddit" visible))))
           ;; each topic corresponds to a public imap folder
           (setq gnus-topic-alist '(("live.com")
                                    ;;("Reddit")
                                    ("Gnus"))))
#+end_src
** google-c-style
#+begin_src emacs-lisp
(with-hook google-c-style-mode
  (diminish 'google-c-style-mode))
#+end_src
** helm
#+begin_src emacs-lisp
(with-hook eshell-mode
	      (when (featurep 'helm)
	        (with-key-map eshell-mode-map
			      ("C-c C-h" . helm-eshell-history)
			      ("C-c C-r" . helm-comint-input-ring)
			      ("C-c C-l" . helm-minibuffer-history))))

  (with-hook helm-ff-cache-mode
	(diminish 'helm-ff-cache-mode))

  (with-package helm
    (require 'helm-config)
    (require 'helm-eshell)
    (require 'helm-buffers)
    (require 'helm-files)

    (defun my-helm-next-source ()
      (interactive)
      (helm-next-source)
      (helm-next-line))

    (defun my-helm-return ()
      (interactive)
      (helm-select-nth-action 0))

    (setq helm-completion-style             'emacs
	  helm-completion-in-region-fuzzy-match t
	  helm-recentf-fuzzy-match              t
	  helm-buffers-fuzzy-matching           t
	  helm-locate-fuzzy-match               t
	  helm-lisp-fuzzy-completion            t
	  helm-session-fuzzy-match              t
	  helm-apropos-fuzzy-match              t
	  helm-imenu-fuzzy-match                t
	  helm-semantic-fuzzy-match             t
	  helm-M-x-fuzzy-match                  t
	  helm-split-window-inside-p            t
	  helm-move-to-line-cycle-in-source     t
	  helm-ff-search-library-in-sexp        t
	  helm-scroll-amount                    8
	  helm-ff-file-name-history-use-recentf t
	  helm-ff-auto-update-initial-value     t
	  helm-net-prefer-curl                  t
	  helm-autoresize-max-height            0
	  helm-autoresize-min-height           20
	  helm-candidate-number-limit         100
	  helm-idle-delay                     0.0
	  helm-input-idle-delay               0.0
	  helm-ff-cache-mode-lighter-sleep    nil
	  helm-ff-cache-mode-lighter-updating nil
	  helm-ff-cache-mode-lighter          nil
	  ;; browse-url-mosaic-program           "firefox-developer-edition"
	  helm-ff-skip-boring-files            t)

    (dolist (regexp '("\\`\\*direnv" "\\`\\*straight" "\\`\\*xref"))
      (push regexp helm-boring-buffer-regexp-list))

    (helm-autoresize-mode 1)
    (helm-adaptive-mode t)
    (helm-mode 1)

    (add-to-list 'helm-sources-using-default-as-input
		 'helm-source-man-pages)
    (setq helm-mini-default-sources '(helm-source-buffers-list
				      helm-source-bookmarks
				      helm-source-recentf
				      helm-source-buffer-not-found))
    (with-key-map helm
      ("M-i" . helm-previous-line)
      ("M-k" . helm-next-line)
      ("M-I" . helm-previous-page)
      ("M-K" . helm-next-page)
      ("M-h" . helm-beginning-of-buffer)
      ("M-H" . helm-end-of-buffer))

    (with-key-map helm-read-file
      ("C-o" . my-helm-next-source) 
      ("RET" . my-helm-return)))

  (with-hook after-init
    (with-key-map global    
      ("M-x"     . helm-M-x)
      ("C-x C-b" . helm-buffers-list)
      ("C-z a"   . helm-ag)
      ("C-z b"   . helm-filtered-bookmarks)
      ("C-z c"   . helm-company)
      ("C-z d"   . helm-dabbrev)
      ("C-z e"   . helm-calcul-expression)
      ("C-z g"   . helm-google-suggest)
      ("C-z h"   . helm-descbinds)
      ("C-z i"   . helm-imenu-anywhere)
      ("C-z k"   . helm-show-kill-ring)

      ("C-z f"   . helm-find-files)
      ("C-z m"   . helm-mini)
      ("C-z o"   . helm-occur)
      ("C-z p"   . helm-browse-project)
      ("C-z q"   . helm-apropos)
      ("C-z r"   . helm-recentf)
      ("C-z s"   . helm-swoop)
      ("C-z C-c" . helm-colors)
      ("C-z x"   . helm-M-x)
      ("C-z y"   . helm-yas-complete)
      ("C-z C-g" . helm-ls-git-ls)
      ("C-z SPC" . helm-all-mark-rings)))
#+end_src

** helm-ag
#+begin_src emacs-lisp
(with-package helm-ag
              (setq helm-ag-use-agignore t
                    helm-ag-base-command 
                    "ag --mmap --nocolor --nogroup --ignore-case
                    --ignore=*terraform.tfstate.backup*"))
#+end_src
** helm-c-yasnippet
#+begin_src emacs-lisp
(with-hook helm-c-yasnippet
           (setq helm-yas-space-match-any-greedy t))
#+end_src
** helm-descbinds
#+begin_src emacs-lisp

#+end_src
** helm-dired-history
#+begin_src emacs-lisp
(with-package helm-dired-history
              (require 'savehist)
              (add-to-list 'savehist-additional-variables
                           'helm-dired-history-variable)
              (savehist-mode 1)
              (with-eval-after-load 'dired
                (require 'helm-dired-history)
                (define-key dired-mode-map "," 'dired)))
#+end_src
** helm-emms
#+begin_src emacs-lisp

#+end_src
** helm-flyspell
#+begin_src emacs-lisp

#+end_src
** helm-ls-git
#+begin_src emacs-lisp

#+end_src
** helm-lsp
#+begin_src emacs-lisp

#+end_src
** helm-lsp
#+begin_src emacs-lisp
(with-package helm-lsp
  
  (defun netrom/helm-lsp-workspace-symbol-at-point ()
    (interactive)
    (let ((current-prefix-arg t))
    (call-interactively 'helm-lsp-workspace-symbol)))

  (defun netrom/helm-lsp-global-workspace-symbol-at-point ()
    (interactive)
    (let ((current-prefix-arg t))
    (call-interactively 'helm-lsp-global-workspace-symbol)))

  (setq netrom--general-lsp-hydra-heads
        '(;; Xref
          ("d" xref-find-definitions "Definitions" :column "Xref")
          ("D" xref-find-definitions-other-window "-> other win")
          ("r" xref-find-references "References")
          ("s" netrom/helm-lsp-workspace-symbol-at-point "Helm search")
          ("S" netrom/helm-lsp-global-workspace-symbol-at-point "Helm global search")

          ;; Peek
          ("C-d" lsp-ui-peek-find-definitions "Definitions" :column "Peek")
          ("C-r" lsp-ui-peek-find-references "References")
          ("C-i" lsp-ui-peek-find-implementation "Implementation")

          ;; LSP
          ("p" lsp-describe-thing-at-point "Describe at point" :column "LSP")
          ("C-a" lsp-execute-code-action "Execute code action")
          ("R" lsp-rename "Rename")
          ("t" lsp-goto-type-definition "Type definition")
          ("i" lsp-goto-implementation "Implementation")
          ("f" helm-imenu "Filter funcs/classes (Helm)")
          ("C-c" lsp-describe-session "Describe session")

          ;; Flycheck
          ("l" lsp-ui-flycheck-list "List errs/warns/notes" :column "Flycheck"))

        netrom--misc-lsp-hydra-heads
        '(;; Misc
          ("q" nil "Cancel" :column "Misc")
          ("b" pop-tag-mark "Back")))

  ;; Create general hydra.
  (eval `(defhydra netrom/lsp-hydra (:color blue :hint nil)
           ,@(append
              netrom--general-lsp-hydra-heads
              netrom--misc-lsp-hydra-heads))))

(with-hook helm-lsp-mode
  (with-key-map lsp-mode-map
    ([remap xref-find-apropos] . #'helm-lsp-workspace-symbol)
    ("C-c C-l" . 'netrom/lsp-hydra/body)))
#+end_src
** helm-make
#+begin_src emacs-lisp

#+end_src
** helm-org
#+begin_src emacs-lisp

#+end_src
** helm-projectile
#+begin_src emacs-lisp

#+end_src

** helm-swoop
#+begin_src emacs-lisp

#+end_src
** helm-xref
#+begin_src emacs-lisp

#+end_src
** helpful
#+begin_src emacs-lisp
  (with-hook after-init
    (with-key-map global
      ("<f1>"  . helpful-variable)
      ("C-h v" . helpful-variable)
      ("C-h k" . helpful-key)
      ("C-h f" . helpful-callable)
      ("C-h j" . helpful-at-point)
      ("C-h u" . helpful-command)))
#+end_src

** hydra
#+begin_src emacs-lisp
(with-package hydra
  (with-key-map global
    ("C-x t" .
      (defhydra toggle (:color blue)
                "toggle"
                ("a" abbrev-mode "abbrev")
                ("s" flyspell-mode "flyspell")
                ("d" toggle-debug-on-error "debug")
                ("c" fci-mode "fCi")
                ("f" auto-fill-mode "fill")
                ("t" toggle-truncate-lines "truncate")
                ("w" whitespace-mode "whitespace")
                ("q" nil "cancel")))
    ("C-x j" .
      (defhydra gotoline
                ( :pre (linum-mode 1)
                :post (linum-mode -1))
                "goto"
                ("t" (lambda () (interactive)(move-to-window-line-top-bottom 0)) "top")
                ("b" (lambda () (interactive)(move-to-window-line-top-bottom -1)) "bottom")
                ("m" (lambda () (interactive)(move-to-window-line-top-bottom)) "middle")
                ("e" (lambda () (interactive)(goto-char (point-max)) "end"))
                ("c" recenter-top-bottom "recenter")
                ("n" next-line "down")
                ("p" (lambda () (interactive) (forward-line -1))  "up")
                ("g" goto-line "goto-line")
                ))
    ("C-c t" .
      (defhydra hydra-global-org (:color blue)
                "Org"
                ("t" org-timer-start "Start Timer")
                ("s" org-timer-stop "Stop Timer")
                ("r" org-timer-set-timer "Set Timer") ; This one requires you be in an orgmode doc, as it sets the timer for the header
                ("p" org-timer "Print Timer") ; output timer value to buffer
                ("w" (org-clock-in '(4)) "Clock-In") ; used with (org-clock-persistence-insinuate) (setq org-clock-persist t)
                ("o" org-clock-out "Clock-Out") ; you might also want (setq org-log-note-clock-out t)
                ("j" org-clock-goto "Clock Goto") ; global visit the clocked task
                ("c" org-capture "Capture") ; Dont forget to define the captures you want http://orgmode.org/manual/Capture.html
                ("l" (or )rg-capture-goto-last-stored "Last Capture")))))
#+end_src
** imenu-anywhere
#+begin_src emacs-lisp

#+end_src
** lisp & elisp                                                          :pseudo
#+begin_src emacs-lisp
(with-hook after-init
  (set-default 'auto-mode-alist
    (append '(("\\.lisp$" . lisp-mode)
              ("\\.lsp$" . lisp-mode)
              ("\\.cl$" . lisp-mode))
              auto-mode-alist)))
#+end_src
** lsp-mode
#+begin_src emacs-lisp
(with-package lsp-mode
      (setq lsp-diagnostic-provider :none
            lsp-keymap-prefix "C-f"
            lsp-completion-provider t
            lsp-enable-xref t
            lsp-auto-configure t
            lsp-auto-guess-root t
            ;;lsp-inhibit-message t
            lsp-enable-snippet t
            lsp-restart 'interactive
            lsp-log-io nil
            lsp-enable-links nil
            lsp-enable-symbol-highlighting nil
            lsp-keep-workspace-alive t
            lsp-clients-clangd-args '("-j=4" "-background-index" "-log=error")
            ;; python
            ;; lsp-python-executable-cmd "python3"
            ;; lsp-python-ms-executable "~/repos/python-language-server/output/bin/Release/osx-x64/publish/Microsoft.Python.LanguageServer"
            lsp-enable-completion-enable t)

      (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
      (add-hook 'lsp-managed-mode-hook (lambda () (setq-local company-backends
      '(company-capf)))))

(with-hook lsp-mode
      (diminish 'lsp-mode))
#+end_src
** lsp-ui
#+begin_src emacs-lisp
(with-package lsp-ui
  (add-hook 'lsp-mode-hook 'lsp-ui-mode)
  (setq lsp-ui-doc-enable t
        lsp-ui-doc-header t
        lsp-ui-doc-include-signature t
        lsp-ui-doc-position 'top
        lsp-ui-doc-border (face-foreground 'default)
        lsp-ui-sideline-enable nil
        lsp-ui-sideline-ignore-duplicate t
        lsp-ui-sideline-show-code-actions nil
        lsp-ui-sideline-ignore-duplicate t
        ;; Use lsp-ui-doc-webkit only in GUI
        lsp-ui-doc-use-webkit t
        ;; WORKAROUND Hide mode-line of the lsp-ui-imenu buffer
        ;; https://github.com/emacs-lsp/lsp-ui/issues/243
        mode-line-format nil)
        (defadvice lsp-ui-imenu (after hide-lsp-ui-imenu-mode-line activate)))

(with-hook lsp-ui
  (diminish 'lsp-ui-mode)
  (with-key-map lsp-ui-mode
    ([remap xref-find-references] . lsp-ui-peek-find-references)
    ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
    ("C-c u" . lsp-ui-imenu)))
#+end_src
** modern-cpp-font-lock
#+begin_src emacs-lisp
(with-hook modern-cpp-font-lock-mode
  (diminish 'modern-cpp-font-lock-mode))
#+end_src
** nov
#+begin_src emacs-lisp
(with-hook after-init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+end_src
** oauth2 :disable
#+begin_src emacs-lisp

#+end_src
** org-noter-pdftools
#+begin_src emacs-lisp
(with-package pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions
       #'org-noter-pdftools-jump-to-note))
#+end_src
** org-pdftools
#+begin_src emacs-lisp
(with-hook org-load
  (org-pdftools-setup-link))
#+end_src
** org                                                                      :pseudo
#+begin_src emacs-lisp
  (with-package org

   (defun get-html-title-from-url (url)
     "Return content in <title> tag."
     (require 'mm-url)
     (let (x1 x2 (download-buffer (url-retrieve-synchronously url)))
       (with-current-buffer download-buffer
	 (goto-char (point-min))
	 (setq x1 (search-forward "<title>"))
	 (search-forward "</title>")
	 (setq x2 (search-backward "<"))
	 (mm-url-decode-entities-string (buffer-substring-no-properties x1 x2)))))

   (defun my-org-insert-link ()
     "Insert org link where default description is set to html title."
     (interactive)
     (let* ((url (read-string "URL: "))
	    (title (get-html-title-from-url url)))
       (org-insert-link nil url title)))

   (defun org-agenda-show-agenda-and-todo (&optional arg)
     ""
     (interactive "P")
     (org-agenda arg "c")
     (org-agenda-fortnight-view))

   (setq org-capture-templates
	 `(("p" "Protocol" entry (file+headline "~/Dokument/notes.org" "Inbox")
	    "* %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")
	   ("L" "Protocol Link" entry (file+headline "~/Dokument/notes.org" "Inbox")
	    "* %? [[%:link][%(transform-square-brackets-to-round-ones\"%:description\")]]\n")
	   ("n" "Note" entry (file "~/Dokument/notes.org")
	    "* %? %^G\n%U" :empty-lines 1)
	   ("P" "Research project" entry (file "~/Org/inbox.org")
	    "* TODO %^{Project title} :%^G:\n:PROPERTIES:\n:CREATED:
		    %U\n:END:\n%^{Project description}\n** 
		   TODO Literature review\n** TODO %?\n** TODO Summary\n** TODO Reports\n** Ideas\n" :clock-in t :clock-resume t)
	   ("e" "Email" entry (file "~/Org/inbox.org")
	    "* TODO %? email |- %:from: %:subject :EMAIL:\n:PROPERTIES:\n:CREATED: %U\n:EMAIL-SOURCE: %l\n:END:\n%U\n" :clock-in t :clock-resume t)))

  (setq  org-log-done 'time
	 org-ditaa-jar-path "/usr/bin/ditaa"
	 org-todo-keywords '((sequence "TODO" "INPROGRESS" "DONE"))
	 org-todo-keyword-faces '(("INPROGRESS" . (:foreground "blue" :weight bold)))
	 org-directory (expand-file-name "~/Dokument/")
	 org-default-notes-file (expand-file-name "notes.org" org-directory)
	 org-use-speed-commands       t
	 org-src-preserve-indentation t
	 org-export-html-postamble    nil
	 org-hide-leading-stars       t
	 org-make-link-description    t
	 org-hide-emphasis-markers    t
	 org-startup-folded           'overview
	 org-startup-indented         t))
#+end_src
** pdf-tools
#+begin_src emacs-lisp
(with-package pdf-tools
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page)

  
  (defhydra hydra-pdftools (:color blue :hint nil)
        "
                                                                      ╭───────────┐
       Move  History   Scale/Fit     Annotations  Search/Link    Do   │ PDF Tools │
   ╭──────────────────────────────────────────────────────────────────┴───────────╯
         ^^_g_^^      _B_    ^↧^    _+_    ^ ^     [_al_] list    [_s_] search    [_u_] revert buffer
         ^^^↑^^^      ^↑^    _H_    ^↑^  ↦ _W_ ↤   [_am_] markup  [_o_] outline   [_i_] info
         ^^_p_^^      ^ ^    ^↥^    _0_    ^ ^     [_at_] text    [_F_] link      [_d_] dark mode
         ^^^↑^^^      ^↓^  ╭─^─^─┐  ^↓^  ╭─^ ^─┐   [_ad_] delete  [_f_] search link
    _h_ ←pag_e_→ _l_  _N_  │ _P_ │  _-_    _b_     [_aa_] dired
         ^^^↓^^^      ^ ^  ╰─^─^─╯  ^ ^  ╰─^ ^─╯   [_y_]  yank
         ^^_n_^^      ^ ^  _r_eset slice box
         ^^^↓^^^
         ^^_G_^^
   --------------------------------------------------------------------------------
        "
        ("\\" hydra-master/body "back")
        ("<ESC>" nil "quit")
        ("al" pdf-annot-list-annotations)
        ("ad" pdf-annot-delete)
        ("aa" pdf-annot-attachment-dired)
        ("am" pdf-annot-add-markup-annotation)
        ("at" pdf-annot-add-text-annotation)
        ("y"  pdf-view-kill-ring-save)
        ("+" pdf-view-enlarge :color red)
        ("-" pdf-view-shrink :color red)
        ("0" pdf-view-scale-reset)
        ("H" pdf-view-fit-height-to-window)
        ("W" pdf-view-fit-width-to-window)
        ("P" pdf-view-fit-page-to-window)
        ("n" pdf-view-next-page-command :color red)
        ("p" pdf-view-previous-page-command :color red)
        ("d" pdf-view-dark-minor-mode)
        ("b" pdf-view-set-slice-from-bounding-box)
        ("r" pdf-view-reset-slice)
        ("g" pdf-view-first-page)
        ("G" pdf-view-last-page)
        ("e" pdf-view-goto-page)
        ("o" pdf-outline)
        ("s" pdf-occur)
        ("i" pdf-misc-display-metadata)
        ("u" pdf-view-revert-buffer)
        ("F" pdf-links-action-perfom)
        ("f" pdf-links-isearch-link)
        ("B" pdf-history-backward :color red)
        ("N" pdf-history-forward :color red)
        ("l" image-forward-hscroll :color red)
        ("h" image-backward-hscroll :color red)))
#+end_src
** solarized-theme
#+begin_src emacs-lisp
(with-hook after-init
           (load-theme 'solarized-dark t))
#+end_src
** which-key
#+begin_src emacs-lisp
  (with-hook after-init
    (which-key-mode t)
    (diminish 'which-key-mode))
#+end_src
** wrap-region
 #+begin_src emacs-lisp
 (with-hook after-init
    (wrap-region-global-mode t)
    (diminish 'wrap-region-mode))
#+end_src
* Epilog
#+begin_src emacs-lisp
(setq gc-cons-threshold       16777216 ; 16mb
      gc-cons-percentage      0.1
      file-name-handler-alist old-file-name-handler)
  
;; Local Variables:
;; byte-compile-warnings: (not free-vars unresolved))
;; eval: (progn (org-babel-goto-named-src-block "onstartup") (org-babel-execute-src-block) (outline-hide-sublevels 2))
;; End:
#+end_src

#+RESULTS:









