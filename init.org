!# -*- eval: (progn (setq org-startup-folded 'overview) (org-babel-goto-named-src-block "onstartup") (org-babel-execute-src-block)); -*-
* About
** To fix
   [[https://dev.to/viglioni/how-i-set-up-my-emacs-for-typescript-3eeh]]
   https://github.com/clemera/helm-ido-like-guide
** Introduction
*** Motivation
   A very personal and opinionated setup, based on a small code generator. The
   idea with generator is to generate a machine specific setup, so no probing
   for packages, files, paths etc is needed, as well as to perform some
   optimizations automatically and some that are normally not possible.

   This is/was mainly a learning experience to learn Emacs Lisp, but I do use it
   personally for my Emacs setup. It is a lazy-loaded setup and uses lot of timers
   to load the setup during the idle time.

   The setup assumes some environment variables defined in both GNU/Linux and MS
   Windows:

   - BROWSER I use firefox-developer-edition on both OS:s.
   - HOME    Need to be defined on MS Windows, I use %UserProfile%

   This setup also assumes Emacs to run in a Unix-like environment with all the
   standard GNU tools available, so on MS Windows mingw environemnt needs to be
   present and configured. I haven't tested with Cygwin, but I guess it should
   probably work.

   As of later versions it uses the built-in package-vc-install to handle repos
   not present in official repositories (melpa and elpa). The org-keyword I use
   is #+url, and should be placed between the heading and source block marker:

   ** [x] some-package
   #+url https://some-url/some-package
   #+being_src emacs-lisp
   #+end_src

   When I started I used use-package as the inspiration, but never as the source
   of code. All code is developed by me. It started when I really had no idea how to
   program neither Emacs Lisp not any other Lisp, and my knowledge of Emacs internals
   was really bad. Things have improved since I started this :). But as all learning
   projects, the code here is questionable, so honestly I don't recommend using it. It
   should work, but you are on your own, but you are much better off using use-package
   than this. You are warned.

*** The generator implementation

**** Notes
I don't think I ever finished this to my satisfaction. The idea was to take the machine
at hand and produce an init file that is custom tailored for this machine, so no probing
at startup is needed. One should be able to open this very init file in their pristine
Emacs (emacs -q) and be able to generate a configuration customized for the particular
machine. It is not unlike static web-site generators idea. However it means to basicaly
compile some elisp, which in this case means to evaluate some elisp and write the result
of those evaluations into the init file. For example, if you have expand-file-name and
some string and variable, you want to evaluate that expand-file-name and write down the
actual resulted file path to init file. For this of course, one need the full working
environment at compile-time, which might be tricky. In other words, bootstrapping this
from pristine Emacs is not an easy task, and as of current, 2025-09-24, I still haven't
really achieved this in full. To make this easier to work with, I also need to be able
to run this at runtime, so there is "compiler" and "interpreter" versions of some macros.

If you are user of use-package, you are familiar with the DSL they use. As with any DSL,
it is a double-edged sword in my opinion. A DSL enables writing highly expressive code.
But on the other side, it hides the original language behind the DSL. With a DSL everything
is fine when it works. However, when things break, than one usually needs to know how the
DSL maps to the underlaying language it abstracts away, which suddenly adds more complexity
than it automates away. For me, this was a learning experience for Emacs Lisp, and what is
more opportunity to work how Emacs works deeply, than to write a configuration of your own,
or even to automate writing of such a configuration?

What I took notice early, is that use-package is basicaly abstraction on top of Emacs hooks.
Hooks are what is in C or some other languages seen as callbacs. Typically a callback in a
framework is called when certain event happens. For example if you load a library (elisp
term for elisp source file), a "special hook", i.e. 'after-load-function' function is run.
Macro `with-eval-after-load' uses this hook to arrange for elisp specified in this macro to
run when a certain file is loaded. Given a name of an emacs package, we can easily construct
a macro that runs when a package is loaded. Similarly, each mode runs a mode hook after it has
loaded, so one can use that hook to run some code that customizes mode or loads another mode
when a certain mode is loaded.

Perhaps a paradoxical, but once, you understand this principle, you don't need a DSL, but you
also want a DSL to save you some typing. There is also one big advantage with a DSL as
use-package, and hiding the implementation behind a language: like with any other language, one
can change the underlaying implementation without the users not needing to change anything in
their configurations. For example, use-package has 'diminish' keyword. They can implement this
keyword either via `diminish-mode', some other similar mode, or in a newer Emacs with the built-in
primitive for this (which as of this writing does not seem to work, at least not having any effect
in my Emacs).

**** Hooks

I wanted this to be simple to type and look at. The DSL is very simple

** Licence
   GNU General Public License, see the attached LICENSE file
   or visit <https://www.gnu.org/licenses/> for the details.

* Generator
#+NAME: onstartup
#+begin_src emacs-lisp :results output silent
(require 'files)
(eval-when-compile
  (require 'cl-macs)
  (require 'comp))
;;(require 'comp)
(require 'pp)
(require 'pcase)
(require 'compile)
(setf lexical-binding nil)
(defvar init-file-init-file
  (expand-file-name "init.el" user-emacs-directory))
(defvar init-file-early-init-file
  (expand-file-name "early-init.el" user-emacs-directory))
(defvar init-file-target init-file-init-file)
(defvar init-file-verbose-messages nil)
(defvar init-file-unroll-key-bindings t)
(defvar init-file-use-modules nil)
(defvar init-file-lisp-directory (expand-file-name "lisp/" user-emacs-directory))
(defvar init-file--autoloads-map (make-hash-table :test 'equal))
(defvar init-file-load-paths nil)
(defvar init-file--need-package-refresh t)
(defvar init-file-package-list nil)
(defvar init-file-hooks nil)
(defvar init-file-idle-interval 0.25)

(setq package-archives nil)
(defvar melpa-archive '("melpa" . "https://melpa.org/packages/"))
(defvar nelpa-archive '("nelpa" . "https://elpa.nongnu.org/nongnu/"))
(defvar gnu-archive '("elpa" . "https://elpa.gnu.org/packages/"))

;;(add-to-list 'package-archives site-archive)
(add-to-list 'package-archives gnu-archive)
(add-to-list 'package-archives nelpa-archive)
(add-to-list 'package-archives melpa-archive)

(unless (file-directory-p init-file-lisp-directory)
  (make-directory init-file-lisp-directory))

(defsubst read-expression ()
  (ignore-errors (read (current-buffer))))

(cl-defstruct package
  (name "")
  (enabled t)
  (pseudo nil)
  (pinned nil)
  (code-beg 0)
  (code-end 0)
  (url ""))

(defun on-buffer-change-hook (beg eng len)
  (setq init-file-package-list nil))
(add-hook 'after-change-functions 'on-buffer-change-hook)

;; (defmacro on-hook (name &rest body)
;;   (declare (indent defun))
;;   (let (found hook)
;;     (setq name (if (string-match "-hook\\'" (symbol-name `,name))
;;                    `,name
;;                  (intern (concat (symbol-name name) "-hook"))))
;;     (setq body (nreverse body))
;;     (dolist (hook init-file-hooks)
;;       (when (equal (symbol-name (car hook)) (symbol-name name))
;;         (dolist (sexp (nreverse (cdr hook)))
;;           (add-to-list 'body sexp))
;;         (setcdr hook body)
;;         (setq found t)))
;;     (unless found
;;       (add-to-list 'init-file-hooks (cons name body)))
;;     (ignore)))

(defun verbose (format-string
                &rest args )
  (when init-file-verbose-messages
    (apply #'message format-string args)))

(defun clean-init-file ()
  (interactive)
  (with-temp-buffer
    (insert-file-contents init-file-init-file)
    (beginning-of-buffer)
    (while (not (eobp))
      (when (char-equal (char-after) ?\^M)
        (delete-char 1))
      (forward-char 1))
    (write-region (point-min) (point-max) init-file-init-file)))

(defmacro on-hook (hook &rest body)
  "Less-verbose `add-hook', with basic functionality."
  (declare (indent defun) (debug (sexp def-body)))
  `(add-hook ',hook (lambda () ,@body)))

;; config-macros start

(defmacro on-package (package &rest body)
  (declare (indent defun) (debug (sexp def-body)))
  `(with-eval-after-load ,package
     ,@body))

(defmacro on-idle (&rest body)
  (declare (indent defun))
  `(run-with-idle-timer 0.5 nil (lambda () ,@body)))

(defmacro on-system (systype &rest body)
  (declare (indent defun))
  (when (equal system-type systype)
    `(progn ,@body)))

(defmacro on-host (host &rest body)
  (declare (indent defun))
  (when (equal system-name host)
    `(progn ,@body)))

(defmacro defkeys (mapname &rest body)
  (declare (indent defun))
  `(let ((defs '(,@body)))
     (while defs
       (define-key ,mapname
                   (if (vectorp (car defs))
                       (car defs)
                     (read-kbd-macro (car defs)))
                   (if (or (listp (cadr defs)) (functionp (cadr defs)))
                       (cadr defs)
                     (if `(keymapp (bound-and-true-p ,(cadr defs)))
                         (eval (cadr defs)))))
       (setq defs (cddr defs)))))

;; config-macros end

(defun get-config-macs ()
  (with-current-buffer (get-buffer "init.org")
    (save-excursion
      (goto-char 1)
      (search-forward "config-macros")
      (forward-line 1)
      (let ((beg (point)))
        (search-forward "config-macros")
        (forward-line -1)
        (buffer-substring-no-properties beg (point))))))

(defun append-to-file (expression)
  (write-region 
   (if (stringp expression)
       expression
     (prin1-to-string expression))
   nil init-file-target t 0))

(defun emit-defkeys (map definitions)
  (while definitions
    (let ((key (car definitions))
    	  (command (cadr definitions)))
      (append-to-file
       `(define-key ,map ,(if (vectorp  key) key (kbd key))  #',command)))
    (setf definitions (cddr definitions))))

(defun emit-on-idle (sexp)
  (append-to-file 
   `(run-with-idle-timer ,init-file-idle-interval nil (lambda () ,sexp))))

(defun emit-on-hook (hook body)
  (message "EMIT HOOK %s" `(add-hook ',hook (lambda () ,@body)))
  (append-to-file `(add-hook ',hook (lambda () ,@body))))

(defun emit-package (name body)
  (message "Parsing package [%s]" name)
  (when (eq name 'company)
    (message "Body %S" body))
  (write-region (format "\n(with-eval-after-load '%s\n" name)
    		nil init-file-target t 0)
  (dolist (expression body)
    (message "LB: %d" (length body))
    (emit-sexp-to-file expression)
    (append-to-file "\n"))
  (write-region ")\n" nil init-file-target t 0))

(defun emit-init (body)
  (let ((init-file-target init-file-init-file))
    (dolist (expression body)
      (emit-sexp-to-file expression))))

(defun emit-early-init (body)
  (let ((init-file-target init-file-early-init-file))
    (dolist (expression body)
      (emit-sexp-to-file expression))))

(defun emit-sexp-to-file (sexp)
  (pcase (car sexp)
    ('defkeys
      (emit-defkeys (cadr sexp) (cddr sexp)))
    ('on-package
      (pcase (cadr sexp)
    	('init (emit-init (cddr sexp)))
    	('early-init (emit-early-init (cddr sexp)))
        (_
         (emit-package (cadr sexp) (cddr sexp)))))
    ('on-hook
      (emit-on-hook (cadr sexp) (cddr sexp)))
    ('on-idle
      (emit-on-idle (cadr sexp)))
    ('on-system
      (when (equal (cadr sexp) system-type)
        (append-to-file (cddr sexp))))
    ('on-host
      (when (equal (cadr sexp) system-name)
        (append-to-file (cddr sexp))))
    (_
     (append-to-file sexp))))

(defun emit-region (beg end)
  (save-excursion
    (goto-char beg)
    (while (lte (point) end)
      (let (expression)
        (while (setf expression (read-expression))
          (emit-sexp-to-file expression))))))

(defun emit-packages ()
  (message "Emiting packages ... ")
  (dolist (p (get-package-list))
    (when (package-enabled p)
      (verbose "Emiting package: %s" (package-name p))
      (emit-region (package-code-beg p) (package-code-end p)))))

(defun emit-hooks ()
  (message "Emiting hooks ...")
  (dolist (hook init-file-hooks)
    (verbose "Hook: %s" (car hook))
    (progn
      (append-to-file (concat "(add-hook '"
          		      (symbol-name (car hook))
          		      " #'(lambda nil\n"))
      (dolist (s (cdr hook))
        (emit-to-init-file s))
      (append-to-file "))"))))

(defun quotedp (sym)
  (if (and (consp sym) (eq (car sym) 'quote))
      sym `(quote ,sym)))

(defun interactivep (form)
  "Wether form is an interactive command."
  (catch 'interactive
    (dolist (sxp form)
      (and (listp sxp) (eq 'interactive (car sxp))
           (throw 'interactive t)))))

(defun init-file-load-paths ()
  (let ((packages (get-package-list))
        (default-directory package-user-dir))
    (setf init-file-load-paths nil)
    (dolist (package packages)
      (let ((pkgdir (car (file-expand-wildcards (concat (package-name package) "*")))))
        (when (and (package-enabled package)
                   (not (package-pseudo package))
                   pkgdir)
          (setf pkgdir (expand-file-name pkgdir))
  	  (message "PKGDIR %s" pkgdir)
          (push pkgdir init-file-load-paths)
  	  (setf load-path (append init-file-load-paths load-path))
  	  init-file-load-paths)))))

(defun macro-p (form)
  "Wether FORM is a macro definition."
  (eq (car form) 'defmacro))

(defun emit-load-paths ()
  (message "Emitting load-path")
  (let ((loadpath (car (read-from-string
                        (shell-command-to-string
                         "emacs --batch --eval \"(prin1 load-path)\"")))))
    (push init-file-lisp-directory loadpath)
    (let ((init-file-target init-file-early-init-file))
      (append-to-file
       `(setf load-path (list ,@init-file-load-paths ,@loadpath))))))

(defun collect-autoloads (src)
  (verbose "Collecting autoloads for file: %s" src)
  (when src
    (let (sym interactive macro file expression expressions)
      (with-temp-buffer
        (insert-file-contents src)
        (while (re-search-forward "^;;;###autoload" nil t)
          (setq expression (ignore-errors (read (current-buffer))))
          (when (and expression (listp expression))
            (setq sym (quotedp (cadr expression))
                  interactive (interactivep expression)
                  macro (macro-p expression)
                  file (file-name-nondirectory src))
            (unless (listp (cadr sym))
              (push (list 'autoload sym file nil interactive macro)
          	    expressions)))))
      expressions)))

(defun package-name-from-elpa-dir ()
  (with-temp-buffer
    (let* ((default-directory package-user-dir)
           (file (car (file-expand-wildcards "*-pkg.el"))))
      (when file
        (insert-file-contents file)
        (nth 1 (read (current-buffer)))))))

(defun autoloads-from-elpa-dir (pck-dir)
  (verbose "Collecting autoloads from ELPA dir: %s" pck-dir)
  (when (file-directory-p pck-dir)
    (with-temp-buffer
      (let* ((default-directory (expand-file-name pck-dir package-user-dir))
             (file (car (file-expand-wildcards "*-autoloads.el")))
             (search t))
        (when file
          (insert-file-contents file)
          (verbose "Collect autoloads for pkg %s" (package-name package))
          (cl-loop while search with expr with autoloads do
                   (setf expr (ignore-errors (read (current-buffer))))
                   (unless expr (setf search nil))
                   (when (and expr (listp expr))
          	     (pcase (car expr)
          	       ('add-to-list #'ignore)
          	       ('provide (setf search nil))
          	       (_ (push expr autoloads))))
                   finally
                   (cl-return autoloads)))))))

(defun emit-autoloads (file)
  (message "Emiting autoloads")
  (let ((default-directory package-user-dir))

    (dolist (package (get-package-list))
      (let* ((pkdir (car (file-expand-wildcards
                          (concat (package-name package) "*")))))
        (when (and (package-enabled package)
                   (not (package-pseudo package))
                   pkdir)
          (dolist (expression (autoloads-from-elpa-dir pkdir))
            (when expression
              (append-to-file expression))))))

    (dolist (file (directory-files-recursively
                   init-file-lisp-directory "\\.el$" nil t t))
      (dolist (expression (collect-autoloads file))
        (append-to-file expression)))))

(defsubst maybe-remove-file (file)
  (when (file-exists-p file)
    (delete-file file)
    (message "Removed file %s" file)))

(defun tangle-init-file (&optional init-file)
  (message "Exporting init files.")
  (maybe-remove-file init-file-init-file)
  (maybe-remove-file "init.elc")
  (maybe-remove-file init-file-early-init-file)
  (with-temp-file "init.el"
    (insert ";; init.el -*- lexical-binding: t; -*-\n")
    (insert ";; This file is machine generated by init-file generator, don't edit\n")
    (insert ";; manually, edit instead file init.org and generate new init  file from it.\n\n")
    (insert (get-config-macs)))
  (with-temp-file "early-init.el"
    (insert ";; early-init.el -*- lexical-binding: t; -*-\n")
    (insert ";; This file is machine generated by init-file generator, don't edit\n")
    (insert ";; manually, edit instead file init.org and generate new init file from it.\n\n"))
  (setq init-file-hooks nil
        init-file-package-list (get-package-list))
  (let ((init-file-target init-file-init-file))
    (emit-autoloads init-file)
    ;; generate stuff
    (emit-packages)
    ;; do this after user init stuff
    (emit-hooks) ;; must be done after emiting packages
    (emit-load-paths) ;; must be done after emiting hooks
    ;; fix init.el
    (with-temp-buffer
      (insert-file-contents "init.el")
      (goto-char (point-max))
      (insert "\n;; Local Variables:\n")
      (insert ";; coding: utf-8\n")
      (insert ";; byte-compile-warnings: '(not docstrings free-vars))\n")
      (insert ";; End:\n")
      (emacs-lisp-mode)
      (indent-region (point-min) (point-max)))
    ;;(clean-init-file)
    ))

(defun goto-code-start (section)
  (goto-char (point-min))
  (re-search-forward section)
  (re-search-forward "begin_src.*emacs-lisp")
  (skip-chars-forward "\s\t\n\r"))

(defun goto-code-end ()
  (re-search-forward "end_src")
  (beginning-of-line))

(defun generate-init-files ()
  (interactive)
  (message "Exporting init.el ...")
  (let ((load-path init-file-load-paths))
    (tangle-init-file)
    (setq byte-compile-warnings nil)
    (let ((tangled-file "init.el")
          (byte-compile-warnings nil)
          (fill-column 240))
      ;; always produce elc file
      (byte-compile-file tangled-file)
      (verbose "Byte compiled %s" tangled-file)
      ;; (when (featurep 'native-compile)
      ;;   (native-compile tangled-file)
      ;;   (verbose "Tangled and compiled %s" tangled-file))
      (verbose "Done.")
      (message "Compiling early-init.el ...")
      (byte-compile-file (expand-file-name "early-init.el"  user-emacs-directory))
      (message "Done."))))

(defun install-file (file)
  (when (file-exists-p file)
    (unless (equal (file-name-directory buffer-file-name)
                   (expand-file-name user-emacs-directory))
      (copy-file file user-emacs-directory t))
    (message "Wrote: %s." file)))

(defun install-init-files ()
  (interactive)
  (let ((i "init.el")
        (ic "init.elc")
        (ei "early-init.el")
        (pq (expand-file-name "package-quickstart.el" user-emacs-directory))
        (pqc (expand-file-name "package-quickstart.elc" user-emacs-directory)))
    (install-file i)
    (install-file ei)
    (unless (file-exists-p ic)
      (byte-compile (expand-file-name el)))
    (install-file ic)
    ;; remove package-quickstart files from .emacs.d
    (when (file-exists-p pq)
      (delete-file pq))
    (when (file-exists-p pqc)
      (delete-file pqc))))

(defun read-package-spec ()
  ;; format:
  ;; [name enabled pseudo pinned-to code-beg-pos code-end-pos fetch-url]
  (let ((package (make-package))
        (packages nil)
        (header-beg (point))
        (header-end (line-end-position)))
    ;; package name
    (goto-char header-end)
    (search-backward "] " header-beg t)
    (forward-char)
    (setf (package-name package)
          (string-trim
           (buffer-substring-no-properties (point) header-end)))
    (goto-char header-beg)
    ;; are we "pinned" to something
    (if (re-search-forward "\\[ \\(.*\\) \\]" header-end t)
        (let ((s (string-trim (match-string 1))))
          (set-text-properties 0 (length s) nil s)
          (setf (package-pinned package) s
                header-beg (point))
          (when (equal s "vc")
            (forward-line)
            (if (not (search-forward "#+url" (line-end-position) t))
                (error
                 "VC specified without URL keyword: %s line %s"
                 (package-name package) (1- (line-number-at-pos)))
              (unless (setf (package-url package)
          		    (string-trim
          		     (buffer-substring-no-properties (point)
          						     (line-end-position))))
                (error "VC specified, but no URL given %s line %s"
          	       (package-name package) (1- (line-number-at-pos))))))))
    ;; pseudo package?
    (when (equal (package-pinned package) "none")
      (setf (package-pseudo package) t))
    ;; enabled?
    (when (looking-at-p "\\[ \\]")
      (setf (package-enabled package) nil))
    ;; code start
    (re-search-forward "begin_src.*emacs-lisp")
    (setf (package-code-beg package) (point))
    (search-forward "end_src")
    (goto-char (line-beginning-position))
    (setf (package-code-end package) (- (point) 1))
    (goto-char (line-end-position))
    package))

(defun get-package-list ()
  (with-current-buffer (get-buffer "init.org")
    (save-excursion
      (goto-char (point-min))
      (verbose "Creating package list ...")
      (re-search-forward "^\\* Packages")
      (let ((beg (point))
            (end (or (re-search-forward "^\\* " nil t) (point-max))))
        (goto-char beg)
        (while (re-search-forward "^\\*\\* " end t)
          (push (read-package-spec) init-file-package-list)))))
  init-file-package-list)

;; Install packages
(defun install-package (package)
  (let ((pkg (intern-soft (package-name package)))
        (url (package-url package)))
    (message "Installing package: %s" package)
    (if (string-empty-p url)
        (condition-case nil
            (package-install pkg)
          (error "Can't install ~s" (package-name pkg)))
      (condition-case e
          (package-vc-install url)
        (error "Skipped %S, error %S" (package-name pkg) e)))))

(defun install-packages (&optional packages)
  (interactive)
  (when init-file--need-package-refresh
    (package-refresh-contents)
    (setq init-file--need-package-refresh nil))
  (dolist (p (or packages (get-package-list)))
    (verbose "Current package: %s" (package-name p))
    (verbose "Enabled %s" (package-enabled p))
    (when (and (package-enabled p)
               (not (package-pseudo p))
               (not (package-installed-p p)))
      (install-package p))))

(defun current-package ()
  "Return name of package the cursor is at the moment."
  (save-excursion
    (let (nb ne pn (start (point)))
      (when (re-search-backward "^\\* Packages" (point-min) t)
        (setq nb (point))
        (goto-char start)
        (setq pn (search-forward "** " (line-end-position) t 1))
        (unless pn
          (setq pn (search-backward "** " nb t 1)))
        (when pn
          (search-forward "] ")
          (setq nb (point))
          (re-search-forward "[\n[:blank:]]")
          (forward-char -1)
          (setq ne (point))
          (setq pn (buffer-substring-no-properties nb ne))
          pn)))))

(defun install-and-configure ()
  (interactive)
  (install-packages)
  (generate-init-files)
  (install-init-files))

(defun configure-emacs ()
  (interactive)
  (generate-init-files)
  (install-init-files))

(defalias 'vlt 'version-list-<)
(defun org-init-update-packages ()
  (interactive)
  (package-refresh-contents)
  (let ((package-list (get-package-list)))
    (dolist (package package-activated-list)      
      (let* ((new (cadr (assq package package-archive-contents)))
             (old (cadr (assq package package-alist)))
             (pkg (and new
                       (cl-find (package-desc-name new)
                                package-list :test #'equal :key #'package-name)))
             (to-install (and new old (vlt (package-desc-version old)
                                           (package-desc-version new)))))
        (when (and to-install
                   (or (not pkg)
                       (and pkg (not (package-url pkg)))))
          (setq to-install
                (package-compute-transaction (list new) (package-desc-reqs new)))
          (message "Installing package: %S" (package-desc-dir new))
          (package-download-transaction to-install)
          (message "Removed package: %S" (package-desc-dir old))
          (and (file-directory-p (package-desc-dir old))
               (not (file-symlink-p (package-desc-dir old)))
               (delete-directory (package-desc-dir old) t)))))))

  ;; init paths
(init-file-load-paths)
(require 'diminish)
(require 'helm-easymenu)
(require 'yasnippet)
(require 'yasnippet-snippets)

                        ;;; org hacks

(defmacro gt (n1 n2)
  `(> ,n1 ,n2))
(defmacro gte (n1 n2)
  `(>= ,n1 ,n2))
(defmacro lt (n1 n2)
  `(< ,n1 ,n2))
(defmacro lte (n1 n2)
  `(<= ,n1 ,n2))

;; https://www.reddit.com/message/unread/
;;(require 'cape)

(if (featurep 'org-heading-checkbox)
    (unload-feature 'org-heading-checkbox))
(defvar org-init--enabled-re "^[ \t]*\\*+.*?[ \t]*\\[x\\]")
(defvar org-init--disabled-re "^[ \t]*\\*+.*?[ \t]*\\[ \\]")
(defvar org-init--checkbox-re "^[ \t]*\\*+.*?\\[[ x]\\]")

(defun org-init--heading-checkbox-p ()
  "Return t if this is a heading with a checkbox."
  (save-excursion
    (beginning-of-line)
    (looking-at org-init--checkbox-re)))

(defun org-init--checkbox-enabled-p ()
  "Return t if point is at a heading with an enabed checkbox."
  (save-excursion
    (beginning-of-line)
    (looking-at "^[ \t]*\\*+.*?\\[x\\]")))

(defun org-init--checkbox-disabled-p ()
  "Return t if point is at a heading with a disabeled checkbox."
  (save-excursion
    (beginning-of-line)
    (looking-at "^[ \t]*\\*+.*?\\[ \\]")))

(defun org-init--checkbox-enable ()
  "Disable checkbox for heading at point."
  (interactive)
  (when (org-init--checkbox-enabled-p)
    (save-excursion
      (beginning-of-line)
      (replace-string "[ ]" "[x]" nil (line-beginning-position)
          	      (line-end-position)))))

(defun org-init--checkbox-disable ()
  "Disable checkbox for heading at point."
  (interactive)
  (when (org-init--checkbox-enabled-p)
    (save-excursion
      (beginning-of-line)
      (replace-string "[x]" "[ ]" nil (line-beginning-position)
          	      (line-end-position)))))

(defun org-init--checkbox-toggle ()
  "Toggle state of checkbox at heading under the point."
  (interactive)
  (save-excursion
    (beginning-of-line)
    (cond ((looking-at org-init--enabled-re)
           (replace-string "[x]" "[ ]" nil (line-beginning-position)
                           (line-end-position)))
          ((looking-at org-init--disabled-re)
           (replace-string "[ ]" "[x]" nil (line-beginning-position)
                           (line-end-position)))
          (t (error "Not at org-init-checkbox line.")))))

(defun org-init--packages ()
  "Return start of packages; point after the \"* Packages\" heading."
  (save-excursion
    ;; we search backward, which will find beginning of line if the current
    ;; point is after the heading
    (cond ((re-search-backward "^\\* Packages" (point-min) t)
           (point))
          ;; the point was after the heading, and now we are at the point-min
          ((re-search-forward "^\\* Packages" nil t)
           (beginning-of-line)
           (point))
          ;; we didn't found the Packages section, means invalid file
          (t (error "No Packages section in current file found.")))))

;; help fns to work with init.org
(defun add-package (package)
  (interactive "sPackage name: ")
  (goto-char (org-init--packages))
  (forward-line 1)
  (insert (concat "\n** [x] "
                  package
                  "\n#+begin_src emacs-lisp\n"
                  "\n#+end_src\n"))
  (forward-line -2))

(defun add-git-package (url)
  (interactive "sGIT url: ")
  (unless (string-empty-p url)
    (let ((tokens (split-string url "/" t "\s\t")) package)
      (message "T: %S" tokens)
      (dolist (tk tokens)
        (setq package tk))
      (goto-char (org-init--packages))
      (forward-line 1)
      (insert (concat "\n** [x] " package
          	      "\n#+GIT: " url
          	      "\n#+begin_src emacs-lisp\n"
          	      "\n#+end_src\n"))
      (forward-line -2))))

(defun org-init--package-enabled-p ()
  "Return t if point is in a package headline and package is enabled."
  (save-excursion
    (beginning-of-line)
    (looking-at "^[ \t]*\\*\\* \\[x\\]")))

(defun org-init--toggle-headline-checkbox ()
  "Switch between enabled/disabled todo state."
  (if (org-init--package-enabled-p)
      (org-todo 2)
    (org-todo 1)))

(defun org-init--package-section-p ()
  (save-excursion
    (let ((current-point (point)))
      (when (re-search-backward "^\\* Packages" nil t)
        (forward-line 1)
        (gte current-point (point))))))

(defun org-init--shiftup ()
  "Switch between enabled/disabled todo state."
  (interactive)
  (if (org-init--package-section-p)
      (save-excursion
        (beginning-of-line)
        (unless (looking-at org-heading-regexp)
          (re-search-backward org-heading-regexp))
        (if (org-init--heading-checkbox-p)
            (org-init--checkbox-toggle)))
    (org-shiftup)))

(defun org-init--shiftdown ()
  "Switch between enabled/disabled todo state."
  (interactive)
  (if (org-init--package-section-p)
      (save-excursion
        (beginning-of-line)
        (unless (looking-at org-heading-regexp)
          (re-search-backward org-heading-regexp))
        (if (org-init--heading-checkbox-p)
            (org-init--checkbox-toggle)))
    (org-shiftdown)))

(defun org-init--shiftright ()
  "Switch between enabled/disabled todo state."
  (interactive)
  (if (org-init--package-section-p)
      (save-excursion
        (beginning-of-line)
        (unless (looking-at org-heading-regexp)
          (re-search-backward org-heading-regexp))
        (org-shiftright))
    (org-shiftright)))

(defun org-init--shiftleft ()
  "Switch between enabled/disabled todo state."
  (interactive)
  (if (org-init--package-section-p)
      (save-excursion
        (beginning-of-line)
        (unless (looking-at org-heading-regexp)
          (re-search-backward org-heading-regexp))
        (org-shiftleft))
    (org-shiftleft)))

(defun org-init--open-in-dired ()
  (interactive)
  (if (org-init--package-section-p)
      (save-excursion
        (beginning-of-line)
        (unless (looking-at org-heading-regexp)
          (re-search-backward org-heading-regexp))
        (let ((elpa (expand-file-name "elpa" user-emacs-directory))
              start pkgname pkdir)
          (search-forward "[ " (line-end-position) t)
          (if (search-forward "none" (line-end-position) t)
              (dired (expand-file-name "lisp/" user-emacs-directory) pkdir)
            (progn
              (beginning-of-line)
              (while (search-forward "] " (line-end-position) t) )
              (setq start (point))
              (skip-chars-forward "[a-zA-Z\\-]")
              (setq pkgname (buffer-substring-no-properties start (point)))
              (setq pkdir (directory-files elpa t pkgname t ))
              (if pkdir (dired (car pkdir)))))))))

(defun org-init--sort-packages ()
  "This is just a convenience wrapper for org-sort. It does reverted sort on
                                  todo keywords-"
  (interactive)
  (save-excursion
    (goto-char (org-init--packages))
    (org-sort-entries nil ?a) ;; first sort alphabetic than in reversed todo-order
    (org-sort-entries nil ?O)
    (org-cycle) (org-cycle)))

(defun org-init--goto-package ()
  (interactive)
  (let ((org-goto-interface 'outline-path-completionp)
        (org-outline-path-complete-in-steps nil))
    (org-goto)))

(defvar org-init-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key org-mode-map [remap org-shiftup] #'org-init--shiftup)
    (define-key org-mode-map [remap org-shiftdown] #'org-init--shiftdown)
    (define-key org-mode-map [remap org-shiftleft] #'org-init--shiftleft)
    (define-key org-mode-map [remap org-shiftright] #'org-init--shiftright)
    (define-key map (kbd "C-c i a") 'add-package)
    (define-key map (kbd "C-c i i") 'install-packages)
    (define-key map (kbd "C-c i p") 'add-pseudo-package)
    (define-key map (kbd "C-c i g") 'generate-init-files)
    (define-key map (kbd "C-c i j") 'org-init--goto-package)
    (define-key map (kbd "C-c C-j") 'org-init--open-in-dired)
    (define-key map (kbd "C-c i s") 'org-init--sort-packages)
    (define-key map (kbd "C-c i u") 'org-init-update-packages)
    map)
  "Keymap used in `org-init-mode'.")

(defvar org-init-mode-enabled nil)
(defvar org-init-old-kwds nil)
(defvar org-init-old-key-alist nil)
(defvar org-init-old-kwd-alist nil)
(defvar org-init-old-log-done nil)
(defvar org-init-old-todo nil)
(setq org-init-mode-enabled nil org-init-old-kwds nil org-init-old-key-alist nil
      org-init-old-kwd-alist nil org-init-old-log-done nil org-init-old-todo nil)
(make-variable-buffer-local 'org-log-done)
(make-variable-buffer-local 'org-todo-keywords)

(defun org-init--longest-str (lst)
  (let ((len 0) l)
    (dolist (elt lst)
      (setq l (length elt))
      (when (lt len l)
        (setq len l)))
    len))

(defun org-init--initial-outline ()
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "^\\* About")
    (hide-subtree)
    (re-search-forward "^\\* Generator")
    (hide-subtree)
    (re-search-forward "^\\* Packages")
    (hide-subtree)
    (show-children)))

(defun org-todo-per-file-keywords (kwds)
  "Sets per file TODO labels. Takes as argument a list of strings to be
                                          used as labels."
  (let (alist)
    (push "TODO" alist)
    (dolist (kwd kwds)
      (push kwd alist))
    (setq alist (list (nreverse alist)))
    ;; TODO keywords.
    (setq-local org-todo-kwd-alist nil)
    (setq-local org-todo-key-alist nil)
    (setq-local org-todo-key-trigger nil)
    (setq-local org-todo-keywords-1 nil)
    (setq-local org-done-keywords nil)
    (setq-local org-todo-heads nil)
    (setq-local org-todo-sets nil)
    (setq-local org-todo-log-states nil)
    (let ((todo-sequences alist))
      (dolist (sequence todo-sequences)
        (let* ((sequence (or (run-hook-with-args-until-success
          		      'org-todo-setup-filter-hook sequence)
          		     sequence))
               (sequence-type (car sequence))
               (keywords (cdr sequence))
               (sep (member "|" keywords))
               names alist)
          (dolist (k (remove "|" keywords))
            (unless (string-match "^\\(.*?\\)\\(?:(\\([^!@/]\\)?.*?)\\)?$"
                                  k)
              (error "Invalid TODO keyword %s" k))
            (let ((name (match-string 1 k))
                  (key (match-string 2 k))
                  (log (org-extract-log-state-settings k)))
              (push name names)
              (push (cons name (and key (string-to-char key))) alist)
              (when log (push log org-todo-log-states))))
          (let* ((names (nreverse names))
                 (done (if sep (org-remove-keyword-keys (cdr sep))
                         (last names)))
                 (head (car names))
                 (tail (list sequence-type head (car done) (org-last done))))
            (add-to-list 'org-todo-heads head 'append)
            (push names org-todo-sets)
            (setq org-done-keywords (append org-done-keywords done nil))
            (setq org-todo-keywords-1 (append org-todo-keywords-1 names nil))
            (setq org-todo-key-alist
                  (append org-todo-key-alist
                          (and alist
          		       (append '((:startgroup))
          			       (nreverse alist)
          			       '((:endgroup))))))
            (dolist (k names) (push (cons k tail) org-todo-kwd-alist))))))
    (setq org-todo-sets (nreverse org-todo-sets)
          org-todo-kwd-alist (nreverse org-todo-kwd-alist)
          org-todo-key-trigger (delq nil (mapcar #'cdr org-todo-key-alist))
          org-todo-key-alist (org-assign-fast-keys org-todo-key-alist))
    ;; Compute the regular expressions and other local variables.
    ;; Using `org-outline-regexp-bol' would complicate them much,
    ;; because of the fixed white space at the end of that string.
    (unless org-done-keywords
      (setq org-done-keywords
            (and org-todo-keywords-1 (last org-todo-keywords-1))))
    (setq org-not-done-keywords
          (org-delete-all org-done-keywords
                          (copy-sequence org-todo-keywords-1))
          org-todo-regexp (regexp-opt org-todo-keywords-1 t)
          org-not-done-regexp (regexp-opt org-not-done-keywords t)
          org-not-done-heading-regexp
          (format org-heading-keyword-regexp-format org-not-done-regexp)
          org-todo-line-regexp
          (format org-heading-keyword-maybe-regexp-format org-todo-regexp)
          org-complex-heading-regexp
          (concat "^\\(\\*+\\)"
                  "\\(?: +" org-todo-regexp "\\)?"
                  "\\(?: +\\(\\[#.\\]\\)\\)?"
                  "\\(?: +\\(.*?\\)\\)??"
                  "\\(?:[ \t]+\\(:[[:alnum:]_@#%:]+:\\)\\)?"
                  "[ \t]*$")
          org-complex-heading-regexp-format
          (concat "^\\(\\*+\\)"
                  "\\(?: +" org-todo-regexp "\\)?"
                  "\\(?: +\\(\\[#.\\]\\)\\)?"
                  "\\(?: +"
                  ;; Stats cookies can be stuck to body.
                  "\\(?:\\[[0-9%%/]+\\] *\\)*"
                  "\\(%s\\)"
                  "\\(?: *\\[[0-9%%/]+\\]\\)*"
                  "\\)"
                  "\\(?:[ \t]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?"
                  "[ \t]*$")
          org-todo-line-tags-regexp
          (concat "^\\(\\*+\\)"
                  "\\(?: +" org-todo-regexp "\\)?"
                  "\\(?: +\\(.*?\\)\\)??"
                  "\\(?:[ \t]+\\(:[[:alnum:]:_@#%]+:\\)\\)?"
                  "[ \t]*$"))))

(add-to-list 'org-element-affiliated-keywords "Git")

;; from J. Kitchin:
;; https://kitchingroup.cheme.cmu.edu/blog/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook/
(require 'org-mouse)
(require 'elisp-mode)

(defun scimax-spoof-mode (orig-func &rest args)
  "Advice function to spoof commands in org-mode src blocks.
                                It is for commands that depend on the major mode. One example is
                                `lispy--eval'."
  (if (org-in-src-block-p)
      (let ((major-mode (intern (format "%s-mode"
                                        (first (org-babel-get-src-block-info))))))
        (apply orig-func args))
    (apply orig-func args)))

(defvar scimax-src-block-keymaps
  `(("emacs-lisp"
     .
     ,(let ((map (make-composed-keymap
                  `(,emacs-lisp-mode-map ,org-init-mode-map)
                  org-mode-map)))
        (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
        map))))

(defun scimax-add-keymap-to-src-blocks (limit)
  "Add keymaps to src-blocks defined in `scimax-src-block-keymaps'."
  (let ((case-fold-search t)
        lang)
    (while (re-search-forward org-babel-src-block-regexp limit t)
      (let ((lang (match-string 2))
            (beg (match-beginning 0))
            (end (match-end 0)))
        (if (assoc (org-no-properties lang) scimax-src-block-keymaps)
            (progn
              (add-text-properties
               beg end `(local-map ,(cdr (assoc
                                          (org-no-properties lang)
                                          scimax-src-block-keymaps))))
              (add-text-properties
               beg end `(cursor-sensor-functions
                         ((lambda (win prev-pos sym)
          		    ;; This simulates a mouse click and makes a menu change
          		    ;; (org-mouse-down-mouse nil)
          		    ))))))))))

(define-minor-mode org-init-mode ""
  :global nil :lighter " init-file"
  (unless (derived-mode-p 'org-mode)
    (error "Not in org-mode."))
  (cond (org-init-mode
         (unless org-init-mode-enabled
           (setq org-init-mode-enabled t
                 org-init-old-log-done org-log-done
                 org-init-old-kwds org-todo-keywords-1
                 org-init-old-key-alist org-todo-key-alist
                 org-init-old-kwd-alist org-todo-kwd-alist)
           (setq-local org-log-done nil)
           (let (s kwdlist templist l)
             (dolist (repo package-archives)
               (push (car repo) templist))
             (push "vc" templist)
             (push "none" templist)
             (setq l (org-init--longest-str templist))
             (dolist (s templist)
               (while (lt (length s) l)
                 (setq s (concat s " ")))
               (push (concat "[ " s " ]") kwdlist))
             (org-todo-per-file-keywords (nreverse kwdlist))))
         (add-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks t)
         (add-to-list 'font-lock-extra-managed-props 'local-map)
         (add-to-list 'font-lock-extra-managed-props 'cursor-sensor-functions)
         ;;(advice-add 'lispy--eval :around 'scimax-spoof-mode)
         (cursor-sensor-mode +1)
         (eldoc-mode +1))
        (t
         (remove-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks)
         ;;(advice-remove 'lispy--eval 'scimax-spoof-mode)
         (cursor-sensor-mode -1)
         (setq org-todo-keywords-1 org-init-old-kwds
               org-todo-key-alist org-init-old-key-alist
               org-todo-kwd-alist org-init-old-kwd-alist
               org-log-done org-init-old-log-done
               org-init-mode-enabled nil)))
  (font-lock-fontify-buffer))

(org-init--initial-outline)
(org-init-mode +1)
#+end_src
* Packages

** [ vc    ] [x] emacs-calendar-hr
#+url https://github.com/amno1/emacs-calendar-hr
#+begin_src emacs-lisp

#+end_src

** [ ] helm-dired-history
#+begin_src emacs-lisp
(on-package helm-dired-history
  (require 'savehist)
  (add-to-list 'savehist-additional-variables
               'helm-dired-history-variable)
  (savehist-mode 1)
  (with-eval-after-load "dired"
    (require 'helm-dired-history)
    (define-key dired-mode-map "," 'dired)))
#+end_src
** [ ] helm-git-grep
#+begin_src emacs-lisp
#+end_src
** [ ] helm-sly
#+begin_src emacs-lisp
#+end_src
** [ ] org-sidebar
#+begin_src emacs-lisp
#+end_src
** [ ] polymode
#+begin_src emacs-lisp
#+end_src
** [ ] sly
#+begin_src emacs-lisp
  (on-package sly
    (add-to-list 'sly-contribs 'sly-asdf)
    (add-to-list 'sly-contribs 'sly-mrepl)
    (add-to-list 'sly-contribs 'sly-indentation)
    ;;(require 'sly-stepper-autoloads)
    ;;(require 'sly-quicklisp-autoloads)
    ;;(require 'sly-macrostep-autoloads)
    ;;(require 'sly-named-readtables-autoloads)
    (setq inferior-lisp-program "sbcl")
    (setq sly-init-function 'sly-init-using-slynk-loader)
    (defkeys sly-editing-mode-map
      "C-c b" sly-eval-buffer
      "C-c d" sly-eval-defun
      "C-c C-d" sly-compile-defun
      "C-c C-k" sly-my-compile-and-load-file
      "C-c l" sly-eval-last-expression
      "M-h" sly-documentation-lookup
      "M-n" scroll-up-line
      "M-p" scroll-down-line)
    (defkeys sly-prefix-map
      "C-c b" sly-eval-buffer
      "C-c d" sly-eval-defun
      "C-c C-d" sly-compile-defun
      "C-c C-k" sly-my-compile-and-load-file
      "C-c l" sly-eval-last-expression
      "M-h" sly-documentation-lookup))

  (on-package sly-mrepl
    (defkeys sly-mrepl-mode-map
      "M-n" scroll-up-line
      "M-p" scroll-down-line
      "<up>" sly-mrepl-previous-input-or-button
      "<down>" sly-mrepl-next-input-or-button))

  (on-hook sly-mrepl-mode-hook
    (cl-hooks))

  (on-hook sly-mode-hook
    ;; Sly auto-installs its own indetantion function, which seems to be loaded
    ;; first when mrepl is loaded.
    ;; That results with Emacs ending up in the debugger when I try to indent a
    ;; Lisp file without a connection or mrepl loaded.
    ;; This is my temporary fix for the situation:
    (unless (functionp (symbol-function 'sly-common-lisp-indent-function))
      (let ((sly-dir (file-name-directory (find-library-name "sly"))))
        (add-to-list 'load-path (expand-file-name "lib" sly-dir))
        (add-to-list 'load-path (expand-file-name "contrib" sly-dir))
        (require 'sly-autodoc)
        (require 'sly-indentation))))
#+end_src
** [ ] sly-asdf
#+begin_src emacs-lisp

#+end_src
** [ ] sly-macrostep
#+begin_src emacs-lisp
#+end_src
** [ ] sly-named-readtables
#+begin_src emacs-lisp
#+end_src
** [ ] sly-quicklisp
#+begin_src emacs-lisp

#+end_src
** [x] academic-phrases
#+begin_src emacs-lisp
#+end_src
** [x] ace-window
#+begin_src emacs-lisp
(on-package ace-window
  (ace-window-display-mode 1)
  ;;(setq aw-dispatch-always t)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src
** [x] activities
#+begin_src emacs-lisp

#+end_src
** [x] ascii-table
#+begin_src emacs-lisp
#+end_src
** [x] async
#+begin_src emacs-lisp
(on-package
  async
  (async-bytecomp-package-mode 1)
  (on-system windows-nt
    ;; https://gist.github.com/kiennq/cfe57671bab3300d3ed849a7cbf2927c
    (eval-when-compile
      (require 'cl-lib))
    (defvar async-maximum-parallel-procs 4)
    (defvar async--parallel-procs 0)
    (defvar async--queue nil)
    (defvar-local async--cb nil)
    (advice-add #'async-start :around
                (lambda (orig-func func &optional callback)
                  (when (>= async--parallel-procs async-maximum-parallel-procs)
                    (push `(,func ,callback) async--queue)
                    (cl-incf async--parallel-procs)
                    (let ((future (funcall orig-func func
                                           (lambda (re)
                                             (cl-decf async--parallel-procs)
                                             (when async--cb (funcall async--cb re))
                                             (when-let (args (pop async--queue))
                                               (apply #'async-start args))))))
                      (with-current-buffer (process-buffer future)
                        (setq async--cb callback))))))))
(on-hook dired-async-mode-hook (diminish 'dired-async-mode))
#+end_src
** [x] beacon
#+begin_src emacs-lisp
(on-package init (on-idle (beacon-mode t)))
(on-hook beacon-mode-hook (diminish 'beacon-mode))
#+end_src
** [x] buttercup
#+begin_src emacs-lisp
#+end_src
** [x] checkdoc
#+begin_src emacs-lisp
#+end_src
** [x] common-lisp-snippets
#+begin_src emacs-lisp

#+end_src
** [x] company
#+begin_src emacs-lisp
(on-package company
  (setf company-selection-wrap-around t
        company-idle-delay 0))
#+end_src
** [x] consult
#+begin_src emacs-lisp

#+end_src

** [x] crux
#+begin_src emacs-lisp
#+end_src
** [x] diminish
#+begin_src emacs-lisp
#+end_src
** [x] dired-auto-readme
#+begin_src emacs-lisp

#+end_src
** [x] dired-hacks-utils
#+begin_src emacs-lisp
#+end_src
** [x] dired-narrow
#+begin_src emacs-lisp
#+end_src
** [x] dired-quick-sort
#+begin_src emacs-lisp
#+end_src
** [x] dired-subtree
#+begin_src emacs-lisp
(on-package init (on-idle (require 'dired-subtree)))
(on-package dired-subtree
  (setq dired-subtree-line-prefix "    "
        dired-subtree-use-backgrounds nil))
#+end_src
** [x] disable-mouse
#+begin_src emacs-lisp

#+end_src
** [x] eask
#+begin_src emacs-lisp

#+end_src
** [x] elisp-benchmarks
#+begin_src emacs-lisp

#+end_src
** [x] elnode
#+begin_src emacs-lisp
#+end_src
** [x] el-search
#+begin_src emacs-lisp
#+end_src
** [x] eros
#+begin_src emacs-lisp

#+end_src

** [x] expand-region
#+begin_src emacs-lisp
(on-package init
  (defkeys global-map
    "C-+" er/expand-region
    "C--" er/contract-region))
(on-hook expand-region-mode-hook
  (diminish 'expand-region-mode))
#+end_src
** [x] feebleline
#+begin_src emacs-lisp
#+end_src
** [x] flimenu
#+begin_src emacs-lisp
(on-package flimenu
  (flimenu-global-mode))
#+end_src
** [x] flycheck
#+begin_src emacs-lisp
#+end_src
** [x] flycheck-package
#+begin_src emacs-lisp
#+end_src
** [x] gh
#+begin_src emacs-lisp
#+end_src
** [x] gif-screencast
#+begin_src emacs-lisp
(on-package gif-screencast
  (setf gif-screencast-convert-args
        (append (list "-resize" "1024x") gif-screencast-convert-args)
        ;; gif-screencast-capture-prefer-internal t
        gif-screencast-capture-format "svg")
  (defkeys global-map
    "C-x <f5>" gif-screencast)
  (defkeys gif-screencast-mode-map
    "C-x <f5>" gif-screencast-start-or-stop))
#+end_src
** [x] gist
#+begin_src emacs-lisp
#+end_src
** [x] git-gutter
#+begin_src emacs-lisp
(on-hook git-gutter-mode-hook
  (setq git-gutter:update-interval 0.02))
#+end_src
** [x] git-gutter-fringe
#+begin_src emacs-lisp
(on-package git-gutter-fringe
  (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
  (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
  (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+end_src
** [x] github-clone
#+begin_src emacs-lisp
#+end_src
** [x] github-search
#+begin_src emacs-lisp
#+end_src
** [x] git-link
#+begin_src emacs-lisp
#+end_src
** [x] git-messenger
#+begin_src emacs-lisp
#+end_src
** [x] gnu-elpa-keyring-update
#+begin_src emacs-lisp
#+end_src
** [x] google-c-style
#+begin_src emacs-lisp
(on-hook google-c-style-mode-hook
  (diminish 'google-c-style-mode))
#+end_src
** [x] goto-last-change
#+begin_src emacs-lisp
#+end_src
** [x] helm
#+begin_src emacs-lisp
(on-package init
  (on-idle
    (require 'helm-setup)))

(on-package init
  (require 'helm-setup)
  (defkeys global-map
    "M-x"     helm-M-x
    "C-z ,"   helm-pages
    "C-x C-b" helm-buffers-list
    "C-z a"   helm-do-grep-ag
    "C-z b"   helm-filtered-bookmarks
    "C-z d"   helm-dabbrev
    "C-z e"   helm-calcul-expression
    "C-z g"   helm-google-suggest
    "C-z h"   helm-descbinds
    "C-z i"   helm-imenu-anywhere
    "C-z k"   helm-show-kill-ring
    "C-z f"   helm-find-files
    "C-z m"   helm-mini
    "C-z o"   helm-occur
    "C-z p"   helm-browse-project
    "C-z q"   helm-apropos
    "C-z r"   helm-recentf
    "C-z s"   helm-swoop
    "C-z C-c" helm-colors
    "C-z x"   helm-M-x
    "C-z y"   helm-yas-complete
    "C-z SPC" helm-all-mark-rings))
#+end_src
** [x] helm-comint
#+begin_src emacs-lisp

#+end_src
** [x] helm-c-yasnippet
#+begin_src emacs-lisp
(on-package helm-c-yasnippet
  (setq helm-yas-space-match-any-greedy t))
#+end_src
** [x] helm-dash
#+begin_src emacs-lisp
#+end_src
** [x] helm-descbinds
#+begin_src emacs-lisp
#+end_src
** [x] helm-flyspell
#+begin_src emacs-lisp
#+end_src
** [x] helm-fuzzier
#+begin_src emacs-lisp
#+end_src
** [x] helm-make
#+begin_src emacs-lisp
#+end_src
** [x] helm-navi
#+begin_src emacs-lisp
#+end_src
** [x] helm-org
#+begin_src emacs-lisp
#+end_src
** [x] helm-pages
#+begin_src emacs-lisp
#+end_src
** [x] helm-projectile
#+begin_src emacs-lisp
#+end_src
** [x] helm-rg
#+begin_src emacs-lisp

#+end_src

** [x] helm-smex
#+begin_src emacs-lisp
#+end_src
** [x] helm-xref
#+begin_src emacs-lisp
#+end_src
** [x] helpful
#+begin_src emacs-lisp

#+end_src
** [x] hnreader
#+begin_src emacs-lisp

#+end_src
** [x] ht
#+begin_src emacs-lisp
#+end_src
** [x] htmlize
#+begin_src emacs-lisp
#+end_src

** [x] hydra
#+begin_src emacs-lisp

#+end_src

** [x] igist
#+begin_src emacs-lisp

#+end_src
** [x] imenu-anywhere
#+begin_src emacs-lisp
#+end_src
** [x] import-js
#+begin_src emacs-lisp
#+end_src
** [x] inf-elixir
#+begin_src emacs-lisp

#+end_src

** [x] jq-mode
#+begin_src emacs-lisp

#+end_src
** [x] keycast
#+begin_src emacs-lisp

#+end_src

** [x] keycast
#+begin_src emacs-lisp
#+end_src
** [x] kv
#+begin_src emacs-lisp
#+end_src
** [x] lusty-explorer
#+begin_src emacs-lisp
#+end_src
** [x] macro-math
#+begin_src emacs-lisp
#+end_src
** [x] macrostep
#+begin_src emacs-lisp
;;(on-hook edebug-mode (macrostep-mode +1))
#+end_src

** [x] magit
#+begin_src emacs-lisp
#+end_src
** [x] magit-filenotify
#+begin_src emacs-lisp
#+end_src
** [x] magit-gh-pulls
#+begin_src emacs-lisp
#+end_src

** [x] markdown-mode
#+begin_src emacs-lisp
  (on-package markdown-mode
    (defkeys markdown-mode-map
      "M-n" scroll-up-line
      "M-p" scroll-down-line
      "M-N" scroll-up-command
      "M-P" scroll-down-command)
    (defkeys markdown-view-mode-map
      "M-n" scroll-up-line
      "M-p" scroll-down-line
      "M-N" scroll-up-command
      "M-P" scroll-down-command))
#+end_src
** [x] marshal
#+begin_src emacs-lisp
#+end_src
** [x] modern-cpp-font-lock
#+begin_src emacs-lisp
(on-hook modern-cpp-font-lock-mode-hook
  (diminish 'modern-cpp-font-lock-mode))
#+end_src
** [x] nov
#+begin_src emacs-lisp
(on-package init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+end_src
** [x] ob-async
#+begin_src emacs-lisp
#+end_src
** [x] org-appear
#+begin_src emacs-lisp
#+end_src
** [x] org-bullets
#+begin_src emacs-lisp

#+end_src
** [x] org-contrib
#+begin_src emacs-lisp
#+end_src

** [x] org-download
#+begin_src emacs-lisp
#+end_src
** [x] org-projectile
#+begin_src emacs-lisp
(on-package org-projectile
  (require 'org-projectile)
  (setq org-projectile-projects-file "~Dokument/todos.org"
        org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
  (push (org-projectile-project-todo-entry) org-capture-templates)

  (defkeys global-map
    "C-c n p" org-projectile-project-todo-completing-read
    "C-c c" org-capture))
#+end_src
** [x] org-projectile-helm
#+begin_src emacs-lisp
#+end_src
** [x] org-ref
#+begin_src emacs-lisp
#+end_src

** [x] org-superstar
#+begin_src emacs-lisp
#+end_src
** [x] org-view-mode
#+begin_src emacs-lisp

#+end_src

** [x] origami
#+begin_src emacs-lisp

#+end_src

** [x] outli
#+begin_src emacs-lisp

#+end_src

** [x] package-lint
#+begin_src emacs-lisp
#+end_src
** [x] page-break-lines
#+begin_src emacs-lisp
(on-hook page-break-lines-mode-hook (diminish 'page-break-lines-mode))
#+end_src
** [x] paxedit
#+begin_src emacs-lisp

#+end_src
** [x] posframe
#+begin_src emacs-lisp

#+end_src

** [x] prettier-js
#+begin_src emacs-lisp
(on-package prettier-js
  (diminish 'prettier-js-mode))
(on-hook js2-mode-hook
  (prettier-js-mode))
(on-hook rjsx-mode-hook
  (prettier-js-mode))
#+end_src
** [x] pretty-symbols
#+begin_src emacs-lisp
#+end_src
** [x] projectile
#+begin_src emacs-lisp
(on-package projectile
  (setq projectile-indexing-method 'alien))
#+end_src
** [x] pulseaudio-control
#+begin_src emacs-lisp
#+end_src
** [x] quick-peek
#+begin_src emacs-lisp

#+end_src
** [x] refine
#+begin_src emacs-lisp
#+end_src
** [x] request
#+begin_src emacs-lisp
#+end_src
** [x] rjsx-mode
#+begin_src emacs-lisp
(on-package rjsx-mode
  (setq js2-mode-show-parse-errors nil
        js2-mode-show-strict-warnings nil
        js2-basic-offset 2
        js-indent-level 2)
  (setq-local flycheck-disabled-checkers (cl-union flycheck-disabled-checkers
                                                   '(javascript-jshint))) ; jshint doesn't work for JSX
  (electric-pair-mode 1))
(on-package init
  (add-to-list 'auto-mode-alist '("\\.js\\'" . rjsx-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx\\'" . rjsx-mode)))
#+end_src
** [x] sentex
#+begin_src emacs-lisp

#+end_src
** [x] slime
#+begin_src emacs-lisp
(on-package slime
  (add-to-list 'load-path (expand-file-name "~/repos/el/emacs-configs/slime-star/"))
  (setf inferior-lisp-program "sbcl"
        slime-contribs '(slime-fancy slime-star))
  (defkeys slime-mode-map
    "M-n"   scroll-up-line
    "M-S-n" scroll-up-command
    "M-p"   scroll-down-line
    "M-S-p" scroll-down-command))
#+end_src

** [x] slime-company
#+begin_src emacs-lisp

#+end_src

** [x] solarized-theme
#+begin_src emacs-lisp
     ;; (on-package
     ;;  solarized
     ;;  (load-theme 'solarized-dark t))
#+end_src
** [x] super-save
#+begin_src emacs-lisp
(on-package super-save
  ;; add integration with ace-window
  (add-to-list 'super-save-triggers 'ace-window)
  ;; save on find-file
  (add-to-list 'super-save-hook-triggers 'find-file-hook)
  (setf super-save-remote-files nil
        super-save-idle-duration 0.5
        super-save-auto-save-when-idle t
        super-save-exclude '(".gpg")
        super-save-silent t
        super-save-triggers
        (append super-save-triggers
                '(emacs-lisp-byte-compile
                  emacs-lisp-byte-compile-and-load
                  emacs-lisp-native-compile-and-load))))
(on-hook super-save-mode-hook (diminish 'super-save))
#+end_src
** [x] web-mode
#+begin_src emacs-lisp

#+end_src

** [x] window-layout
#+begin_src emacs-lisp

#+end_src

** [x] window-layout
#+begin_src emacs-lisp

#+end_src

** [x] winum
#+begin_src emacs-lisp
#+end_src
** [x] with-simulated-input
#+begin_src emacs-lisp
#+end_src
** [x] yasnippet
#+begin_src emacs-lisp

  (eval-when-compile
    (require 'yasnippet-snippets))

  (on-idle (require 'yasnippet))

  (on-package yasnippet
    (require 'yasnippet-snippets)
    (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
    (setq yas-key-syntaxes '("w_" "w_." "^ ")
          yas-expand-only-for-last-commands nil)
    (defkeys yas-minor-mode-map
      "C-i" nil
      "TAB" nil
      "C-<tab>" yas-expand
      "M-_" yas-undo-expand))

  (on-hook yas-minor-mode-hook
    (diminish 'yas-mode 'yas-minor-mode))
#+end_src
** [x] yasnippet-snippets
#+begin_src emacs-lisp
#+end_src
** [ vc    ] [x] dired-setup
#+url https://github.com/amno1/dired-setup
#+begin_src emacs-lisp
(on-package init (dired-setup))
#+end_src
** [ vc    ] [x] edebug-x
#+url https://github.com/amno1/edebug-x
#+begin_src emacs-lisp

#+end_src

** [ vc    ] [x] elisp-ergo-mode
#+url https://github.com/amno1/elisp-ergo-mode
#+begin_src emacs-lisp

#+end_src

** [ vc    ] [x] help-extras
#+url https://github.com/amno1/help-extras
#+begin_src emacs-lisp

#+end_src
** [ vc    ] [x] peep-dired
#+url https://github.com/amno1/peep-dired
#+begin_src emacs-lisp

#+end_src

** [ none  ] [ ] top-override-keymap
#+begin_src emacs-lisp
(on-package top-override-keymap
  (defkeys top-override-keymap-mode-map
    "M-n"   scroll-up-line
    "M-p"   scroll-down-line
    "M-S-n" scroll-up-command
    "M-S-p" scroll-down-command))
#+end_src

** [ none  ] [x] abbrev
#+begin_src emacs-lisp
(on-package abbrev
  (diminish 'abbrev-mode))
#+end_src
** [ none  ] [x] c/c++
#+begin_src emacs-lisp
(on-package init
  (add-hook 'c-initialization-hook 'my-c-init)
  (add-hook 'c++-mode-hook 'my-c++-init)
  (add-to-list 'auto-mode-alist '("\\.\\(c\\|h\\|inc\\|src\\)\\'" . c-mode))
  (add-to-list 'auto-mode-alist '("\\.\\(|hh\\|cc\\|c++\\|cpp\\|tpp\\|hpp\\|hxx\\|cxx\\|inl\\|cu\\)'" . c++-mode))
  (on-idle  (require 'c++-setup)))
#+end_src
** [ none  ] [x] dap-java
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] early-init
#+begin_src emacs-lisp
(on-package early-init
  (defvar yas-alias-to-yas/prefix-p nil)
  (defvar default-gc-cons-threshold gc-cons-threshold)
  (defvar old-file-name-handler file-name-handler-alist)

  (on-system windows-nt
    (push "C:/msys64/usr/bin/" exec-path))

  (setq file-name-handler-alist nil
        switch-to-buffer-obey-display-actions t
        debug-on-error t
        gc-cons-threshold most-positive-fixnum
        frame-inhibit-implied-resize t
        bidi-inhibit-bpa t
        initial-scratch-message ""
        inhibit-splash-screen t
        inhibit-startup-screen t
        inhibit-startup-message t
        inhibit-startup-echo-area-message t
        show-paren-delay 0
        use-dialog-box nil
        visible-bell nil
        ring-bell-function 'ignore
        load-prefer-newer t
        shell-command-default-error-buffer "Shell Command Errors"
        native-comp-async-report-warnings-errors 'silent
        comp-speed 3)

  (when 'native-comp-compiler-options
    (setq native-comp-async-jobs-number 4))

  (setq-default abbrev-mode t
                indent-tabs-mode nil
                indicate-empty-lines t
                cursor-type 'bar
                fill-column 80
                auto-fill-function 'do-auto-fill
                cursor-in-non-selected-windows 'hollow
                bidi-display-reordering 'left-to-right
                bidi-paragraph-direction 'left-to-right)
  (push '(fullscreen . maximized) initial-frame-alist)
  (push '(fullscreen . maximized) default-frame-alist)
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars . nil) default-frame-alist)
  (push '(font . "Anonymous Pro-20") default-frame-alist)

  (setq show-paren-style 'expression
        use-short-answers t
        auto-insert-query nil
        message-log-max 10000 ;; original 1000
        undo-outer-limit 37000000
        shell-command-switch "-c"
        delete-exited-processes t
        echo-keystrokes 0.1
        create-lockfiles nil
        winner-dont-bind-my-keys t
        auto-windo-vscroll nil
        split-width-threshold 0
        split-height-threshold nil
        bookmark-save-flag 1
        delete-selection-mode t
        initial-major-mode 'emacs-lisp-mode
        confirm-kill-processes nil
        help-enable-symbol-autoload t
        large-file-warning-threshold nil
        save-abbrevs 'silent
        save-silently t
        save-interprogram-paste-before-kill t
        save-place-file (expand-file-name "places" user-emacs-directory)
        max-lisp-eval-depth '100000
        scroll-preserve-screen-position 'always
        scroll-conservatively 1
        maximum-scroll-margin 1
        mouse-autoselect-window t
        scroll-margin 0
        make-backup-files nil
        vc-make-backup-files nil
        vc-display-status nil
        ;;vc-handled-backends nil
        kill-buffer-delete-auto-save-files t
        backup-directory-alist `(("." . ,user-emacs-directory))
        custom-file (expand-file-name "custom.el" user-emacs-directory)
        bookmark-default-file (expand-file-name "bookmarks" user-emacs-directory)
        default-licence "GPL 3.0")

  (let ((default-directory  (expand-file-name "lisp" user-emacs-directory)))
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
  (let ((deff (gethash 'default face--new-frame-defaults)))
    (aset (cdr deff) 4 440)
    (puthash 'default deff face--new-frame-defaults))
  (define-prefix-command 'C-z-map)
  (global-set-key (kbd "C-z") 'C-z-map)
  (global-unset-key (kbd "C-v"))
  ;;define a setc function for use in init file
  (put 'setc 'byte-optimizer 'byte-compile-inline-expand))
#+end_src
** [ none  ] [x] eglot
#+begin_src emacs-lisp
(on-package
  eglot
  (fset #'jsonrpc--log-event #'ignore)
  (setq eglot-events-buffer-size 0)
  (setq eglot-sync-connect nil)
  (setq eglot-connect-timeout nil)
  (push :inlayHintProvider eglot-ignored-server-capabilities)
  ;;(advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
  ;;(advice-add 'eglot-completion-at-point :around #'cape-wrap-noninterruptible)
  )
#+end_src

** [ none  ] [x] emacs
#+begin_src emacs-lisp
(on-hook text-mode-hook
  (auto-fill-mode -1)
  (visual-line-mode +1))
(on-hook abbrev-mode-hooke (diminish 'abbrev-mode))
(on-hook auto-complete-mode-hook (diminish 'auto-complete-mode))
(on-hook auto-fill-mode-hook (diminish 'auto-fill-function))
(on-hook auto-insert-mode-hook
  (setq auto-insert-query nil)
  (diminish 'auto-insert-mode))
(on-hook edit-abbrevs-mode-hook (diminish 'abbrev-mode))
(on-hook eldoc-mode-hook (diminish 'eldoc-mode))
(on-hook electric-pair-mode-hook (diminish 'electric-pair-mode))
(on-hook subword-mode-hook (diminish 'subword-mode))
(on-hook wrap-region-mode-hook (diminish 'wrap-region-mode))
(on-hook winner-mode-hook (diminish 'winner-mode))
(on-hook term-mode-hook
  (goto-address-mode)
  (defkeys term-raw-map
    "C-y" ansi-term-paste-string))

(on-package init

  (eval-when-compile (require 'cl-macs))
  
  (when (eq system-type 'windows-nt)
    (setq w32-get-true-file-attributes nil
          w32-pipe-read-delay 0
          w32-pipe-buffer-size (* 64 1024)
          source-directory "~/repos/em2/emacs"
          command-line-x-option-alist nil
          command-line-ns-option-alist nil
          browse-url-galeon-program (getenv "BROWSER")
          browse-url-netscape-program browse-url-galeon-program)

    (when (getenv "MSYSTEM") (setq package-gnupghome-dir "")))

  (setq
        auto-insert-query nil
        auto-window-vscroll nil
        split-width-threshold 0
        split-height-threshold nil
        bookmark-save-flag 1
        save-place-file (expand-file-name "places" user-emacs-directory)
        max-lisp-eval-depth '100000
        bookmark-default-file (expand-file-name "bookmarks" user-emacs-directory)
        default-licence "GPL 3.0")

  (push '("\\*Compile-Log\\*" (display-buffer-no-window)) display-buffer-alist)
  (push `       ((,(rx bos (or "*Apropos*" "*Help*" "*helpful*" "*info*" "*Summary*")
                (0+ not-newline))
           (display-buffer-same-window
            display-buffer-reuse-mode-window
            display-buffer-pop-up-window)
           (mode apropos-mode help-mode helpful-mode Info-mode Man-mode)))
        display-buffer-alist)

  (push '(("*Help*" (window-parameters . ((dedicated . t))))) display-buffer-alist)
  (push (expand-file-name "~/repos/ready-lisp/doc/info") Info-directory-list)
  (setq find-file-hook (delq 'vc-refresh-state find-file-hook))

  (fset 'vc-backend 'ignore)
  (electric-indent-mode 1)
  (electric-pair-mode 1)
  (global-auto-revert-mode)
  (global-hl-line-mode 1)
  (global-subword-mode 1)
  (auto-compression-mode 1)
  (auto-image-file-mode)
  (auto-insert-mode 1)
  ;;(auto-save-visited-mode 1)
  (blink-cursor-mode 1)
  (column-number-mode 1)
  (delete-selection-mode 1)
  (display-time-mode t)
  (pending-delete-mode 1)
  (show-paren-mode t)
  (save-place-mode 1)
  (winner-mode t)
  (turn-on-auto-fill)
  (pixel-scroll-precision-mode +1)
  (bash-alias-mode +1)
  (which-key-mode +1)
  (super-save-mode +1)
  (help-details-mode +1)
  (help-remote +1)
  ;; (global-top-override-keymap-mode +1)

  (defkeys global-map
    ;;"C-v C-t"       term-toggle-ielm
    [f9]            ispell-word
    [S-f10]         next-buffer
    [C-enter]       other-window
    [M-S-f10]       next-buffer-other-window
    [f8]            last-buffer
    [f10]           previous-buffer
    [M-f10]         previous-buffer-other-window
    [M-f12]         kill-buffer-other-window
    [f12]           kill-buffer-but-not-some
    [C-M-f12]       only-current-buffer
    [C-return]      other-window
    "C-;"           do-in-other-window
    "C-M-:"         do-to-this-in-other-window
    "C-:"           do-to-this-and-stay-in-other-window
    ;; Emacs windows
    "C-v <left>"   windmove-swap-states-left
    "C-v <right>"  windmove-swap-states-right
    "C-v <up>"     windmove-swap-states-up
    "C-v <down>"   windmove-swap-states-down
    "C-v o"        other-window
    "C-v j"        windmove-left
    "C-v l"        windmove-right
    "C-v i"        windmove-up
    "C-v k"        windmove-down
    "C-v a"        send-to-window-left
    "C-v d"        send-to-window-right
    "C-v w"        send-to-window-up
    "C-v s"        send-to-window-down
    ;; "C-v v"        maximize-window-vertically
    ;; "C-v h"        maximize-window-horizontally
    "C-v n"        next-buffer
    "C-v p"        previous-buffer
    "C-v +"        text-scale-increase
    "C-v -"        text-scale-decrease
    "C-v C-+"      enlarge-window-horizontally
    "C-v C-,"      enlarge-window-vertically
    "C-v C--"      shrink-window-horizontally
    "C-v C-."      shrink-window-vertically
    "C-v u"        winner-undo
    "C-v r"        winner-redo
    "C-v C-k"      delete-window
    "C-v C-l"      windmove-delete-left
    "C-v C-r"      windmove-delete-right
    "C-v C-a"      windmove-delete-up
    "C-v C-b"      windmove-delete-down
    "C-v <return>" delete-other-windows
    "C-v ,"        split-window-right
    "C-v ."        split-window-below
    ;;"C-h M-i"      help-toggle-source-view
    ;; "C-v C-s"      swap-two-buffers
    [remap other-window]  ace-window
    [remap find-file-other-window]  ff-other-window
    ;; cursor movement
    "M-n"     scroll-up-line
    "M-N"     scroll-up-command
    "M-p"     scroll-down-line
    "M-P"     scroll-down-command
    "C-v c"   org-capture
    "C-v C-c" avy-goto-char
    "C-v C-v" avy-goto-word-1
    "C-v C-w" avy-goto-word-0
    "C-v C-g" avy-goto-line
    "C-z a"   helm-do-grep-ag
    ;; some random stuff
    "C-h C-i" (lambda()
                (interactive)
                (find-file (expand-file-name
                            "init.org"
                            user-emacs-directory))))

  (on-host "emmi"
    ;; this laptop runs Arch Linux and translates numeric keypad somewhat differently
    ;; than my desktop which runs both Arch Linux and Windows 10 (Razor keyboard)
    ;; (defkeys global-map
    ;;   "C-0"      term-toggle-term
    ;;   "S-0"      term-toggle-eshell)
    )

  (on-host "pascal"
    (defkeys global-map
      "C-<insert>"      term-toggle-term
      "<insert"         term-toggle-eshell))

  (on-idle (require 'which-key))
  (on-idle (require 'extras))
  (on-idle (require 'sv-kalender)
    ;;(add-to-list 'special-display-frame-alist '(tool-bar-lines . 0))
    (when (and custom-file (file-exists-p custom-file))
      (load custom-file 'noerror))
    (add-hook 'comint-output-filter-functions
              #'comint-watch-for-password-prompt))

  (load-theme 'solarized-dark t)
  (setq gc-cons-threshold       default-gc-cons-threshold
        ;;gc-cons-percentage      0.1
        file-name-handler-alist old-file-name-handler))
#+end_src

** [ none  ] [x] emacs-director
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] emacs-run-command
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] emacs-velocity
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] gnus
#+begin_src emacs-lisp
(on-package init
  (require 'gnus))

(on-hook message-mode-hook
  (setq fill-column 72))

(on-package gnus

  ;; (require 'nnir)
  (setq user-full-name    "Arthur Miller"
        user-mail-address "arthur.miller@live.com")
  (setq gnus-select-method '(nnnil ""))
  ;; for the outlook
  (setq gnus-secondary-select-methods
        '((nnimap "live.com"
                 (nnimap-address "imap-mail.outlook.com")
                 (nnimap-server-port 993)
                 (nnimap-stream starttls)
                 (nnimap-search-engine imap)
                 (nnimap-authinfo-file "~/.authinfo"))))

  ;; Send email through SMTP
  (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-default-smtp-server "smtp-mail.outlook.com"
        smtpmail-smtp-service 587
        smtpmail-stream-type 'starttls
        smtpmail-local-domain "homepc"
)

  (setq gnus-thread-sort-functions
        '(gnus-thread-sort-by-most-recent-date
          (not gnus-thread-sort-by-number)))
  (setq gnus-use-cache t gnus-view-pseudo-asynchronously t)
  ;; Show more MIME-stuff:
  (setq gnus-mime-display-multipart-related-as-mixed t)
  ;; http://www.gnu.org/software/emacs/manual/html_node/gnus/_005b9_002e2_005d.html
  (setq gnus-use-correct-string-widths nil)
  ;;(setq nnmail-expiry-wait 'immediate)
  ;; set renderer for html mail to w3m in emacs
  ;;(setq mm-text-html-renderer 'eww)
  (setq gnus-inhibit-images nil)
  ;; set gnus-parameter
  ;; (setq gnus-parameters
  ;;       '(("nnimap.*"
  ;;          (gnus-use-scoring nil)
  ;;          (expiry-wait . 2)
  ;;          (display . all))))

  ;;[[http://stackoverflow.com/questions/4982831/i-dont-want-to-expire-mail-in-gnus]]
  ;;(setq gnus-large-newsgroup 'nil)
  ;; Smileys:
  (setq smiley-style 'medium)
  (setq gnus-fetch-old-headers 'some)
  ;; Use topics per default:
  (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
  (setq gnus-message-archive-group '((format-time-string "sent.%Y")))
  (setq gnus-server-alist '(("archive" nnfolder "archive" (nnfolder-directory "~/mail/archive")
                             (nnfolder-active-file "~/mail/archive/active")
                             (nnfolder-get-new-mail nil)
                             (nnfolder-inhibit-expiry t))))

  (setq gnus-topic-topology '(("live.com" visible)))

  ;; each topic corresponds to a public imap folder
  (setq gnus-topic-alist '(("live.com")
                           ("Gnus"))))
#+end_src
** [ none  ] [x] helm-convert
#+begin_src emacs-lisp
#+end_src
** [ none  ] [x] ielm
#+begin_src emacs-lisp
(on-package
  ielm
  (require 'elisp-ergo-mode)
  (advice-add 'ielm :around #'ielm-use-current-buffer)
  ;;(advice-add 'ielm-eval-inpu :after #'paredit-open-round)
  (defkeys ielm-map
    "\C-c a" emacs-lisp-byte-compile-and-load
    "\C-c b" emacs-lisp-byte-compile
    "\C-c c" emacs-lisp-native-compile-and-load
    "\C-c d" eval-defun
    "\C-c e" eval-buffer
    "\C-c r" eval-region
    "\C-c l" eval-last-sexp
    "\C-c n" eval-next-sexp
    "\C-c i" reindent-buffer
    "\C-c p" fc-eval-and-replace
    "\C-c s" eval-surrounding-sexp)
  (require 'paredit)
  (define-key paredit-mode-map (kbd "RET") nil)
  (define-key paredit-mode-map (kbd "C-j") 'paredit-newline))

(on-hook ielm-mode-hook
  ;;(ielm-change-working-buffer (other-window-buffer -1))
  (paredit-mode +1)
  (turn-on-eldoc-mode))
#+end_src
** [ none  ] [x] inferior-python-mode
#+begin_src emacs-lisp
(on-hook inferior-python-mode-hook
  (hide-mode-line-mode))
#+end_src
** [ none  ] [x] info
#+begin_src emacs-lisp
(on-package info
  (defkeys Info-mode-map
    "M-n" nil))
#+end_src

** [ none  ] [x] lisp & elisp
#+begin_src emacs-lisp
(on-idle (require 'cl-extras))

(on-package elisp-mode
  (require 'elisp-ergo-mode))

(on-package init
  (set-default
   'auto-mode-alist
   (append '(("\\.lisp" . lisp-mode)
             ("\\.lsp" . lisp-mode)
             ("\\.asd" . lisp-mode)
             ("\\.cl" . lisp-mode))
           auto-mode-alist)))

(on-package inf-lisp (require 'cl-extras))
(on-hook lisp-mode-hook (require 'cl-extras))
(on-hook emacs-lisp-mode-hook (elisp-ergo-mode +1))
(on-hook inf-lisp-mode-hook (cl-hooks))
(on-hook lisp-mode-hook (cl-hooks))
#+end_src
** [ none  ] [x] org
#+begin_src emacs-lisp
  (on-hook org-mode-hook
    (auto-fill-mode -1)
    (visual-line-mode +1)
    (when (equal (buffer-name) "init.org")
      (auto-save-mode 1)
      (page-break-lines-mode 1))
    (yas-minor-mode 1))

  (on-package org
    (require 'org-extras))

  ;;  (defkeys org-mode-map
  ;;     [C-<enter>] other-window
  ;;     [C-S-<return>] org-insert-heading-respect-content))
 #+end_src
** [ none  ] [x] paredit
#+begin_src emacs-lisp
(on-package paredit
  (defkeys paredit-mode-map
    "C-8" paredit-backward-slurp-sexp
    "C-9" paredit-forward-slurp-sexp
    "C-7" paredit-backward-barf-sexp
    "C-0" paredit-forward-barf-sexp
    "M-8" paredit-wrap-round
    "M-9" paredit-close-round-and-newline
    "C-." paredit-forward
    "C-," paredit-backward))
#+end_src
** [ none  ] [x] recentf
#+begin_src emacs-lisp
(on-idle
  (recentf-mode +1)
  (diminish 'recentf-mode)
  (setf recentf-max-saved-items 100))
#+end_src
** [ none  ] [x] term-toggle    
#+begin_src emacs-lisp
(on-package term-toggle
  (setq term-toggle-no-confirm-exit t
        term-toggle-kill-buffer-on-term-exit t))
#+end_src
** [ none  ] [x] wdired
#+begin_src emacs-lisp
(on-package wdired
  (defkeys wdired-mode-map
    "<return>"    dired-find-file
    "M-<return>"  my-run
    "S-<return>"  dired-openwith
    "M-<"         dired-go-to-first
    "M->"         dired-go-to-last
    "M-p"         scroll-down-line))
#+end_src
** [ none  ] [x] which-key
#+begin_src emacs-lisp
(on-package which-key
  (setq which-key-idle-delay 0.01)
  (which-key-mode))
(on-hook which-key-mode-hook
  (diminish 'which-key-mode)
  (which-key-setup-minibuffer))
#+end_src
